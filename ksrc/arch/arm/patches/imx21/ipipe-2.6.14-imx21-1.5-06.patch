diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp ipipe-2.6.14-arm-imx21/arch/arm/kernel/process.c ipipe-2.6.14-imx21/arch/arm/kernel/process.c
--- ipipe-2.6.14-arm-imx21/arch/arm/kernel/process.c	2007-01-20 16:51:27.258746384 +0100
+++ ipipe-2.6.14-imx21/arch/arm/kernel/process.c	2007-01-20 15:58:52.570225827 +0100
@@ -39,6 +39,10 @@ extern void setup_mm_for_reboot(char mod
 
 static volatile int hlt_counter;
 
+#ifdef CONFIG_IPIPE
+static volatile int idle_mode = 1; 
+#endif
+
 #include <asm/arch/system.h>
 
 void disable_hlt(void)
@@ -67,6 +71,27 @@ static int __init hlt_setup(char *__unus
 	return 1;
 }
 
+#ifdef CONFIG_IPIPE
+static int __init idle_setup(char *str)
+{
+	if(!strncmp(str, "poll",strlen("poll"))) {
+		idle_mode = 0;
+		printk(KERN_INFO
+	       	       "I-pipe : CPU idle mode selected : %s\n",
+	               str);
+	}
+	else {
+		idle_mode = 1;
+		printk(KERN_INFO
+	       	       "I-pipe : Unknown CPU idle mode : %s -> default mode selected\n",
+	               str);
+	}
+	return 1;
+
+}
+__setup("idle=", idle_setup);
+#endif
+
 __setup("nohlt", nohlt_setup);
 __setup("hlt", hlt_setup);
 
@@ -117,7 +142,18 @@ void cpu_idle(void)
 		preempt_disable();
 		leds_event(led_idle_start);
 		while (!need_resched())
+#ifdef CONFIG_IPIPE
+		//Test if the kernel start with polling
+		//option for the idle of CPU
+		if(idle_mode == 0) {
+			;
+                }
+		else {
 			idle();
+		}	
+#else
+		idle();
+#endif
 		leds_event(led_idle_end);
 		preempt_enable();
 		schedule();
diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp ipipe-2.6.14-arm-imx21/arch/arm/mach-imx21/irq.c ipipe-2.6.14-imx21/arch/arm/mach-imx21/irq.c
--- ipipe-2.6.14-arm-imx21/arch/arm/mach-imx21/irq.c	2007-01-20 16:57:08.564284059 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/irq.c	2007-01-20 16:45:17.557741430 +0100
@@ -23,6 +23,12 @@
  *  03/03/2004   Sascha Hauer <sascha@saschahauer.de>
  *               Copied from the motorola bsp package and added gpio demux
  *               interrupt handler
+ *
+ * April 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board with Xenomai by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ * 
   */
 #include <linux/init.h>
 extern int x1;
@@ -181,6 +187,40 @@ imx21_gpio_handler(unsigned int irq_unus
     }
 }
 
+#ifdef CONFIG_IPIPE
+void __ipipe_mach_demux_irq(unsigned irq_unused, struct pt_regs *regs)
+{
+    struct irqdesc *desc, *desc_unused = irq_desc + irq_unused;
+    unsigned int mask;
+    unsigned int port;
+    unsigned int irq_base;
+    unsigned int irq = 0;
+
+    for (port = 0; port < 6; port++) {
+        if (ISR(port) & IMR(port)) {
+            break;
+        }
+    }
+
+    mask = ISR(port);
+    irq_base = IRQ_GPIOA(0) + (port * 32);
+
+    desc = irq_desc + irq_base;
+    while (mask) {
+        if (mask & 1) {
+            DEBUG_IRQ("handling irq %d (port %d)\n", irq, port);
+	    __ipipe_handle_irq(irq + irq_base, regs);	    
+            ISR(port) = (1 << irq);
+        }
+        irq++;
+        desc++;
+        mask >>= 1;
+    }
+
+    desc_unused->chip->unmask(irq_unused);
+}
+#endif /* CONFIG_IPIPE */
+
 static struct irqchip imx21_gpio_chip = {
 	.ack = imx21_gpio_ack_irq,
 	.mask = imx21_gpio_mask_irq,
@@ -209,6 +249,16 @@ imx21_init_irq(void)
 	IMR(4) = 0;
 	IMR(5) = 0;
 
+	/* Define priorities for all interrupts lines */
+	AITC_NIPRIORITY7 = 0x00000000 ;
+	AITC_NIPRIORITY6 = 0x00000000 ;	
+	AITC_NIPRIORITY5 = 0x00000000 ;	
+	AITC_NIPRIORITY4 = 0x00000000 ;	
+	AITC_NIPRIORITY3 = 0x00000f00 ;
+	AITC_NIPRIORITY2 = 0x00000000 ;	
+	AITC_NIPRIORITY1 = 0x00000000 ;	
+	AITC_NIPRIORITY0 = 0x00000000 ;	
+
 	for (irq = 0; irq < IMX21_IRQS; irq++) {
 		set_irq_chip(irq, &imx21_internal_chip);
 		set_irq_handler(irq, do_level_IRQ);
diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp ipipe-2.6.14-arm-imx21/arch/arm/mach-imx21/time.c ipipe-2.6.14-imx21/arch/arm/mach-imx21/time.c
--- ipipe-2.6.14-arm-imx21/arch/arm/mach-imx21/time.c	2007-01-20 16:57:08.566283810 +0100
+++ ipipe-2.6.14-imx21/arch/arm/mach-imx21/time.c	2007-01-20 16:49:29.274424987 +0100
@@ -10,13 +10,23 @@
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
+ *
+ * April 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board with Xenomai by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
+ * * 24.04.06 : modification of value __ipipe_mach_ticks_per_jiff
+ *              the value dependent of timer clock frequency and HZ constant
  */
+
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/time.h>
+#include <linux/module.h>
 
 #include <asm/hardware.h>
 #include <asm/io.h>
@@ -24,56 +34,171 @@
 #include <asm/irq.h>
 #include <asm/mach/time.h>
 
+#include <asm/arch/csb535.h>
+
+static unsigned long timer_reload;
+static unsigned long timer_interval;
+static unsigned long timer_lxlost;
+static int tscok;
+
+#ifdef CONFIG_IPIPE
+int __ipipe_mach_timerint = INT_GPT1;
+static unsigned long long __ipipe_mach_tsc;
+static DEFINE_SPINLOCK(timer_lock);
+int __ipipe_mach_timerstolen = 0;
+EXPORT_SYMBOL(__ipipe_mach_timerstolen);
 /*
- * Returns number of us since last clock interrupt.  Note that interrupts
- * will have been disabled by do_gettimeoffset()
+ * timer_frequency = 17'616'076,8 Hz
+ * ticks/jiffy = timer_freq / Hz
  */
-static unsigned long imx21_gettimeoffset(void)
+unsigned int __ipipe_mach_ticks_per_jiffy = CLKPERCLK1 / HZ;
+EXPORT_SYMBOL(__ipipe_mach_ticks_per_jiffy);
+#endif /* CONFIG_IPIPE */
+
+/*
+ * Called with IRQ disabled from do_gettimeofday().
+ */
+static inline unsigned long imx_getticksoffset(void)
 {
-	unsigned long ticks;
 
+	if (!tscok)
+		return 0;
+	
+	//Return the value of Timer 1
+	return IMX21_TCN(GPT1);
+	
+}
+
+/*
+ * Reprogram the timer
+ */
+static inline void  set_dec(unsigned long reload)
+{
+
+	//Configure timer in a now state
+	IMX21_TCTL(GPT1) = 0 ;
+	//Load the compare value (next IRQ)
+	IMX21_TCMP(GPT1) = reload;
+	//Restart the timer (in free run mode (FRR))
+	IMX21_TCTL(GPT1) = TCTL_CLK_PCLK1 | TCTL_IRQ_COMP | TCTL_TEN | TCTL_FRR | TCTL_OM |TCTL_CC ;
+
+	timer_reload = reload;
+
+}
+
+#ifdef CONFIG_IPIPE
+void inline __ipipe_mach_acktimer(void)
+{
+	
 	/*
-	 * Get the current number of ticks.  Note that there is a race
-	 * condition between us reading the timer and checking for
-	 * an interrupt.  We get around this by ensuring that the
-	 * counter has not reloaded between our two reads.
-	 */
+	 * TODO : Could be optimize 
+	*/
+	if ( IMX21_TSTAT(GPT1) )
+	    IMX21_TSTAT(GPT1) = TSTAT_COMP;
+	
+}
+EXPORT_SYMBOL(__ipipe_mach_acktimer);
+
+unsigned long long __ipipe_mach_get_tsc(void)
+{
+	
+	unsigned long long result;
+	unsigned long flags;
+
+	spin_lock_irqsave_hw(&timer_lock, flags);
+	result = __ipipe_mach_tsc + imx_getticksoffset();
+	spin_unlock_irqrestore_hw(&timer_lock, flags);
+	return result;
+
+}
+EXPORT_SYMBOL(__ipipe_mach_get_tsc);
+
+void __ipipe_mach_set_dec(unsigned long reload)
+{
+	unsigned long ticks;
+	unsigned long flags;
+
+	spin_lock_irqsave_hw(&timer_lock, flags);
+	ticks = imx_getticksoffset();
+	__ipipe_mach_tsc += ticks;
+	set_dec(reload);
+	timer_lxlost += ticks;
+	spin_unlock_irqrestore_hw(&timer_lock, flags);
+
+}
+EXPORT_SYMBOL(__ipipe_mach_set_dec);
+
+void __ipipe_mach_release_timer(void)
+{
+       __ipipe_mach_set_dec(__ipipe_mach_ticks_per_jiffy);
+}
+EXPORT_SYMBOL(__ipipe_mach_release_timer);
+
+unsigned long __ipipe_mach_get_dec(void)
+{
+	unsigned ticks;
+	
 	ticks = IMX21_TCN(GPT1);
 
-	/*
-	 * Interrupt pending?  If so, we've reloaded once already.
-	 */
-	if (IMX21_TSTAT(GPT1) & TSTAT_COMP)
-		ticks += LATCH;
+	if (ticks < timer_reload) {
+		return timer_reload - ticks;
+	}
+	else {
+		return 0xffffffff + timer_reload - ticks;
+	}
+}
+EXPORT_SYMBOL(__ipipe_mach_get_dec);
+#endif /* CONFIG_IPIPE */
+
+unsigned long imx21_gettimeoffset(void)
+{
 
 	/*
-	 * Convert the ticks to usecs
+	 * Convert ticks to usecs
 	 */
-	return (1000000 / CLK32) * ticks;
+	return ((10000 * (timer_lxlost + imx_getticksoffset())) / __ipipe_mach_ticks_per_jiffy);
+		
 }
 
-/*
- * IRQ handler for the timer
- */
 static irqreturn_t
 imx21_timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	write_seqlock(&xtime_lock);
 
-	/* if any bits set, rupt has occurred, clear it by  writing a 1 */
-	if ( IMX21_TSTAT(GPT1) ) {
-	    IMX21_TSTAT(GPT1) = TSTAT_CAPT | TSTAT_COMP;
+	timer_lxlost = 0;
+
+#ifdef CONFIG_IPIPE
+	/*
+	 * If Linux is the only domain, ack the timer and reprogram it
+	 */
+	if (!__ipipe_mach_timerstolen) {
+		__ipipe_mach_tsc += imx_getticksoffset();
+#else
+		if (IMX21_TSTAT(GPT1) ) {
+	    		IMX21_TSTAT(GPT1) = TSTAT_COMP;
+		}
+#endif
+		/*
+		 * Reprogram timer with "__ipipe_mach_ticks_per_jiffy";
+		 */
+		IMX21_TCTL(GPT1) = 0 ;
+		IMX21_TCMP(GPT1) = __ipipe_mach_ticks_per_jiffy;
+		IMX21_TCTL(GPT1) = TCTL_CLK_PCLK1 | TCTL_IRQ_COMP | TCTL_TEN | TCTL_FRR | TCTL_OM | TCTL_CC ;
+		
+#ifdef CONFIG_IPIPE
 	}
-	
+#endif	
+
 	timer_tick(regs);
 	write_sequnlock(&xtime_lock);
 
 	return IRQ_HANDLED;
+
 }
 
 static struct irqaction imx21_timer_irq = {
-	.name		= "i.MX21 Timer Tick",
-	.flags		= SA_INTERRUPT,
+	.name		= "i.Mx21 Timer Tick",
+	.flags		= SA_INTERRUPT | SA_TIMER,
 	.handler	= imx21_timer_interrupt
 };
 
@@ -82,21 +207,35 @@ static struct irqaction imx21_timer_irq 
  */
 static void __init imx21_timer_init(void)
 {
+
 	/*
-	 * Initialise to a known state (all timers off, and timing reset)
+	 * Configure all timers in a now state
 	 */
 	IMX21_TCTL(GPT1) = 0;
+	IMX21_TCTL(GPT2) = 0;
+	IMX21_TCTL(GPT3) = 0;
+	/*
+	 * Configure the timer
+         */
 	IMX21_TPRER(GPT1) = 0;
-	IMX21_TCMP(GPT1) = LATCH - 1;
-	IMX21_TCTL(GPT1) = TCTL_CLK_32 | TCTL_IRQEN | TCTL_TEN;
 
 	/*
 	 * Make irqs happen for the system timer
 	 */
 	setup_irq(INT_GPT1, &imx21_timer_irq);
+
+	/*
+         * Reprogram the timer and start it !
+	 */
+	set_dec(__ipipe_mach_ticks_per_jiffy);
+
+	tscok = 1;
+
 }
 
 struct sys_timer imx21_timer = {
 	.init		= imx21_timer_init,
 	.offset		= imx21_gettimeoffset,
 };
+
+
diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp ipipe-2.6.14-arm-imx21/include/asm-arm/arch-imx/imx-regs.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx/imx-regs.h
--- ipipe-2.6.14-arm-imx21/include/asm-arm/arch-imx/imx-regs.h	2005-10-28 02:02:08.000000000 +0200
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx/imx-regs.h	2007-01-20 15:58:52.573225454 +0100
@@ -1,481 +1,618 @@
-#ifndef _IMX_REGS_H
-#define _IMX_REGS_H
+#ifndef _MX2ADS_REGS_H
+#define _MX2ADS_REGS_H
 /* ------------------------------------------------------------------------
- *  Motorola IMX system registers
+ *  Freescale i.iMX21 system registers
  * ------------------------------------------------------------------------
  *
+ * Modified By: Ron Melvin (ron.melvin@timesys.com)
+ * Copyright (C) 2005 TimeSys Corporation 
+ *
+ * Modified by: Stephen Donecker (sdonecker@sbcglobal.net)
+ *
+ * April 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board with Xenomai by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ * 
+*/
+
+/*
+ * Memory mapped I/O for the M9328MX21ADS    
+ *
+ * TODO: move these defines to an appropiate board specific file
  */
 
+#define MX2ADS_MMIO_PHYS	(0xCC800000)
+#define MX2ADS_MMIO_OFFSET	MX2ADS_MMIO_PHYS-IMX21_CS1_PHYS
+#define MMIO_REG		(*((volatile u16 *)(IMX21_CS1_VIRT+MX2ADS_MMIO_OFFSET)))
+
+#define MMIO_SD_WP		(1<<0)
+#define MMIO_SW_SEL		(1<<1)
+#define MMIO_RESET_E_UART	(1<<2)
+#define MMIO_RESET_BASE		(1<<3)
+#define MMIO_CSI_CTL2		(1<<4)
+#define MMIO_CSI_CTL1		(1<<5)
+#define MMIO_CSI_CTL0		(1<<6)
+#define MMIO_UART1_EN		(1<<7)
+#define MMIO_UART4_EN		(1<<8)
+#define	MMIO_LCDON		(1<<9)
+#define MMIO_IRDA_EN		(1<<10)
+#define MMIO_IRDA_FIR_SEL	(1<<11)
+#define MMIO_IRDA_MD0_B		(1<<12)
+#define MMIO_IRDA_MD1		(1<<13)
+#define MMIO_LED4_ON		(1<<14)
+#define MMIO_LED3_ON		(1<<15)
+
 /*
  *  Register BASEs, based on OFFSETs
  *
  */
-#define IMX_AIPI1_BASE             (0x00000 + IMX_IO_BASE)
-#define IMX_WDT_BASE               (0x01000 + IMX_IO_BASE)
-#define IMX_TIM1_BASE              (0x02000 + IMX_IO_BASE)
-#define IMX_TIM2_BASE              (0x03000 + IMX_IO_BASE)
-#define IMX_RTC_BASE               (0x04000 + IMX_IO_BASE)
-#define IMX_LCDC_BASE              (0x05000 + IMX_IO_BASE)
-#define IMX_UART1_BASE             (0x06000 + IMX_IO_BASE)
-#define IMX_UART2_BASE             (0x07000 + IMX_IO_BASE)
-#define IMX_PWM_BASE               (0x08000 + IMX_IO_BASE)
-#define IMX_DMAC_BASE              (0x09000 + IMX_IO_BASE)
-#define IMX_AIPI2_BASE             (0x10000 + IMX_IO_BASE)
-#define IMX_SIM_BASE               (0x11000 + IMX_IO_BASE)
-#define IMX_USBD_BASE              (0x12000 + IMX_IO_BASE)
-#define IMX_SPI1_BASE              (0x13000 + IMX_IO_BASE)
-#define IMX_MMC_BASE               (0x14000 + IMX_IO_BASE)
-#define IMX_ASP_BASE               (0x15000 + IMX_IO_BASE)
-#define IMX_BTA_BASE               (0x16000 + IMX_IO_BASE)
-#define IMX_I2C_BASE               (0x17000 + IMX_IO_BASE)
-#define IMX_SSI_BASE               (0x18000 + IMX_IO_BASE)
-#define IMX_SPI2_BASE              (0x19000 + IMX_IO_BASE)
-#define IMX_MSHC_BASE              (0x1A000 + IMX_IO_BASE)
-#define IMX_PLL_BASE               (0x1B000 + IMX_IO_BASE)
-#define IMX_GPIO_BASE              (0x1C000 + IMX_IO_BASE)
-#define IMX_EIM_BASE               (0x20000 + IMX_IO_BASE)
-#define IMX_SDRAMC_BASE            (0x21000 + IMX_IO_BASE)
-#define IMX_MMA_BASE               (0x22000 + IMX_IO_BASE)
-#define IMX_AITC_BASE              (0x23000 + IMX_IO_BASE)
-#define IMX_CSI_BASE               (0x24000 + IMX_IO_BASE)
 
-/* PLL registers */
-#define CSCR   __REG(IMX_PLL_BASE)        /* Clock Source Control Register */
-#define CSCR_SYSTEM_SEL (1<<16)
+/* TODO: Rename MX2ADS to processor specific name, not a board name */
 
-#define MPCTL0 __REG(IMX_PLL_BASE + 0x4)  /* MCU PLL Control Register 0 */
-#define MPCTL1 __REG(IMX_PLL_BASE + 0x8)  /* MCU PLL and System Clock Register 1 */
-#define SPCTL0 __REG(IMX_PLL_BASE + 0xc)  /* System PLL Control Register 0 */
-#define SPCTL1 __REG(IMX_PLL_BASE + 0x10) /* System PLL Control Register 1 */
-#define PCDR   __REG(IMX_PLL_BASE + 0x20) /* Peripheral Clock Divider Register */
+#define MX2ADS_AIPI1_BASE             (0x00000 + IMX21_IO_BASE)
+#define MX2ADS_AIPI2_BASE             (0x20000 + IMX21_IO_BASE)
 
-#define CSCR_MPLL_RESTART (1<<21)
+#define MX2ADS_DMA_BASE               (0x01000 + IMX21_IO_BASE)
+#define MX2ADS_WDT_BASE               (0x02000 + IMX21_IO_BASE)
+#define MX2ADS_GPT1_BASE              (0x03000 + IMX21_IO_BASE)
+#define MX2ADS_GPT2_BASE              (0x04000 + IMX21_IO_BASE)
+#define MX2ADS_GPT3_BASE              (0x05000 + IMX21_IO_BASE)
+#define MX2ADS_PWM_BASE               (0x06000 + IMX21_IO_BASE)
+#define MX2ADS_RTC_BASE               (0x07000 + IMX21_IO_BASE)
+#define MX2ADS_KPP_BASE               (0x08000 + IMX21_IO_BASE)
+#define MX2ADS_OWIRE_BASE             (0x09000 + IMX21_IO_BASE)
+#define MX2ADS_UART1_BASE             (0x0A000 + IMX21_IO_BASE)
+#define MX2ADS_UART2_BASE             (0x0B000 + IMX21_IO_BASE)
+#define MX2ADS_UART3_BASE             (0x0C000 + IMX21_IO_BASE)
+#define MX2ADS_UART4_BASE             (0x0D000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI1_BASE             (0x0E000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI2_BASE             (0x0F000 + IMX21_IO_BASE)
+#define MX2ADS_SSI1_BASE              (0x10000 + IMX21_IO_BASE)
+#define MX2ADS_SSI2_BASE              (0x11000 + IMX21_IO_BASE)
+#define MX2ADS_I2C_BASE               (0x12000 + IMX21_IO_BASE)
+#define MX2ADS_SDHC1_BASE             (0x13000 + IMX21_IO_BASE)
+#define MX2ADS_SDHC2_BASE             (0x14000 + IMX21_IO_BASE)
+#define MX2ADS_GPIO_BASE              (0x15000 + IMX21_IO_BASE)
+#define MX2ADS_AUDMUX_BASE            (0x16000 + IMX21_IO_BASE)
+#define MX2ADS_CSPI3_BASE	      (IMX21_IO_BASE + 0x17000)
+#define MX2ADS_LCDC_BASE              (0x21000 + IMX21_IO_BASE)
+#define MX2ADS_SLCDC_BASE             (0x22000 + IMX21_IO_BASE)
+#define MX2ADS_SAHARA_BASE            (0x23000 + IMX21_IO_BASE)
+#define MX2ADS_USBOTG_BASE            (0x24000 + IMX21_IO_BASE)
+#define MX2ADS_EMMA_BASE              (0x26000 + IMX21_IO_BASE)
+#define MX2ADS_CRM_BASE               (0x27000 + IMX21_IO_BASE)
+#define MX2ADS_FIRI_BASE              (0x28000 + IMX21_IO_BASE)
+#define MX2ADS_RNGA_BASE	      (IMX21_IO_BASE + 0x29000)
+#define MX2ADS_RTIC_BASE	      (IMX21_IO_BASE + 0x2A000)
+#define MX2ADS_JAM_BASE               (0x3E000 + IMX21_IO_BASE)
+#define MX2ADS_MAX_BASE               (0x3F000 + IMX21_IO_BASE)
+#define MX2ADS_AITC_BASE              (0x40000 + IMX21_IO_BASE)
+
+/*
+ * Interrupt controller
+ */
+#define AITC_NIVECSR		__REG(MX2ADS_AITC_BASE + 0x40)
+#define AITC_NIPRIORITY7	__REG(MX2ADS_AITC_BASE + 0x20)
+#define AITC_NIPRIORITY6	__REG(MX2ADS_AITC_BASE + 0x24)
+#define AITC_NIPRIORITY5	__REG(MX2ADS_AITC_BASE + 0x28)
+#define AITC_NIPRIORITY4	__REG(MX2ADS_AITC_BASE + 0x2C)
+#define AITC_NIPRIORITY3	__REG(MX2ADS_AITC_BASE + 0x30)
+#define AITC_NIPRIORITY2	__REG(MX2ADS_AITC_BASE + 0x34)
+#define AITC_NIPRIORITY1	__REG(MX2ADS_AITC_BASE + 0x38)
+#define AITC_NIPRIORITY0	__REG(MX2ADS_AITC_BASE + 0x3C)
+
+/*
+ * GPIOs
+ */
+#define GPIO_A	0
+#define GPIO_B	1
+#define GPIO_C	2
+#define GPIO_D	3
+#define GPIO_E	4
+#define GPIO_F	5
 
 /*
  *  GPIO Module and I/O Multiplexer
- *  x = 0..3 for reg_A, reg_B, reg_C, reg_D
+ *  x = 0..5 for reg_A, reg_B, reg_C, reg_D, reg_E, reg_F
  */
-#define DDIR(x)    __REG2(IMX_GPIO_BASE + 0x00, ((x) & 3) << 8)
-#define OCR1(x)    __REG2(IMX_GPIO_BASE + 0x04, ((x) & 3) << 8)
-#define OCR2(x)    __REG2(IMX_GPIO_BASE + 0x08, ((x) & 3) << 8)
-#define ICONFA1(x) __REG2(IMX_GPIO_BASE + 0x0c, ((x) & 3) << 8)
-#define ICONFA2(x) __REG2(IMX_GPIO_BASE + 0x10, ((x) & 3) << 8)
-#define ICONFB1(x) __REG2(IMX_GPIO_BASE + 0x14, ((x) & 3) << 8)
-#define ICONFB2(x) __REG2(IMX_GPIO_BASE + 0x18, ((x) & 3) << 8)
-#define DR(x)      __REG2(IMX_GPIO_BASE + 0x1c, ((x) & 3) << 8)
-#define GIUS(x)    __REG2(IMX_GPIO_BASE + 0x20, ((x) & 3) << 8)
-#define SSR(x)     __REG2(IMX_GPIO_BASE + 0x24, ((x) & 3) << 8)
-#define ICR1(x)    __REG2(IMX_GPIO_BASE + 0x28, ((x) & 3) << 8)
-#define ICR2(x)    __REG2(IMX_GPIO_BASE + 0x2c, ((x) & 3) << 8)
-#define IMR(x)     __REG2(IMX_GPIO_BASE + 0x30, ((x) & 3) << 8)
-#define ISR(x)     __REG2(IMX_GPIO_BASE + 0x34, ((x) & 3) << 8)
-#define GPR(x)     __REG2(IMX_GPIO_BASE + 0x38, ((x) & 3) << 8)
-#define SWR(x)     __REG2(IMX_GPIO_BASE + 0x3c, ((x) & 3) << 8)
-#define PUEN(x)    __REG2(IMX_GPIO_BASE + 0x40, ((x) & 3) << 8)
+#define DDIR(x)    __REG2(MX2ADS_GPIO_BASE + 0x00, ((x) & 7) << 8)
+#define OCR1(x)    __REG2(MX2ADS_GPIO_BASE + 0x04, ((x) & 7) << 8)
+#define OCR2(x)    __REG2(MX2ADS_GPIO_BASE + 0x08, ((x) & 7) << 8)
+#define ICONFA1(x) __REG2(MX2ADS_GPIO_BASE + 0x0c, ((x) & 7) << 8)
+#define ICONFA2(x) __REG2(MX2ADS_GPIO_BASE + 0x10, ((x) & 7) << 8)
+#define ICONFB1(x) __REG2(MX2ADS_GPIO_BASE + 0x14, ((x) & 7) << 8)
+#define ICONFB2(x) __REG2(MX2ADS_GPIO_BASE + 0x18, ((x) & 7) << 8)
+#define DR(x)      __REG2(MX2ADS_GPIO_BASE + 0x1c, ((x) & 7) << 8)
+#define GIUS(x)    __REG2(MX2ADS_GPIO_BASE + 0x20, ((x) & 7) << 8)
+#define SSR(x)     __REG2(MX2ADS_GPIO_BASE + 0x24, ((x) & 7) << 8)
+#define ICR1(x)    __REG2(MX2ADS_GPIO_BASE + 0x28, ((x) & 7) << 8)
+#define ICR2(x)    __REG2(MX2ADS_GPIO_BASE + 0x2c, ((x) & 7) << 8)
+#define IMR(x)     __REG2(MX2ADS_GPIO_BASE + 0x30, ((x) & 7) << 8)
+#define ISR(x)     __REG2(MX2ADS_GPIO_BASE + 0x34, ((x) & 7) << 8)
+#define GPR(x)     __REG2(MX2ADS_GPIO_BASE + 0x38, ((x) & 7) << 8)
+#define SWR(x)     __REG2(MX2ADS_GPIO_BASE + 0x3c, ((x) & 7) << 8)
+#define PUEN(x)    __REG2(MX2ADS_GPIO_BASE + 0x40, ((x) & 7) << 8)
+#define PMASK      __REG(MX2ADS_GPIO_BASE + 0x600)
 
-#define GPIO_PIN_MASK 0x1f
-#define GPIO_PORT_MASK (0x3 << 5)
+/*  ethernet controller IRQ is tied to UART3_RTS */ 
+#define NET_IRQ_BIT		(1 << 11)
 
-#define GPIO_PORT_SHIFT 5
-#define GPIO_PORTA (0<<5)
-#define GPIO_PORTB (1<<5)
-#define GPIO_PORTC (2<<5)
-#define GPIO_PORTD (3<<5)
+/*
+ *  GPIO Mode
+ *
+ *  The pin, port, data direction, pull-up enable, primary/alternate
+ *  function, output configuration, and input configuration are encoded in a 
+ *  single word as follows.
+ *
+ *  4:0 Pin (31-0)
+ *  7:5 Port (F-A)
+ *  8 Direction
+ *  9 PUEN
+ *  10:11 Primary Function,Alternate Function,GPIO
+ *  13:12 OCR
+ *  15:14 ICONF
+ * 
+ *  [ 15 14 | 13 12 | 11 10 | 9  |  8  | 7 6 5 | 4 3 2 1 0 ]
+ *  [ ICONF |  OCR  | P/A/G | PU | Dir | Port  |    Pin    ]
+ */
 
-#define GPIO_OUT   (1<<7)
-#define GPIO_IN    (0<<7)
-#define GPIO_PUEN  (1<<8)
+#define GPIO_PIN_MASK		(0x1f<<0)
 
-#define GPIO_PF    (0<<9)
-#define GPIO_AF    (1<<9)
+#define GPIO_PORT_POS		5
+#define GPIO_PORT_MASK		(0x3 << GPIO_PORT_POS)
+#define GPIO_PORTA 		(0 << GPIO_PORT_POS)
+#define GPIO_PORTB		(1 << GPIO_PORT_POS)
+#define GPIO_PORTC		(2 << GPIO_PORT_POS)
+#define GPIO_PORTD		(3 << GPIO_PORT_POS)
+#define GPIO_PORTE		(4 << GPIO_PORT_POS)
+#define GPIO_PORTF		(5 << GPIO_PORT_POS)
 
-#define GPIO_OCR_SHIFT 10
-#define GPIO_OCR_MASK (3<<10)
-#define GPIO_AIN   (0<<10)
-#define GPIO_BIN   (1<<10)
-#define GPIO_CIN   (2<<10)
-#define GPIO_DR    (3<<10)
+#define GPIO_DIR_MASK		(1<<8)
+#define GPIO_IN			(0<<8)
+#define GPIO_OUT		(1<<8)
 
-#define GPIO_AOUT_SHIFT 12
-#define GPIO_AOUT_MASK (3<<12)
-#define GPIO_AOUT     (0<<12)
-#define GPIO_AOUT_ISR (1<<12)
-#define GPIO_AOUT_0   (2<<12)
-#define GPIO_AOUT_1   (3<<12)
+#define GPIO_PU_MASK		(1<<9)
+#define GPIO_PUDIS		(0<<9)
+#define GPIO_PUEN		(1<<9)
 
-#define GPIO_BOUT_SHIFT 14
-#define GPIO_BOUT_MASK (3<<14)
-#define GPIO_BOUT      (0<<14)
-#define GPIO_BOUT_ISR  (1<<14)
-#define GPIO_BOUT_0    (2<<14)
-#define GPIO_BOUT_1    (3<<14)
+#define GPIO_FUNC_MASK		(0x3<<10)
+#define GPIO_PF			(0<<10)
+#define GPIO_AF			(1<<10)
+#define GPIO_GP			(2<<10)
 
-#define GPIO_GIUS      (1<<16)
+#define GPIO_OCR_POS		12
+#define GPIO_OCR_MASK		(0x3 << GPIO_OCR_POS)
+#define GPIO_AIN		(0 << GPIO_OCR_POS)
+#define GPIO_BIN		(1 << GPIO_OCR_POS)
+#define GPIO_CIN		(2 << GPIO_OCR_POS)
+#define GPIO_DR			(3 << GPIO_OCR_POS)
 
-/* assignements for GPIO alternate/primary functions */
+#define GPIO_ICONF_MASK		(0x3<<14)
+#define GPIO_AOUT		(1<<14)
+#define GPIO_BOUT		(2<<14)
 
-/* FIXME: This list is not completed. The correct directions are
- * missing on some (many) pins
+/*
+ *  Freescale i.MX21 GPIO signal multiplexing mode defines
  */
-#define PA0_AIN_SPI2_CLK     ( GPIO_GIUS | GPIO_PORTA | GPIO_OUT | 0 )
-#define PA0_AF_ETMTRACESYNC  ( GPIO_PORTA | GPIO_AF | 0 )
-#define PA1_AOUT_SPI2_RXD    ( GPIO_GIUS | GPIO_PORTA | GPIO_IN | 1 )
-#define PA1_PF_TIN           ( GPIO_PORTA | GPIO_PF | 1 )
-#define PA2_PF_PWM0          ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 2 )
-#define PA3_PF_CSI_MCLK      ( GPIO_PORTA | GPIO_PF | 3 )
-#define PA4_PF_CSI_D0        ( GPIO_PORTA | GPIO_PF | 4 )
-#define PA5_PF_CSI_D1        ( GPIO_PORTA | GPIO_PF | 5 )
-#define PA6_PF_CSI_D2        ( GPIO_PORTA | GPIO_PF | 6 )
-#define PA7_PF_CSI_D3        ( GPIO_PORTA | GPIO_PF | 7 )
-#define PA8_PF_CSI_D4        ( GPIO_PORTA | GPIO_PF | 8 )
-#define PA9_PF_CSI_D5        ( GPIO_PORTA | GPIO_PF | 9 )
-#define PA10_PF_CSI_D6       ( GPIO_PORTA | GPIO_PF | 10 )
-#define PA11_PF_CSI_D7       ( GPIO_PORTA | GPIO_PF | 11 )
-#define PA12_PF_CSI_VSYNC    ( GPIO_PORTA | GPIO_PF | 12 )
-#define PA13_PF_CSI_HSYNC    ( GPIO_PORTA | GPIO_PF | 13 )
-#define PA14_PF_CSI_PIXCLK   ( GPIO_PORTA | GPIO_PF | 14 )
-#define PA15_PF_I2C_SDA      ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 15 )
-#define PA16_PF_I2C_SCL      ( GPIO_PORTA | GPIO_OUT | GPIO_PF | 16 )
-#define PA17_AF_ETMTRACEPKT4 ( GPIO_PORTA | GPIO_AF | 17 )
-#define PA17_AIN_SPI2_SS     ( GPIO_GIUS | GPIO_PORTA | GPIO_OUT | 17 )
-#define PA18_AF_ETMTRACEPKT5 ( GPIO_PORTA | GPIO_AF | 18 )
-#define PA19_AF_ETMTRACEPKT6 ( GPIO_PORTA | GPIO_AF | 19 )
-#define PA20_AF_ETMTRACEPKT7 ( GPIO_PORTA | GPIO_AF | 20 )
-#define PA21_PF_A0           ( GPIO_PORTA | GPIO_PF | 21 )
-#define PA22_PF_CS4          ( GPIO_PORTA | GPIO_PF | 22 )
-#define PA23_PF_CS5          ( GPIO_PORTA | GPIO_PF | 23 )
-#define PA24_PF_A16          ( GPIO_PORTA | GPIO_PF | 24 )
-#define PA24_AF_ETMTRACEPKT0 ( GPIO_PORTA | GPIO_AF | 24 )
-#define PA25_PF_A17          ( GPIO_PORTA | GPIO_PF | 25 )
-#define PA25_AF_ETMTRACEPKT1 ( GPIO_PORTA | GPIO_AF | 25 )
-#define PA26_PF_A18          ( GPIO_PORTA | GPIO_PF | 26 )
-#define PA26_AF_ETMTRACEPKT2 ( GPIO_PORTA | GPIO_AF | 26 )
-#define PA27_PF_A19          ( GPIO_PORTA | GPIO_PF | 27 )
-#define PA27_AF_ETMTRACEPKT3 ( GPIO_PORTA | GPIO_AF | 27 )
-#define PA28_PF_A20          ( GPIO_PORTA | GPIO_PF | 28 )
-#define PA28_AF_ETMPIPESTAT0 ( GPIO_PORTA | GPIO_AF | 28 )
-#define PA29_PF_A21          ( GPIO_PORTA | GPIO_PF | 29 )
-#define PA29_AF_ETMPIPESTAT1 ( GPIO_PORTA | GPIO_AF | 29 )
-#define PA30_PF_A22          ( GPIO_PORTA | GPIO_PF | 30 )
-#define PA30_AF_ETMPIPESTAT2 ( GPIO_PORTA | GPIO_AF | 30 )
-#define PA31_PF_A23          ( GPIO_PORTA | GPIO_PF | 31 )
-#define PA31_AF_ETMTRACECLK  ( GPIO_PORTA | GPIO_AF | 31 )
-#define PB8_PF_SD_DAT0       ( GPIO_PORTB | GPIO_PF | GPIO_PUEN | 8 )
-#define PB8_AF_MS_PIO        ( GPIO_PORTB | GPIO_AF | 8 )
-#define PB9_PF_SD_DAT1       ( GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 9 )
-#define PB9_AF_MS_PI1        ( GPIO_PORTB | GPIO_AF | 9 )
-#define PB10_PF_SD_DAT2      ( GPIO_PORTB | GPIO_PF | GPIO_PUEN  | 10 )
-#define PB10_AF_MS_SCLKI     ( GPIO_PORTB | GPIO_AF | 10 )
-#define PB11_PF_SD_DAT3      ( GPIO_PORTB | GPIO_PF | 11 )
-#define PB11_AF_MS_SDIO      ( GPIO_PORTB | GPIO_AF | 11 )
-#define PB12_PF_SD_CLK       ( GPIO_PORTB | GPIO_PF | 12 )
-#define PB12_AF_MS_SCLK0     ( GPIO_PORTB | GPIO_AF | 12 )
-#define PB13_PF_SD_CMD       ( GPIO_PORTB | GPIO_PF | GPIO_PUEN | 13 )
-#define PB13_AF_MS_BS        ( GPIO_PORTB | GPIO_AF | 13 )
-#define PB14_AF_SSI_RXFS     ( GPIO_PORTB | GPIO_AF | 14 )
-#define PB15_AF_SSI_RXCLK    ( GPIO_PORTB | GPIO_AF | 15 )
-#define PB16_AF_SSI_RXDAT    ( GPIO_PORTB | GPIO_IN | GPIO_AF | 16 )
-#define PB17_AF_SSI_TXDAT    ( GPIO_PORTB | GPIO_OUT | GPIO_AF | 17 )
-#define PB18_AF_SSI_TXFS     ( GPIO_PORTB | GPIO_AF | 18 )
-#define PB19_AF_SSI_TXCLK    ( GPIO_PORTB | GPIO_AF | 19 )
-#define PB20_PF_USBD_AFE     ( GPIO_PORTB | GPIO_PF | 20 )
-#define PB21_PF_USBD_OE      ( GPIO_PORTB | GPIO_PF | 21 )
-#define PB22_PFUSBD_RCV      ( GPIO_PORTB | GPIO_PF | 22 )
-#define PB23_PF_USBD_SUSPND  ( GPIO_PORTB | GPIO_PF | 23 )
-#define PB24_PF_USBD_VP      ( GPIO_PORTB | GPIO_PF | 24 )
-#define PB25_PF_USBD_VM      ( GPIO_PORTB | GPIO_PF | 25 )
-#define PB26_PF_USBD_VPO     ( GPIO_PORTB | GPIO_PF | 26 )
-#define PB27_PF_USBD_VMO     ( GPIO_PORTB | GPIO_PF | 27 )
-#define PB28_PF_UART2_CTS    ( GPIO_PORTB | GPIO_OUT | GPIO_PF | 28 )
-#define PB29_PF_UART2_RTS    ( GPIO_PORTB | GPIO_IN | GPIO_PF | 29 )
-#define PB30_PF_UART2_TXD    ( GPIO_PORTB | GPIO_OUT | GPIO_PF | 30 )
-#define PB31_PF_UART2_RXD    ( GPIO_PORTB | GPIO_IN | GPIO_PF | 31 )
-#define PC3_PF_SSI_RXFS      ( GPIO_PORTC | GPIO_PF | 3 )
-#define PC4_PF_SSI_RXCLK     ( GPIO_PORTC | GPIO_PF | 4 )
-#define PC5_PF_SSI_RXDAT     ( GPIO_PORTC | GPIO_IN | GPIO_PF | 5 )
-#define PC6_PF_SSI_TXDAT     ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 6 )
-#define PC7_PF_SSI_TXFS      ( GPIO_PORTC | GPIO_PF | 7 )
-#define PC8_PF_SSI_TXCLK     ( GPIO_PORTC | GPIO_PF | 8 )
-#define PC9_PF_UART1_CTS     ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 9 )
-#define PC10_PF_UART1_RTS    ( GPIO_PORTC | GPIO_IN | GPIO_PF | 10 )
-#define PC11_PF_UART1_TXD    ( GPIO_PORTC | GPIO_OUT | GPIO_PF | 11 )
-#define PC12_PF_UART1_RXD    ( GPIO_PORTC | GPIO_IN | GPIO_PF | 12 )
-#define PC13_PF_SPI1_SPI_RDY ( GPIO_PORTC | GPIO_PF | 13 )
-#define PC14_PF_SPI1_SCLK    ( GPIO_PORTC | GPIO_PF | 14 )
-#define PC15_PF_SPI1_SS      ( GPIO_PORTC | GPIO_PF | 15 )
-#define PC16_PF_SPI1_MISO    ( GPIO_PORTC | GPIO_PF | 16 )
-#define PC17_PF_SPI1_MOSI    ( GPIO_PORTC | GPIO_PF | 17 )
-#define PC24_BIN_UART3_RI    ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 24 )
-#define PC25_BIN_UART3_DSR   ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 25 )
-#define PC26_AOUT_UART3_DTR  ( GPIO_GIUS | GPIO_PORTC | GPIO_IN | 26 )
-#define PC27_BIN_UART3_DCD   ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 27 )
-#define PC28_BIN_UART3_CTS   ( GPIO_GIUS | GPIO_PORTC | GPIO_OUT | GPIO_BIN | 28 )
-#define PC29_AOUT_UART3_RTS  ( GPIO_GIUS | GPIO_PORTC | GPIO_IN | 29 )
-#define PC30_BIN_UART3_TX    ( GPIO_GIUS | GPIO_PORTC | GPIO_BIN | 30 )
-#define PC31_AOUT_UART3_RX   ( GPIO_GIUS | GPIO_PORTC | GPIO_IN | 31)
-#define PD6_PF_LSCLK         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 6 )
-#define PD7_PF_REV           ( GPIO_PORTD | GPIO_PF | 7 )
-#define PD7_AF_UART2_DTR     ( GPIO_GIUS | GPIO_PORTD | GPIO_IN | GPIO_AF | 7 )
-#define PD7_AIN_SPI2_SCLK    ( GPIO_GIUS | GPIO_PORTD | GPIO_AIN | 7 )
-#define PD8_PF_CLS           ( GPIO_PORTD | GPIO_PF | 8 )
-#define PD8_AF_UART2_DCD     ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 8 )
-#define PD8_AIN_SPI2_SS      ( GPIO_GIUS | GPIO_PORTD | GPIO_AIN | 8 )
-#define PD9_PF_PS            ( GPIO_PORTD | GPIO_PF | 9 )
-#define PD9_AF_UART2_RI      ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 9 )
-#define PD9_AOUT_SPI2_RXD    ( GPIO_GIUS | GPIO_PORTD | GPIO_IN | 9 )
-#define PD10_PF_SPL_SPR      ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 10 )
-#define PD10_AF_UART2_DSR    ( GPIO_PORTD | GPIO_OUT | GPIO_AF | 10 )
-#define PD10_AIN_SPI2_TXD    ( GPIO_GIUS | GPIO_PORTD | GPIO_OUT | 10 )
-#define PD11_PF_CONTRAST     ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 11 )
-#define PD12_PF_ACD_OE       ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 12 )
-#define PD13_PF_LP_HSYNC     ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 13 )
-#define PD14_PF_FLM_VSYNC    ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 14 )
-#define PD15_PF_LD0          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 15 )
-#define PD16_PF_LD1          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 16 )
-#define PD17_PF_LD2          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 17 )
-#define PD18_PF_LD3          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 18 )
-#define PD19_PF_LD4          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 19 )
-#define PD20_PF_LD5          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 20 )
-#define PD21_PF_LD6          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 21 )
-#define PD22_PF_LD7          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 22 )
-#define PD23_PF_LD8          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 23 )
-#define PD24_PF_LD9          ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 24 )
-#define PD25_PF_LD10         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 25 )
-#define PD26_PF_LD11         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 26 )
-#define PD27_PF_LD12         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 27 )
-#define PD28_PF_LD13         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 28 )
-#define PD29_PF_LD14         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 29 )
-#define PD30_PF_LD15         ( GPIO_PORTD | GPIO_OUT | GPIO_PF | 30 )
-#define PD31_PF_TMR2OUT      ( GPIO_PORTD | GPIO_PF | 31 )
-#define PD31_BIN_SPI2_TXD    ( GPIO_GIUS | GPIO_PORTD | GPIO_BIN | 31 )
 
 /*
- * PWM controller
+ *  The GPIO pin naming convention was developed by the original unknown author. 
+ *  Although using defines for variables is always a good idea for portability, 
+ *  in this case the names are as specific as the values, and thus loose their 
+ *  portability. Ultimately the pin names should be changed to reflect the signal
+ *  name only.  
+ *
+ *  The current naming convention is as follows.
+ *
+ *  P(port)(pin)_(function)_(signal)
+ *
+ *  port = (A-F)
+ *  pin = (0-31)
+ *  function = (PF|AF|AIN|BIN|CIN|DR|AOUT|BOUT)
+ *  signal = signal name from datasheet
+ *
+ *  Remember that when in GPIO mode, AIN, BIN, CIN, and DR are inputs to the GPIO
+ *  peripheral module and represent outputs to the pin. Similarly AOUT, and BOUT
+ *  are outputs from the GPIO peripheral module and represent inputs to the physical 
+ *  pin in question. Refer to the multiplexing table in the section titled "Signal 
+ *  Descriptions and Pin Assignments" in the reference manual.
  */
-#define PWMC	__REG(IMX_PWM_BASE + 0x00)	/* PWM Control Register		*/
-#define PWMS	__REG(IMX_PWM_BASE + 0x04)	/* PWM Sample Register		*/
-#define PWMP	__REG(IMX_PWM_BASE + 0x08)	/* PWM Period Register		*/
-#define PWMCNT	__REG(IMX_PWM_BASE + 0x0C)	/* PWM Counter Register		*/
+   
+#define PE14_PF_UART1_CTS	( GPIO_PORTE | 14 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PE15_PF_UART1_RTS	( GPIO_PORTE | 15 | GPIO_PF | GPIO_IN | GPIO_PUDIS )
+#define PE12_PF_UART1_TXD	( GPIO_PORTE | 12 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PE13_PF_UART1_RXD	( GPIO_PORTE | 13 | GPIO_PF | GPIO_IN | GPIO_PUDIS )
 
-#define PWMC_HCTR		(0x01<<18)		/* Halfword FIFO Data Swapping	*/
-#define PWMC_BCTR		(0x01<<17)		/* Byte FIFO Data Swapping	*/
-#define PWMC_SWR		(0x01<<16)		/* Software Reset		*/
-#define PWMC_CLKSRC		(0x01<<15)		/* Clock Source			*/
-#define PWMC_PRESCALER(x)	(((x-1) & 0x7F) << 8)	/* PRESCALER			*/
-#define PWMC_IRQ		(0x01<< 7)		/* Interrupt Request		*/
-#define PWMC_IRQEN		(0x01<< 6)		/* Interrupt Request Enable	*/
-#define PWMC_FIFOAV		(0x01<< 5)		/* FIFO Available		*/
-#define PWMC_EN			(0x01<< 4)		/* Enables/Disables the PWM	*/
-#define PWMC_REPEAT(x)		(((x) & 0x03) << 2)	/* Sample Repeats		*/
-#define PWMC_CLKSEL(x)		(((x) & 0x03) << 0)	/* Clock Selection		*/
+#define PA5_PF_LSCLK		( GPIO_PORTA | 5 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA6_PF_LD0		( GPIO_PORTA | 6 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA7_PF_LD1		( GPIO_PORTA | 7 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA8_PF_LD2		( GPIO_PORTA | 8 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA9_PF_LD3		( GPIO_PORTA | 9 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA10_PF_LD4		( GPIO_PORTA | 10 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA11_PF_LD5		( GPIO_PORTA | 11 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA12_PF_LD6		( GPIO_PORTA | 12 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA13_PF_LD7		( GPIO_PORTA | 13 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA14_PF_LD8		( GPIO_PORTA | 14 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA15_PF_LD9		( GPIO_PORTA | 15 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA16_PF_LD10		( GPIO_PORTA | 16 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA17_PF_LD11		( GPIO_PORTA | 17 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA18_PF_LD12		( GPIO_PORTA | 18 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA19_PF_LD13		( GPIO_PORTA | 19 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA20_PF_LD14		( GPIO_PORTA | 20 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA21_PF_LD15		( GPIO_PORTA | 21 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA22_PF_LD16		( GPIO_PORTA | 22 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA23_PF_LD17		( GPIO_PORTA | 23 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA24_PF_REV		( GPIO_PORTA | 24 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA25_PF_CLS		( GPIO_PORTA | 25 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA26_PF_PS		( GPIO_PORTA | 26 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA27_PF_SPL_SPR		( GPIO_PORTA | 27 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA28_PF_HSYNC		( GPIO_PORTA | 28 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA29_PF_VSYNC		( GPIO_PORTA | 29 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA30_PF_CONTRAST	( GPIO_PORTA | 30 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
+#define PA31_PF_OE_ACD		( GPIO_PORTA | 31 | GPIO_PF | GPIO_OUT | GPIO_PUDIS )
 
-#define PWMS_SAMPLE(x)		((x) & 0xFFFF)		/* Contains a two-sample word	*/
-#define PWMP_PERIOD(x)		((x) & 0xFFFF)		/* Represents the PWM's period	*/
-#define PWMC_COUNTER(x)		((x) & 0xFFFF)		/* Represents the current count value	*/
+/*
+ *  Freescale i.MX21 register defines
+ *
+ *  All register and field defines should conform to the following naming
+ *  convention, and preferably use the exact names from the corresponding
+ *  datasheets. 
+ *
+ *  #define <module>_<register>		<value>
+ *  #define <register>_<field><type>	<value>
+ *
+ *  Where <type> can be one of the following.
+ *
+ *  _POS = defines the field LSB bit position	
+ *  _MASK = defines the field mask
+ *  (x) = writes x to the field location
+ *
+ *  The POS and MASK entries will be defined on an as needed basis. 
+ */
 
 /*
- *  DMA Controller
+ *  Freescale i.MX21 clock controller registers
  */
-#define DCR     __REG(IMX_DMAC_BASE +0x00)	/* DMA Control Register */
-#define DISR    __REG(IMX_DMAC_BASE +0x04)	/* DMA Interrupt status Register */
-#define DIMR    __REG(IMX_DMAC_BASE +0x08)	/* DMA Interrupt mask Register */
-#define DBTOSR  __REG(IMX_DMAC_BASE +0x0c)	/* DMA Burst timeout status Register */
-#define DRTOSR  __REG(IMX_DMAC_BASE +0x10)	/* DMA Request timeout Register */
-#define DSESR   __REG(IMX_DMAC_BASE +0x14)	/* DMA Transfer Error Status Register */
-#define DBOSR   __REG(IMX_DMAC_BASE +0x18)	/* DMA Buffer overflow status Register */
-#define DBTOCR  __REG(IMX_DMAC_BASE +0x1c)	/* DMA Burst timeout control Register */
-#define WSRA    __REG(IMX_DMAC_BASE +0x40)	/* W-Size Register A */
-#define XSRA    __REG(IMX_DMAC_BASE +0x44)	/* X-Size Register A */
-#define YSRA    __REG(IMX_DMAC_BASE +0x48)	/* Y-Size Register A */
-#define WSRB    __REG(IMX_DMAC_BASE +0x4c)	/* W-Size Register B */
-#define XSRB    __REG(IMX_DMAC_BASE +0x50)	/* X-Size Register B */
-#define YSRB    __REG(IMX_DMAC_BASE +0x54)	/* Y-Size Register B */
-#define SAR(x)  __REG2( IMX_DMAC_BASE + 0x80, (x) << 6)	/* Source Address Registers */
-#define DAR(x)  __REG2( IMX_DMAC_BASE + 0x84, (x) << 6)	/* Destination Address Registers */
-#define CNTR(x) __REG2( IMX_DMAC_BASE + 0x88, (x) << 6)	/* Count Registers */
-#define CCR(x)  __REG2( IMX_DMAC_BASE + 0x8c, (x) << 6)	/* Control Registers */
-#define RSSR(x) __REG2( IMX_DMAC_BASE + 0x90, (x) << 6)	/* Request source select Registers */
-#define BLR(x)  __REG2( IMX_DMAC_BASE + 0x94, (x) << 6)	/* Burst length Registers */
-#define RTOR(x) __REG2( IMX_DMAC_BASE + 0x98, (x) << 6)	/* Request timeout Registers */
-#define BUCR(x) __REG2( IMX_DMAC_BASE + 0x98, (x) << 6)	/* Bus Utilization Registers */
 
-#define DCR_DRST           (1<<1)
-#define DCR_DEN            (1<<0)
-#define DBTOCR_EN          (1<<15)
-#define DBTOCR_CNT(x)      ((x) & 0x7fff )
-#define CNTR_CNT(x)        ((x) & 0xffffff )
-#define CCR_DMOD_LINEAR    ( 0x0 << 12 )
-#define CCR_DMOD_2D        ( 0x1 << 12 )
-#define CCR_DMOD_FIFO      ( 0x2 << 12 )
-#define CCR_DMOD_EOBFIFO   ( 0x3 << 12 )
-#define CCR_SMOD_LINEAR    ( 0x0 << 10 )
-#define CCR_SMOD_2D        ( 0x1 << 10 )
-#define CCR_SMOD_FIFO      ( 0x2 << 10 )
-#define CCR_SMOD_EOBFIFO   ( 0x3 << 10 )
-#define CCR_MDIR_DEC       (1<<9)
-#define CCR_MSEL_B         (1<<8)
-#define CCR_DSIZ_32        ( 0x0 << 6 )
-#define CCR_DSIZ_8         ( 0x1 << 6 )
-#define CCR_DSIZ_16        ( 0x2 << 6 )
-#define CCR_SSIZ_32        ( 0x0 << 4 )
-#define CCR_SSIZ_8         ( 0x1 << 4 )
-#define CCR_SSIZ_16        ( 0x2 << 4 )
-#define CCR_REN            (1<<3)
-#define CCR_RPT            (1<<2)
-#define CCR_FRC            (1<<1)
-#define CCR_CEN            (1<<0)
-#define RTOR_EN            (1<<15)
-#define RTOR_CLK           (1<<14)
-#define RTOR_PSC           (1<<13)
+#define CRM_CSCR	__REG(MX2ADS_CRM_BASE + 0x0)
+#define CSCR_PRESC_MASK		(0x7<<29)
+#define CSCR_PRESC(x)		(((x) & 0x7) << 29)
+#define CSCR_USB_DIV_MASK	(0x7<<26)
+#define CSCR_USB_DIV(x)		(((x) & 0x7) << 26)
+#define CSCR_SD_CNT_MASK	(0x3<<24)
+#define CSCR_SD_CNT(x)		(((x) & 0x3) << 24)
+#define CSCR_SPLL_RESTART	(1<<22)
+#define CSCR_MPLL_RESTART	(1<<21)
+#define CSCR_SSI2_SEL		(1<<20)
+#define CSCR_SSI1_SEL		(1<<19)
+#define CSCR_FIR_SEL		(1<<18)
+#define CSCR_SP_SEL		(1<<17)
+#define CSCR_MCU_SEL		(1<<16)
+#define CSCR_BCLKDIV_MASK	(0xf<<10)
+#define CSCR_BCLKDIV(x)		(((x) & 0xf) << 10)
+#define CSCR_IPDIV		(1<<9)
+#define CSCR_OSC26M_DIV1P5	(1<<4)
+#define CSCR_OSC28M_DIS		(1<<3)
+#define CSCR_FPM_EN		(1<<2)
+#define CSCR_SPEN		(1<<1)
+#define CSCR_MPEN		(1<<0)
+
+#define CRM_MPCTL0	__REG(MX2ADS_CRM_BASE + 0x4)
+#define MPCTL0_CPLM		(1<<31)
+#define MPCTL0_PD(x)		(((x) & 0xf) << 26)
+#define MPCTL0_MFD(x)		(((x) & 0x3ff) << 16)
+#define MPCTL0_MFI(x)		(((x) & 0xf) << 10)
+#define MPCTL0_MFN(x)		(((x) & 0x3ff) << 0)
+
+#define CRM_MPCTL1	__REG(MX2ADS_CRM_BASE + 0x8)
+#define MPCTL1_LF		(1<<15)
+#define MPCTL1_BRMO		(1<<6)
+
+#define CRM_SPCTL0	__REG(MX2ADS_CRM_BASE + 0xc)
+#define SPCTL0_CPLM		(1<<31)
+#define SPCTL0_PD(x)		(((x) & 0xf) << 26)
+#define SPCTL0_MFD(x)		(((x) & 0x3ff) << 16)
+#define SPCTL0_MFI(x)		(((x) & 0xf) << 10)
+#define SPCTL0_MFN(x)		(((x) & 0x3ff) << 0)
+
+#define CRM_SPCTL1	__REG(MX2ADS_CRM_BASE + 0x10)
+#define SPCTL1_LF		(1<<15)
+#define SPCTL1_BRMO		(1<<6)
+
+#define CRM_OSC26MCTL	__REG(MX2ADS_CRM_BASE + 0x14)
+#define OSC26MCTL_OSC26M_PEAK	(0x2<<16)
+#define OSC25MCTL_AGC(x)	(((x) & 0x3f) << 8)
+
+#define CRM_PCDR0	__REG(MX2ADS_CRM_BASE + 0x18)
+#define PCDR0_SSI2DIV(x)	(((x) & 0x3f) << 26)
+#define PCDR0_SSI1DIV(x)	(((x) & 0x3f) << 16)
+#define PCDR0_NFCDIV(x)		(((x) & 0xf) << 12)
+#define PCDR0_CLKO_48MDIV(x)	(((x) & 0x7) << 5)
+#define PCDR0_FIRI_DIV(x)	(((x) & 0x1f) << 0)
+		
+#define CRM_PCDR1	__REG(MX2ADS_CRM_BASE + 0x1c)
+#define PCDR1_PERDIV4_POS	24
+#define PCDR1_PERDIV4_MASK	(0x3f << PCDR1_PERDIV4_POS)
+#define PCDR1_PERDIV4(x)	(((x) & 0x3f) << 24)
+#define PCDR1_PERDIV3_POS	16
+#define PCDR1_PERDIV3_MASK	(0x3f << PCDR1_PERDIV3_POS)
+#define PCDR1_PERDIV3(x) 	(((x) & 0x3f) << 16)
+#define PCDR1_PERDIV2_POS	8
+#define PCDR1_PERDIV2_MASK	(0x3f << PCDR1_PERDIV2_POS)
+#define PCDR1_PERDIV2(x) 	(((x) & 0x3f) << 8)
+#define PCDR1_PERDIV1_POS	0
+#define PCDR1_PERDIV1_MASK	(0x3f << PCDR1_PERDIV1_POS)
+#define PCDR1_PERDIV1(x) 	(((x) & 0x3f) << 0)
+
+#define CRM_PCCR0	__REG(MX2ADS_CRM_BASE + 0x20) 
+#define PCCR0_HCLK_CSI_EN 	(1<<31)
+#define PCCR0_HCLK_DMA_EN 	(1<<30)
+#define PCCR0_HCLK_BROM_EN 	(1<<28)
+#define PCCR0_HCLK_EMMA_EN 	(1<<27)
+#define PCCR0_HCLK_LCDC_EN 	(1<<26)
+#define PCCR0_HCLK_SLCDC_EN 	(1<<25)
+#define PCCR0_HCLK_USBOTG_EN 	(1<<24)
+#define PCCR0_HCLK_BMI_EN 	(1<<23)
+#define PCCR0_PERCLK4_EN 	(1<<22)
+#define PCCR0_SLCDC_EN	 	(1<<21)
+#define PCCR0_FIRI_BAUD_EN 	(1<<20)
+#define PCCR0_NFC_EN		(1<<19)
+#define PCCR0_PERCLK3_EN 	(1<<18)
+#define PCCR0_SSI1_BAUD_EN 	(1<<17)
+#define PCCR0_SSI2_BAUD_EN 	(1<<16)
+#define PCCR0_EMMA_EN 		(1<<15)
+#define PCCR0_USBOTG_EN	 	(1<<14)
+#define PCCR0_DMA_EN 		(1<<13)
+#define PCCR0_I2C_EN 		(1<<12)
+#define PCCR0_GPIO_EN	 	(1<<11)
+#define PCCR0_SDHC2_EN	 	(1<<10)
+#define PCCR0_SDHC1_EN	 	(1<<9)
+#define PCCR0_FIRI_EN	 	(1<<8)
+#define PCCR0_SSI2_EN	 	(1<<7)
+#define PCCR0_SSI1_EN		(1<<6)
+#define PCCR0_CSPI2_EN	 	(1<<5)
+#define PCCR0_CSPI1_EN	 	(1<<4)
+#define PCCR0_UART4_EN	 	(1<<3)
+#define PCCR0_UART3_EN	 	(1<<2)
+#define PCCR0_UART2_EN 		(1<<1)
+#define PCCR0_UART1_EN	 	(1<<0)
+
+#define CRM_PCCR1	__REG(MX2ADS_CRM_BASE + 0x24)
+#define PCCR1_OWIRE_EN		(1<<31)
+#define PCCR1_KPP_EN		(1<<30)
+#define PCCR1_RTC_EN		(1<<29)
+#define PCCR1_PWM_EN		(1<<28)
+#define PCCR1_GPT3_EN		(1<<27)
+#define PCCR1_GPT2_EN		(1<<26)
+#define PCCR1_GPT1_EN		(1<<25)
+#define PCCR1_WDT_EN		(1<<24)
+#define PCCR1_CSPI3_EN		(1<<23)
+#define PCCR1_RTIC_EN		(1<<22)
+#define PCCR1_RNGA_EN		(1<<21)
+
+#define CRM_CCSR	__REG(MX2ADS_CRM_BASE + 0x28)
+#define CCSR_32K_SR		(1<<15)
+#define CCSR_CLK0_SEL(x)	(((x) & 0x1f) << 0)
+	
+#define CRM_WKGDCTL	__REG(MX2ADS_CRM_BASE + 0x34)
+#define WKGDCTL_WKDG_EN		(1<<0)
 
 /*
- *  Interrupt controller
+ * LCD controller (LCDC) registers
  */
 
-#define IMX_INTCNTL        __REG(IMX_AITC_BASE+0x00)
-#define INTCNTL_FIAD       (1<<19)
-#define INTCNTL_NIAD       (1<<20)
+#define LCDC_LSSAR	__REG(MX2ADS_LCDC_BASE + 0x0)
+#define LSSAR_SSA(x)		(((x) & 0x3fffffff) << 2)
 
-#define IMX_NIMASK         __REG(IMX_AITC_BASE+0x04)
-#define IMX_INTENNUM       __REG(IMX_AITC_BASE+0x08)
-#define IMX_INTDISNUM      __REG(IMX_AITC_BASE+0x0c)
-#define IMX_INTENABLEH     __REG(IMX_AITC_BASE+0x10)
-#define IMX_INTENABLEL     __REG(IMX_AITC_BASE+0x14)
+#define LCDC_LSR 	__REG(MX2ADS_LCDC_BASE + 0x4)
+#define LSR_XMAX(x)		(((x) & 0x3f) << 20)
+#define LSR_YMAX(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LVPWR 	__REG(MX2ADS_LCDC_BASE + 0x8)
+#define LVPWR_VPW(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LCPR 	__REG(MX2ADS_LCDC_BASE + 0xc)
+#define LCPR_CC(x)		(((x) & 0x3) << 30)
+#define LCPR_OP			(1<<28)
+#define LCPR_CXP(x)		(((x) & 0x3ff) << 16)
+#define LCPR_CYP(x)		(((x) & 0x3ff) << 0)
+
+#define LCPR_CC_DISABLED	0
+#define LCPR_CC_OR		1
+#define LCPR_CC_XOR		2
+#define LCPR_CC_AND		3
+
+#define LCDC_LCWHBR 	__REG(MX2ADS_LCDC_BASE + 0x10)
+#define LCWHBR_BK_EN		(1<<31)
+#define LCWHBR_CW(x)		(((x) & 0x1f) << 24)
+#define LCWHBR_CH(x)		(((x) & 0x1f) << 16)
+#define LCWHBR_BD(x)		(((x) & 0xff) << 0)
+
+#define LCDC_LCCMR 	__REG(MX2ADS_LCDC_BASE + 0x14)
+#define LCCMR_CUR_COL_R(x)	(((x) & 0x3f) << 12)
+#define LCCMR_CUR_COL_G(x)	(((x) & 0x3f) << 6)
+#define LCCMR_CUR_COL_B(x)	(((x) & 0x3f) << 0)
+
+#define LCDC_LPCR 	__REG(MX2ADS_LCDC_BASE + 0x18)
+#define LPCR_TFT		(1<<31)
+#define LPCR_COLOR		(1<<30)
+#define LPCR_PBSIZ_POS		28
+#define LPCR_PBSIZ_MASK		(0x3 << LPCR_PBSIZ_POS)
+#define LPCR_PBSIZ(x)		(((x) << LPCR_PBSIZ_POS) & LPCR_PBSIZ_MASK)
+#define LPCR_BPIX_POS		25
+#define LPCR_BPIX_MASK		(0x7 << LPCR_BPIX_POS)
+#define LPCR_BPIX(x)		(((x) << LPCR_BPIX_POS) & LPCR_BPIX_MASK)
+#define LPCR_PIXPOL		(1<<24)
+#define LPCR_FLMPOL		(1<<23)
+#define LPCR_LPPOL		(1<<22)
+#define LPCR_CLKPOL		(1<<21)
+#define LPCR_OEPOL		(1<<20)
+#define LPCR_SCLKIDLE		(1<<19)
+#define LPCR_END_SEL		(1<<18)
+#define LPCR_SWAP_SEL		(1<<17)
+#define LPCR_REV_VS		(1<<16)
+#define LPCR_ACDSEL		(1<<15)
+#define LPCR_ACD(x)		(((x) & 0x7f) << 8)
+#define LPCR_SCLKSEL		(1<<7)
+#define LPCR_SHARP		(1<<6)
+#define LPCR_PCD(x)		(((x) & 0x3f) << 0)
+
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_1	0
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_4	2
+#define LPCR_PBSIZ_PANEL_BUS_WIDTH_8	3
+
+#define LPCR_BPIX_BITS_PER_PIXEL_1	0
+#define LPCR_BPIX_BITS_PER_PIXEL_2	1
+#define LPCR_BPIX_BITS_PER_PIXEL_4	2
+#define LPCR_BPIX_BITS_PER_PIXEL_8	3
+#define LPCR_BPIX_BITS_PER_PIXEL_12	4
+#define LPCR_BPIX_BITS_PER_PIXEL_16	5
+#define LPCR_BPIX_BITS_PER_PIXEL_18	6
+
+#define LCDC_LHCR 	__REG(MX2ADS_LCDC_BASE + 0x1c)
+#define LHCR_H_WIDTH(x)		(((x) & 0x3f) << 26)
+#define LHCR_H_WAIT_1(x)	(((x) & 0x1ff) << 8)
+#define LHCR_H_WAIT_2(x)	(((x) & 0x1ff) << 0)
+
+#define LCDC_LVCR 	__REG(MX2ADS_LCDC_BASE + 0x20)
+#define LVCR_V_WIDTH(x)		(((x) & 0x3f) << 26)
+#define LVCR_V_WAIT_1(x)	(((x) & 0x1ff) << 8)
+#define LVCR_V_WAIT_2(x)	(((x) & 0x1ff) << 0)
+
+#define LCDC_LPOR 	__REG(MX2ADS_LCDC_BASE + 0x24)
+#define LPOR_POS(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LSCR 	__REG(MX2ADS_LCDC_BASE + 0x28)
+#define LSCR_PS_RISE_DELAY(x)		(((x) & 0x3f) << 26)
+#define LSCR_CLS_RISE_DELAY(x)		(((x) & 0xff) << 16)
+#define LSCR_REV_TOGGLE_DELAY(x)	(((x) & 0xf) << 8)
+#define LSCR_GRAY2(x)			(((x) & 0xf) << 4)
+#define LSCR_GRAY1(x)			(((x) & 0xf) << 0)
+
+#define LCDC_LPCCR 	__REG(MX2ADS_LCDC_BASE + 0x2c)
+#define LPCCR_CLS_HI_WIDTH(x)	(((x) & 0x1ff) << 16)
+#define LPCCR_LDMSK		(1<<15)
+#define LPCCR_SCR(x)		(((x) & 0x3) << 9)
+#define LPCCR_CC_EN		(1<<8)
+#define LPCCR_PW(x)		(((x) & 0xff) << 0)
+
+#define LPCCR_SCR_LINE_PULSE	0
+#define LPCCR_SCR_PIXEL_CLOCK	1
+#define LPCCR_SCR_LCD_CLOCK	2
+
+#define LCDC_LDCR 	__REG(MX2ADS_LCDC_BASE + 0x30)
+#define LDCR_BURST		(1<<31)
+#define LDCR_HM(x)		(((x) & 0x1f) << 16)
+#define LDCR_TM(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LRMCR 	__REG(MX2ADS_LCDC_BASE + 0x34)
+#define LRMCR_LCDC_EN	        (1<<1)
+#define LRMCR_SELF_REF		(1<<0)
+
+
+#define LCDC_LICR 	__REG(MX2ADS_LCDC_BASE + 0x38)
+#define LICR_GW_INIT_CON	(1<<4)
+#define LICR_INTSYN		(1<<2)
+#define LICR_INTCON		(1<<0)
+
+#define LCDC_LIER 	__REG(MX2ADS_LCDC_BASE + 0x3c)
+#define LIER_GW_UDR_ERR_EN	(1<<7)
+#define LIER_GW_ERR_RES_EN	(1<<6)
+#define LIER_GW_EOF_EN		(1<<5)
+#define LIER_GW_BOF_EN		(1<<4)
+#define LIER_UDR_ERR_EN		(1<<3)
+#define LIER_ERR_RES_EN		(1<<2)
+#define LIER_EOF_EN		(1<<1)
+#define LIER_BOF_EN		(1<<0)
+
+#define LCDC_LISR 	__REG(MX2ADS_LCDC_BASE + 0x40)
+#define LISR_GW_UDR_ERR_MASK	(1<<7)
+#define LISR_GW_ERR_RES_MASK	(1<<6)
+#define LISR_GW_EOF_MASK	(1<<5)
+#define LISR_GW_BOF_MASK	(1<<4)
+#define LISR_UDR_ERR_MASK	(1<<3)
+#define LISR_ERR_RES_MASK	(1<<2)
+#define LISR_EOF_MASK		(1<<1)
+#define LISR_BOF_MASK		(1<<0)
+
+#define LCDC_LGWSAR 	__REG(MX2ADS_LCDC_BASE + 0x50)
+#define LGWSAR_GWSA(x)		(((x) & 0x3fffffff) << 2)
+
+#define LCDC_LGWSR 	__REG(MX2ADS_LCDC_BASE + 0x54)
+#define LGWSR_GWW(x)		(((x) & 0x3f) << 20)
+#define LGWSR_GWH(x)		(((x) & 0x3fff) << 0)
+
+#define LCDC_LGWVPWR 	__REG(MX2ADS_LCDC_BASE + 0x58)
+#define LGWVPWR_GWVPW(x)	(((x) & 0x3ff) << 0)
+
+#define LCDC_LGWPOR 	__REG(MX2ADS_LCDC_BASE + 0x5c)
+#define LGWPOR(x)		(((x) & 0x1f) << 0)
+
+#define LCDC_LGWPR 	__REG(MX2ADS_LCDC_BASE + 0x60)
+#define LGWPR_GWXP(x)		(((x) & 0x3ff) << 16)
+#define LGWPR_GWYP(x)		(((x) & 0x3ff) << 0)
+
+#define LCDC_LGWCR 	__REG(MX2ADS_LCDC_BASE + 0x64)
+#define LGWCR_GWAV(x)		(((x) & 0xff) << 24)
+#define LGWCR_GWCKE		(1<<23)
+#define LGWCR_GWE		(1<<22)
+#define LGWCR_GW_RVS		(1<<21)
+#define LGWCR_GWCKR(x)		(((x) & 0x3f) << 12)
+#define LGWCR_GWCKG(x)		(((x) & 0x3f) << 6)
+#define LGWCR_GWCKB(x)		(((x) & 0x3f) << 0)
+
+#define LCDC_LGWDCR 	__REG(MX2ADS_LCDC_BASE + 0x68)
+#define LGWDCR_GWBT		(1<<31)
+#define LGWDCR_GWHM(x)		(((x) & 0x1f) << 16)
+#define LGWDCR_GWTM(x)		(((x) & 0x1f) << 0)
 
 /*
  *  General purpose timers
  */
-#define IMX_TCTL(x)        __REG( 0x00 + (x))
+#define WHICH_TIMER(x)     ((x)*0x1000)
+#define IMX21_TCTL(x)        __REG( 0x00 + MX2ADS_GPT1_BASE + WHICH_TIMER(x) )
 #define TCTL_SWR           (1<<15)
 #define TCTL_FRR           (1<<8)
 #define TCTL_CAP_RIS       (1<<6)
 #define TCTL_CAP_FAL       (2<<6)
 #define TCTL_CAP_RIS_FAL   (3<<6)
-#define TCTL_OM            (1<<5)
-#define TCTL_IRQEN         (1<<4)
 #define TCTL_CLK_PCLK1     (1<<1)
 #define TCTL_CLK_PCLK1_16  (2<<1)
 #define TCTL_CLK_TIN       (3<<1)
 #define TCTL_CLK_32        (4<<1)
 #define TCTL_TEN           (1<<0)
 
-#define IMX_TPRER(x)       __REG( 0x04 + (x))
-#define IMX_TCMP(x)        __REG( 0x08 + (x))
-#define IMX_TCR(x)         __REG( 0x0C + (x))
-#define IMX_TCN(x)         __REG( 0x10 + (x))
-#define IMX_TSTAT(x)       __REG( 0x14 + (x))
-#define TSTAT_CAPT         (1<<1)
-#define TSTAT_COMP         (1<<0)
-
 /*
- * LCD Controller
+ * Update with Xenomai patch for iMx21 plateform
  */
+#define TCTL_OM		   (1<<9)
+#define TCTL_CC            (1<<10)
+#define TCTL_IRQ_COMP	   (1<<4)
+#define TCTL_IRQ_CAPT	   (1<<5)
 
-#define LCDC_SSA	__REG(IMX_LCDC_BASE+0x00)
-
-#define LCDC_SIZE	__REG(IMX_LCDC_BASE+0x04)
-#define SIZE_XMAX(x)	((((x) >> 4) & 0x3f) << 20)
-#define SIZE_YMAX(y)    ( (y) & 0x1ff )
-
-#define LCDC_VPW	__REG(IMX_LCDC_BASE+0x08)
-#define VPW_VPW(x)	( (x) & 0x3ff )
-
-#define LCDC_CPOS	__REG(IMX_LCDC_BASE+0x0C)
-#define CPOS_CC1        (1<<31)
-#define CPOS_CC0        (1<<30)
-#define CPOS_OP         (1<<28)
-#define CPOS_CXP(x)     (((x) & 3ff) << 16)
-#define CPOS_CYP(y)     ((y) & 0x1ff)
-
-#define LCDC_LCWHB	__REG(IMX_LCDC_BASE+0x10)
-#define LCWHB_BK_EN     (1<<31)
-#define LCWHB_CW(w)     (((w) & 0x1f) << 24)
-#define LCWHB_CH(h)     (((h) & 0x1f) << 16)
-#define LCWHB_BD(x)     ((x) & 0xff)
-
-#define LCDC_LCHCC	__REG(IMX_LCDC_BASE+0x14)
-#define LCHCC_CUR_COL_R(r) (((r) & 0x1f) << 11)
-#define LCHCC_CUR_COL_G(g) (((g) & 0x3f) << 5)
-#define LCHCC_CUR_COL_B(b) ((b) & 0x1f)
-
-#define LCDC_PCR	__REG(IMX_LCDC_BASE+0x18)
-#define PCR_TFT         (1<<31)
-#define PCR_COLOR       (1<<30)
-#define PCR_PBSIZ_1     (0<<28)
-#define PCR_PBSIZ_2     (1<<28)
-#define PCR_PBSIZ_4     (2<<28)
-#define PCR_PBSIZ_8     (3<<28)
-#define PCR_BPIX_1      (0<<25)
-#define PCR_BPIX_2      (1<<25)
-#define PCR_BPIX_4      (2<<25)
-#define PCR_BPIX_8      (3<<25)
-#define PCR_BPIX_12     (4<<25)
-#define PCR_BPIX_16     (4<<25)
-#define PCR_PIXPOL      (1<<24)
-#define PCR_FLMPOL      (1<<23)
-#define PCR_LPPOL       (1<<22)
-#define PCR_CLKPOL      (1<<21)
-#define PCR_OEPOL       (1<<20)
-#define PCR_SCLKIDLE    (1<<19)
-#define PCR_END_SEL     (1<<18)
-#define PCR_END_BYTE_SWAP (1<<17)
-#define PCR_REV_VS      (1<<16)
-#define PCR_ACD_SEL     (1<<15)
-#define PCR_ACD(x)      (((x) & 0x7f) << 8)
-#define PCR_SCLK_SEL    (1<<7)
-#define PCR_SHARP       (1<<6)
-#define PCR_PCD(x)      ((x) & 0x3f)
-
-#define LCDC_HCR	__REG(IMX_LCDC_BASE+0x1C)
-#define HCR_H_WIDTH(x)  (((x) & 0x3f) << 26)
-#define HCR_H_WAIT_1(x) (((x) & 0xff) << 8)
-#define HCR_H_WAIT_2(x) ((x) & 0xff)
-
-#define LCDC_VCR	__REG(IMX_LCDC_BASE+0x20)
-#define VCR_V_WIDTH(x)  (((x) & 0x3f) << 26)
-#define VCR_V_WAIT_1(x) (((x) & 0xff) << 8)
-#define VCR_V_WAIT_2(x) ((x) & 0xff)
-
-#define LCDC_POS	__REG(IMX_LCDC_BASE+0x24)
-#define POS_POS(x)      ((x) & 1f)
-
-#define LCDC_LSCR1	__REG(IMX_LCDC_BASE+0x28)
-#define LSCR1_PS_RISE_DELAY(x)    (((x) & 0x7f) << 26)
-#define LSCR1_CLS_RISE_DELAY(x)   (((x) & 0x3f) << 16)
-#define LSCR1_REV_TOGGLE_DELAY(x) (((x) & 0xf) << 8)
-#define LSCR1_GRAY2(x)            (((x) & 0xf) << 4)
-#define LSCR1_GRAY1(x)            (((x) & 0xf))
-
-#define LCDC_PWMR	__REG(IMX_LCDC_BASE+0x2C)
-#define PWMR_CLS(x)     (((x) & 0x1ff) << 16)
-#define PWMR_LDMSK      (1<<15)
-#define PWMR_SCR1       (1<<10)
-#define PWMR_SCR0       (1<<9)
-#define PWMR_CC_EN      (1<<8)
-#define PWMR_PW(x)      ((x) & 0xff)
+#define IMX21_TPRER(x)       __REG( 0x04 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCMP(x)        __REG( 0x08 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCR(x)         __REG( 0x0C + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TCN(x)         __REG( 0x10 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define IMX21_TSTAT(x)       __REG( 0x14 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
+#define TSTAT_CAPT         (1<<1)
+#define TSTAT_COMP         (1<<0)
 
-#define LCDC_DMACR	__REG(IMX_LCDC_BASE+0x30)
-#define DMACR_BURST     (1<<31)
-#define DMACR_HM(x)     (((x) & 0xf) << 16)
-#define DMACR_TM(x)     ((x) &0xf)
+#define GPT1		0
+#define GPT2		1
+#define GPT3		2
 
-#define LCDC_RMCR	__REG(IMX_LCDC_BASE+0x34)
-#define RMCR_LCDC_EN		(1<<1)
-#define RMCR_SELF_REF		(1<<0)
+/*
+ *  Uart controller registers 
+ */
 
-#define LCDC_LCDICR	__REG(IMX_LCDC_BASE+0x38)
-#define LCDICR_INT_SYN  (1<<2)
-#define LCDICR_INT_CON  (1)
+#define UART_1  0
+#define UART_2  1
+#define UART_3  2
+#define UART_4  3
 
-#define LCDC_LCDISR	__REG(IMX_LCDC_BASE+0x40)
-#define LCDISR_UDR_ERR (1<<3)
-#define LCDISR_ERR_RES (1<<2)
-#define LCDISR_EOF     (1<<1)
-#define LCDISR_BOF     (1<<0)
 
-/*
- *  UART Module. Takes the UART base address as argument
- */
 #define URXD0(x) __REG( 0x0 + (x)) /* Receiver Register */
 #define URTX0(x) __REG( 0x40 + (x)) /* Transmitter Register */
 #define UCR1(x)  __REG( 0x80 + (x)) /* Control Register 1 */
@@ -490,15 +627,10 @@
 #define UBIR(x)  __REG( 0xa4 + (x)) /* BRM Incremental Register */
 #define UBMR(x)  __REG( 0xa8 + (x)) /* BRM Modulator Register */
 #define UBRC(x)  __REG( 0xac + (x)) /* Baud Rate Count Register */
-#define BIPR1(x) __REG( 0xb0 + (x)) /* Incremental Preset Register 1 */
-#define BIPR2(x) __REG( 0xb4 + (x)) /* Incremental Preset Register 2 */
-#define BIPR3(x) __REG( 0xb8 + (x)) /* Incremental Preset Register 3 */
-#define BIPR4(x) __REG( 0xbc + (x)) /* Incremental Preset Register 4 */
-#define BMPR1(x) __REG( 0xc0 + (x)) /* BRM Modulator Register 1 */
-#define BMPR2(x) __REG( 0xc4 + (x)) /* BRM Modulator Register 2 */
-#define BMPR3(x) __REG( 0xc8 + (x)) /* BRM Modulator Register 3 */
-#define BMPR4(x) __REG( 0xcc + (x)) /* BRM Modulator Register 4 */
-#define UTS(x)   __REG( 0xd0 + (x)) /* UART Test Register */
+#define ONMES(x) __REG( 0xb0 + (x)) /* One Millisecond Register */
+#define UTS(x)   __REG( 0xb4 + (x)) /* UART Test Register */
+
+
 
 /* UART Control Register Bit Fields.*/
 #define  URXD_CHARRDY    (1<<15)
@@ -507,6 +639,7 @@
 #define  URXD_FRMERR     (1<<12)
 #define  URXD_BRK        (1<<11)
 #define  URXD_PRERR      (1<<10)
+
 #define  UCR1_ADEN       (1<<15) /* Auto dectect interrupt */
 #define  UCR1_ADBR       (1<<14) /* Auto detect baud rate */
 #define  UCR1_TRDYEN     (1<<13) /* Transmitter ready interrupt enable */
@@ -518,9 +651,10 @@
 #define  UCR1_RTSDEN     (1<<5)	 /* RTS delta interrupt enable */
 #define  UCR1_SNDBRK     (1<<4)	 /* Send break */
 #define  UCR1_TDMAEN     (1<<3)	 /* Transmitter ready DMA enable */
-#define  UCR1_UARTCLKEN  (1<<2)	 /* UART clock enabled */
+// not on mx21 #define  UCR1_UARTCLKEN  (1<<2)	 /* UART clock enabled */
 #define  UCR1_DOZE       (1<<1)	 /* Doze */
 #define  UCR1_UARTEN     (1<<0)	 /* UART enabled */
+
 #define  UCR2_ESCI     	 (1<<15) /* Escape seq interrupt enable */
 #define  UCR2_IRTS  	 (1<<14) /* Ignore RTS pin */
 #define  UCR2_CTSC  	 (1<<13) /* CTS pin control */
@@ -531,36 +665,44 @@
 #define  UCR2_STPB       (1<<6)	 /* Stop */
 #define  UCR2_WS         (1<<5)	 /* Word size */
 #define  UCR2_RTSEN      (1<<4)	 /* Request to send interrupt enable */
+#define  UCR2_ATEN	 (1<<3)  /* Aging Timer Enable */
 #define  UCR2_TXEN       (1<<2)	 /* Transmitter enabled */
 #define  UCR2_RXEN       (1<<1)	 /* Receiver enabled */
 #define  UCR2_SRST 	 (1<<0)	 /* SW reset */
+
 #define  UCR3_DTREN 	 (1<<13) /* DTR interrupt enable */
 #define  UCR3_PARERREN   (1<<12) /* Parity enable */
 #define  UCR3_FRAERREN   (1<<11) /* Frame error interrupt enable */
 #define  UCR3_DSR        (1<<10) /* Data set ready */
 #define  UCR3_DCD        (1<<9)  /* Data carrier detect */
 #define  UCR3_RI         (1<<8)  /* Ring indicator */
-#define  UCR3_TIMEOUTEN  (1<<7)  /* Timeout interrupt enable */
+#define  UCR3_ADNIMP     (1<<7)  /* Timeout interrupt enable */
 #define  UCR3_RXDSEN	 (1<<6)  /* Receive status interrupt enable */
 #define  UCR3_AIRINTEN   (1<<5)  /* Async IR wake interrupt enable */
 #define  UCR3_AWAKEN	 (1<<4)  /* Async wake interrupt enable */
-#define  UCR3_REF25 	 (1<<3)  /* Ref freq 25 MHz */
-#define  UCR3_REF30 	 (1<<2)  /* Ref Freq 30 MHz */
+// not on mx21 #define  UCR3_REF25 	 (1<<3)  /* Ref freq 25 MHz */
+#define  UCR3_RXDMUXSEL  (1<<2)  /* RXD Mux Input Select */
 #define  UCR3_INVT  	 (1<<1)  /* Inverted Infrared transmission */
-#define  UCR3_BPEN  	 (1<<0)  /* Preset registers enable */
-#define  UCR4_CTSTL_32   (32<<10) /* CTS trigger level (32 chars) */
+#define  UCR3_ACIEN  	 (1<<0)  /* Autobaud Counter  Interrupt Enable */
+
+
 #define  UCR4_INVR  	 (1<<9)  /* Inverted infrared reception */
 #define  UCR4_ENIRI 	 (1<<8)  /* Serial infrared interrupt enable */
 #define  UCR4_WKEN  	 (1<<7)  /* Wake interrupt enable */
-#define  UCR4_REF16 	 (1<<6)  /* Ref freq 16 MHz */
+// not on mx21 #define  UCR4_REF16 	 (1<<6)  /* Ref freq 16 MHz */
 #define  UCR4_IRSC  	 (1<<5)  /* IR special case */
+#define  UCR4_LPBYP  	 (1<<5)  /* Low Power Bypass */
 #define  UCR4_TCEN  	 (1<<3)  /* Transmit complete interrupt enable */
 #define  UCR4_BKEN  	 (1<<2)  /* Break condition interrupt enable */
 #define  UCR4_OREN  	 (1<<1)  /* Receiver overrun interrupt enable */
 #define  UCR4_DREN  	 (1<<0)  /* Recv data ready interrupt enable */
+
 #define  UFCR_RXTL_SHF   0       /* Receiver trigger level shift */
 #define  UFCR_RFDIV      (7<<7)  /* Reference freq divider mask */
+#define  UFCR_RFDIV_SHF  7	 /* Reference freq divider shift */
 #define  UFCR_TXTL_SHF   10      /* Transmitter trigger level shift */
+#define  UFCR_DCEDTE	 (1<<6)  /* DCE/DTE Mode */
+
 #define  USR1_PARITYERR  (1<<15) /* Parity error interrupt flag */
 #define  USR1_RTSS  	 (1<<14) /* RTS pin status */
 #define  USR1_TRDY  	 (1<<13) /* Transmitter ready interrupt/dma flag */
@@ -568,27 +710,38 @@
 #define  USR1_ESCF  	 (1<<11) /* Escape seq interrupt flag */
 #define  USR1_FRAMERR    (1<<10) /* Frame error interrupt flag */
 #define  USR1_RRDY       (1<<9)	 /* Receiver ready interrupt/dma flag */
-#define  USR1_TIMEOUT    (1<<7)	 /* Receive timeout interrupt status */
+#define  USR1_AGTIM      (1<<8)	 /* Aging Timer Interrupt Flag */
+// not on mx21 #define  USR1_TIMEOUT    (1<<7)	 /* Receive timeout interrupt status */
 #define  USR1_RXDS  	 (1<<6)	 /* Receiver idle interrupt flag */
 #define  USR1_AIRINT	 (1<<5)	 /* Async IR wake interrupt flag */
 #define  USR1_AWAKE 	 (1<<4)	 /* Aysnc wake interrupt flag */
+
 #define  USR2_ADET  	 (1<<15) /* Auto baud rate detect complete */
 #define  USR2_TXFE  	 (1<<14) /* Transmit buffer FIFO empty */
 #define  USR2_DTRF  	 (1<<13) /* DTR edge interrupt flag */
 #define  USR2_IDLE  	 (1<<12) /* Idle condition */
+#define  USR2_ACST  	 (1<<11) /* Autobaud Controller Stopped*/
+#define  USR2_RIDELT  	 (1<<10) /* Ring Indicator Delta */
+#define  USR2_RIIN  	 (1<<9)  /* Ring Indicator Input*/
 #define  USR2_IRINT 	 (1<<8)	 /* Serial infrared interrupt flag */
 #define  USR2_WAKE  	 (1<<7)	 /* Wake */
+#define  USR2_DCDDELT  	 (1<<6)	 /* Data Carrier Delta Detect */
+#define  USR2_DCDIN  	 (1<<5)	 /* Data Carrier Detect Input */
 #define  USR2_RTSF  	 (1<<4)	 /* RTS edge interrupt flag */
 #define  USR2_TXDC  	 (1<<3)	 /* Transmitter complete */
 #define  USR2_BRCD  	 (1<<2)	 /* Break condition */
 #define  USR2_ORE        (1<<1)	 /* Overrun error */
 #define  USR2_RDR        (1<<0)	 /* Recv data ready */
+
 #define  UTS_FRCPERR	 (1<<13) /* Force parity error */
 #define  UTS_LOOP        (1<<12) /* Loop tx and rx */
+#define  UTS_DBGEN       (1<<11) /* /Debug Enable */
+#define  UTS_LOOPIR      (1<<10) /* Loop tx and rx for IR */
+#define  UTS_RXFIFO	 (1<<9)	 /* RXFifo Debug */
 #define  UTS_TXEMPTY	 (1<<6)	 /* TxFIFO empty */
 #define  UTS_RXEMPTY	 (1<<5)	 /* RxFIFO empty */
 #define  UTS_TXFULL 	 (1<<4)	 /* TxFIFO full */
 #define  UTS_RXFULL 	 (1<<3)	 /* RxFIFO full */
 #define  UTS_SOFTRST	 (1<<0)	 /* Software reset */
 
-#endif				// _IMX_REGS_H
+#endif				// _MX2ADS_REGS_H
diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp ipipe-2.6.14-arm-imx21/include/asm-arm/arch-imx21/csb535.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/csb535.h
--- ipipe-2.6.14-arm-imx21/include/asm-arm/arch-imx21/csb535.h	2007-01-20 16:57:08.587281198 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/csb535.h	2007-01-20 15:58:52.573225454 +0100
@@ -20,6 +20,16 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
+ * April 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board with Xenomai by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ *
+ * 24.04.06 : define the value : TICKS_PER_uSEC
+ *             adapted by Sébastien Gerber
+ * 25.04.06 : add a constant for the timer clock (CLKPERCLK1)
+ *             adapted by Sébastien Gerber
+ * 
  */
 
 #ifndef __ASM_ARCH_CSB535_H
@@ -34,7 +44,11 @@
 
 #define IMX_FB_PHYS			(0x0C000000 - 0x40000)
 
-#define CLK32 32768
+#define CLK32                            32768
+#define CLKPERCLK1                       16515072
+
+#define TICKS_PER_uSEC                    CLKPERCLK1 / 1000000
+
 
 #define CSB535_ETH_VIRT IMX21_CS1_VIRT
 #define CSB535_ETH_PHYS IMX21_CS1_PHYS
diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp ipipe-2.6.14-arm-imx21/include/asm-arm/arch-imx21/imx-regs.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/imx-regs.h
--- ipipe-2.6.14-arm-imx21/include/asm-arm/arch-imx21/imx-regs.h	2007-01-20 16:57:08.592280576 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/imx-regs.h	2007-01-20 15:58:52.573225454 +0100
@@ -8,7 +8,13 @@
  * Copyright (C) 2005 TimeSys Corporation 
  *
  * Modified by: Stephen Donecker (sdonecker@sbcglobal.net)
- */
+ *
+ * April 2006 :
+ * Adapted to ARM9 i.MX21/CSB535FS board with Xenomai by S.Gerber, G.Boutillier and D.Rossier
+ * University of Applied Sciences Western Switzerland
+ * Reconfigurable & Embedded Digital Systems, REDS Institute
+ * 
+*/
 
 /*
  * Memory mapped I/O for the M9328MX21ADS    
@@ -69,7 +75,7 @@
 #define MX2ADS_SDHC2_BASE             (0x14000 + IMX21_IO_BASE)
 #define MX2ADS_GPIO_BASE              (0x15000 + IMX21_IO_BASE)
 #define MX2ADS_AUDMUX_BASE            (0x16000 + IMX21_IO_BASE)
-#define MX2ADS_CSPI3_BASE		(IMX21_IO_BASE + 0x17000)
+#define MX2ADS_CSPI3_BASE	      (IMX21_IO_BASE + 0x17000)
 #define MX2ADS_LCDC_BASE              (0x21000 + IMX21_IO_BASE)
 #define MX2ADS_SLCDC_BASE             (0x22000 + IMX21_IO_BASE)
 #define MX2ADS_SAHARA_BASE            (0x23000 + IMX21_IO_BASE)
@@ -77,12 +83,28 @@
 #define MX2ADS_EMMA_BASE              (0x26000 + IMX21_IO_BASE)
 #define MX2ADS_CRM_BASE               (0x27000 + IMX21_IO_BASE)
 #define MX2ADS_FIRI_BASE              (0x28000 + IMX21_IO_BASE)
-#define MX2ADS_RNGA_BASE		(IMX21_IO_BASE + 0x29000)
-#define MX2ADS_RTIC_BASE		(IMX21_IO_BASE + 0x2A000)
+#define MX2ADS_RNGA_BASE	      (IMX21_IO_BASE + 0x29000)
+#define MX2ADS_RTIC_BASE	      (IMX21_IO_BASE + 0x2A000)
 #define MX2ADS_JAM_BASE               (0x3E000 + IMX21_IO_BASE)
 #define MX2ADS_MAX_BASE               (0x3F000 + IMX21_IO_BASE)
 #define MX2ADS_AITC_BASE              (0x40000 + IMX21_IO_BASE)
 
+/*
+ * Interrupt controller
+ */
+#define AITC_NIVECSR		__REG(MX2ADS_AITC_BASE + 0x40)
+#define AITC_NIPRIORITY7	__REG(MX2ADS_AITC_BASE + 0x20)
+#define AITC_NIPRIORITY6	__REG(MX2ADS_AITC_BASE + 0x24)
+#define AITC_NIPRIORITY5	__REG(MX2ADS_AITC_BASE + 0x28)
+#define AITC_NIPRIORITY4	__REG(MX2ADS_AITC_BASE + 0x2C)
+#define AITC_NIPRIORITY3	__REG(MX2ADS_AITC_BASE + 0x30)
+#define AITC_NIPRIORITY2	__REG(MX2ADS_AITC_BASE + 0x34)
+#define AITC_NIPRIORITY1	__REG(MX2ADS_AITC_BASE + 0x38)
+#define AITC_NIPRIORITY0	__REG(MX2ADS_AITC_BASE + 0x3C)
+
+/*
+ * GPIOs
+ */
 #define GPIO_A	0
 #define GPIO_B	1
 #define GPIO_C	2
@@ -94,7 +116,6 @@
  *  GPIO Module and I/O Multiplexer
  *  x = 0..5 for reg_A, reg_B, reg_C, reg_D, reg_E, reg_F
  */
-
 #define DDIR(x)    __REG2(MX2ADS_GPIO_BASE + 0x00, ((x) & 7) << 8)
 #define OCR1(x)    __REG2(MX2ADS_GPIO_BASE + 0x04, ((x) & 7) << 8)
 #define OCR2(x)    __REG2(MX2ADS_GPIO_BASE + 0x08, ((x) & 7) << 8)
@@ -313,16 +334,16 @@
 #define CRM_PCDR1	__REG(MX2ADS_CRM_BASE + 0x1c)
 #define PCDR1_PERDIV4_POS	24
 #define PCDR1_PERDIV4_MASK	(0x3f << PCDR1_PERDIV4_POS)
-#define PCDR1_PERDIV4(x)	(((x) << PCDR1_PERDIV4_POS) & PCDR1_PERDIV4_MASK)
+#define PCDR1_PERDIV4(x)	(((x) & 0x3f) << 24)
 #define PCDR1_PERDIV3_POS	16
 #define PCDR1_PERDIV3_MASK	(0x3f << PCDR1_PERDIV3_POS)
-#define PCDR1_PERDIV3(x) 	(((x) << PCDR1_PERDIV3_POS) & PCDR1_PERDIV3_MASK)
+#define PCDR1_PERDIV3(x) 	(((x) & 0x3f) << 16)
 #define PCDR1_PERDIV2_POS	8
 #define PCDR1_PERDIV2_MASK	(0x3f << PCDR1_PERDIV2_POS)
-#define PCDR1_PERDIV2(x) 	(((x) << PCDR1_PERDIV2_POS) & PCDR1_PERDIV2_MASK)
+#define PCDR1_PERDIV2(x) 	(((x) & 0x3f) << 8)
 #define PCDR1_PERDIV1_POS	0
 #define PCDR1_PERDIV1_MASK	(0x3f << PCDR1_PERDIV1_POS)
-#define PCDR1_PERDIV1(x) 	(((x) << PCDR1_PERDIV1_POS) & PCDR1_PERDIV1_MASK)
+#define PCDR1_PERDIV1(x) 	(((x) & 0x3f) << 0)
 
 #define CRM_PCCR0	__REG(MX2ADS_CRM_BASE + 0x20) 
 #define PCCR0_HCLK_CSI_EN 	(1<<31)
@@ -486,8 +507,10 @@
 #define LDCR_TM(x)		(((x) & 0x1f) << 0)
 
 #define LCDC_LRMCR 	__REG(MX2ADS_LCDC_BASE + 0x34)
+#define LRMCR_LCDC_EN	        (1<<1)
 #define LRMCR_SELF_REF		(1<<0)
 
+
 #define LCDC_LICR 	__REG(MX2ADS_LCDC_BASE + 0x38)
 #define LICR_GW_INIT_CON	(1<<4)
 #define LICR_INTSYN		(1<<2)
@@ -547,7 +570,6 @@
 /*
  *  General purpose timers
  */
-
 #define WHICH_TIMER(x)     ((x)*0x1000)
 #define IMX21_TCTL(x)        __REG( 0x00 + MX2ADS_GPT1_BASE + WHICH_TIMER(x) )
 #define TCTL_SWR           (1<<15)
@@ -555,14 +577,20 @@
 #define TCTL_CAP_RIS       (1<<6)
 #define TCTL_CAP_FAL       (2<<6)
 #define TCTL_CAP_RIS_FAL   (3<<6)
-#define TCTL_OM            (1<<5)
-#define TCTL_IRQEN         (1<<4)
 #define TCTL_CLK_PCLK1     (1<<1)
 #define TCTL_CLK_PCLK1_16  (2<<1)
 #define TCTL_CLK_TIN       (3<<1)
 #define TCTL_CLK_32        (4<<1)
 #define TCTL_TEN           (1<<0)
 
+/*
+ * Update with Xenomai patch for iMx21 plateform
+ */
+#define TCTL_OM		   (1<<9)
+#define TCTL_CC            (1<<10)
+#define TCTL_IRQ_COMP	   (1<<4)
+#define TCTL_IRQ_CAPT	   (1<<5)
+
 #define IMX21_TPRER(x)       __REG( 0x04 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
 #define IMX21_TCMP(x)        __REG( 0x08 + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
 #define IMX21_TCR(x)         __REG( 0x0C + MX2ADS_GPT1_BASE + WHICH_TIMER(x))
diff -x '*~' -x '*.orig' -x '*.rej' -Naurdp ipipe-2.6.14-arm-imx21/include/asm-arm/arch-imx21/irqs.h ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/irqs.h
--- ipipe-2.6.14-arm-imx21/include/asm-arm/arch-imx21/irqs.h	2007-01-20 16:57:08.594280327 +0100
+++ ipipe-2.6.14-imx21/include/asm-arm/arch-imx21/irqs.h	2007-01-20 15:58:52.574225330 +0100
@@ -125,3 +125,7 @@
 #define NR_IRQS (IRQ_GPIOF(32) + 1)
 #define IRQ_GPIO(x)
 #endif
+
+#ifdef CONFIG_IPIPE
+#define __ipipe_mach_irq_mux_p(irq) ((irq) == INT_GPIO)
+#endif /* CONFIG_IPIPE */
