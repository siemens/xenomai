<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: Thread synchronization services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Thread synchronization services.<br/>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for Thread synchronization services.:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__synch.png" border="0" alt="" usemap="#group____synch"/>
<map name="group____synch" id="group____synch">
<area shape="rect" id="node1" href="group__nucleus.html" title="Xenomai nucleus." alt="" coords="7,5,143,35"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="synch_8c.html">synch.c</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Thread synchronization services. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#ga4c07b8ec87b14cf18ef512f0e0aade51">xnsynch_init</a> (struct xnsynch *synch, xnflags_t flags, xnarch_atomic_t *fastlock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a synchronization object.  <a href="#ga4c07b8ec87b14cf18ef512f0e0aade51"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">xnflags_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#ga2747e9834546af461f118e7c90c9613e">xnsynch_sleep_on</a> (struct xnsynch *synch, xnticks_t timeout, xntmode_t timeout_mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sleep on an ownerless synchronization object.  <a href="#ga2747e9834546af461f118e7c90c9613e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct xnthread *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#gad5992ddbdb81821cb29bae8900eb65ac">xnsynch_wakeup_one_sleeper</a> (struct xnsynch *synch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give the resource ownership to the next waiting thread.  <a href="#gad5992ddbdb81821cb29bae8900eb65ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct xnpholder *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#ga9e530d12df9881251231af489208762e">xnsynch_wakeup_this_sleeper</a> (struct xnsynch *synch, struct xnpholder *holder)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give the resource ownership to a given waiting thread.  <a href="#ga9e530d12df9881251231af489208762e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">xnflags_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#ga6d4ad886901c751a4f3c51b90fc8f91f">xnsynch_acquire</a> (struct xnsynch *synch, xnticks_t timeout, xntmode_t timeout_mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire the ownership of a synchronization object.  <a href="#ga6d4ad886901c751a4f3c51b90fc8f91f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#ga268adcf6898492eb6ff82445899d4bc8">xnsynch_clear_boost</a> (struct xnsynch *synch, struct xnthread *owner)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the priority boost.  <a href="#ga268adcf6898492eb6ff82445899d4bc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#ga49c975f160509b1aa04df4900614b2ce">xnsynch_requeue_sleeper</a> (struct xnthread *thread)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a sleeper's priority.  <a href="#ga49c975f160509b1aa04df4900614b2ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct xnthread *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#ga1208abb6b3d0017a4e0c43b9baff8cfb">xnsynch_release</a> (struct xnsynch *synch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give the resource ownership to the next waiting thread.  <a href="#ga1208abb6b3d0017a4e0c43b9baff8cfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct xnthread *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#gae02c775ea161a0c27b919d019d170bc2">xnsynch_peek_pendq</a> (struct xnsynch *synch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the thread leading a synch object wait queue.  <a href="#gae02c775ea161a0c27b919d019d170bc2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#ga82beb68147bc5f0306ab02a61a9dc76b">xnsynch_flush</a> (struct xnsynch *synch, xnflags_t reason)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock all waiters pending on a resource.  <a href="#ga82beb68147bc5f0306ab02a61a9dc76b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#ga997e546948920193bb36ab8d120fbab7">xnsynch_forget_sleeper</a> (struct xnthread *thread)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort a wait for a resource.  <a href="#ga997e546948920193bb36ab8d120fbab7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__synch.html#ga51146a2d5bd0ec6a10d2fcd685946938">xnsynch_release_all_ownerships</a> (struct xnthread *thread)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release all ownerships.  <a href="#ga51146a2d5bd0ec6a10d2fcd685946938"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Thread synchronization services. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga6d4ad886901c751a4f3c51b90fc8f91f"></a><!-- doxytag: member="synch.c::xnsynch_acquire" ref="ga6d4ad886901c751a4f3c51b90fc8f91f" args="(struct xnsynch *synch, xnticks_t timeout, xntmode_t timeout_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnflags_t xnsynch_acquire </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntmode_t&nbsp;</td>
          <td class="paramname"> <em>timeout_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Acquire the ownership of a synchronization object. </p>
<p>This service should be called by upper interfaces wanting the current thread to acquire the ownership of the given resource. If the resource is already assigned to a thread, the caller is suspended.</p>
<p>This service must be used only with synchronization objects that track ownership (XNSYNCH_OWNER set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object to acquire.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout which may be used to limit the time the thread pends on the resource. This value is a wait time given in ticks (see note). It can either be relative, absolute monotonic, or absolute adjustable depending on <em>timeout_mode</em>. Passing XN_INFINITE <b>and</b> setting <em>mode</em> to XN_RELATIVE specifies an unbounded wait. All other values are used to initialize a watchdog timer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_mode</em>&nbsp;</td><td>The mode of the <em>timeout</em> parameter. It can either be set to XN_RELATIVE, XN_ABSOLUTE, or XN_REALTIME (see also <a class="el" href="group__timer.html#ga0ad3c70bed7fe1a45b45ee0875f031ab" title="Arm a timer.">xntimer_start()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A bitmask which may include zero or one information bit among XNRMID, XNTIMEO and XNBREAK, which should be tested by the caller, for detecting respectively: object deletion, timeout or signal/unblock conditions which might have happened while waiting.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: possible.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the current thread is bound to a periodic time base (see xnpod_init_thread), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="group__nucleus__state__flags.html#gaca3bcd5615c7331c73c3eadddb3d1b89">XNBOOST</a>, <a class="el" href="group__nucleus__info__flags.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__nucleus__state__flags.html#ga77b8d73c05c6339c32471c777ff5288e">XNOTHER</a>, <a class="el" href="group__nucleus__state__flags.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread()</a>, <a class="el" href="group__nucleus__info__flags.html#gab07d9dea73645dbba353dc2452c15b40">XNRMID</a>, <a class="el" href="group__nucleus__info__flags.html#gad28db508d297929d6a0ec30964639d65">XNROBBED</a>, <a class="el" href="group__nucleus__info__flags.html#gaa11d7fc754db50d3a1f1e41611d324e9">XNTIMEO</a>, and <a class="el" href="group__nucleus__info__flags.html#ga53e49fa49b312e5266b31d66f7465d44">XNWAKEN</a>.</p>

<p>Referenced by <a class="el" href="group__posix__mutex.html#gaf15961a63f3579e9d9d483f75774b236">pthread_mutex_destroy()</a>, <a class="el" href="group__task.html#ga99a89c21c9866e2784860e100a444b49">rt_task_send()</a>, and <a class="el" href="group__rtdmsync.html#ga0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ga268adcf6898492eb6ff82445899d4bc8"></a><!-- doxytag: member="synch.c::xnsynch_clear_boost" ref="ga268adcf6898492eb6ff82445899d4bc8" args="(struct xnsynch *synch, struct xnthread *owner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_clear_boost </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnthread *&nbsp;</td>
          <td class="paramname"> <em>owner</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear the priority boost. </p>
<p><b>For internal use only.</b></p>
<p>This service is called internally whenever a synchronization object is not claimed anymore by sleepers to reset the object owner's priority to its initial level.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owner</em>&nbsp;</td><td>The descriptor address of the thread which currently owns the synchronization object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine must be entered nklock locked, interrupts off. </dd></dl>

<p>References <a class="el" href="group__nucleus__state__flags.html#gaca3bcd5615c7331c73c3eadddb3d1b89">XNBOOST</a>, and <a class="el" href="group__nucleus__state__flags.html#gaa5b9ff889ab0bfbfb96a435cbea25d6a">XNZOMBIE</a>.</p>

<p>Referenced by <a class="el" href="group__synch.html#ga82beb68147bc5f0306ab02a61a9dc76b">xnsynch_flush()</a>, and <a class="el" href="group__synch.html#ga997e546948920193bb36ab8d120fbab7">xnsynch_forget_sleeper()</a>.</p>

</div>
</div>
<a class="anchor" id="ga82beb68147bc5f0306ab02a61a9dc76b"></a><!-- doxytag: member="synch.c::xnsynch_flush" ref="ga82beb68147bc5f0306ab02a61a9dc76b" args="(struct xnsynch *synch, xnflags_t reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnsynch_flush </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>reason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unblock all waiters pending on a resource. </p>
<p>This service atomically releases all threads which currently sleep on a given resource.</p>
<p>This service should be called by upper interfaces under circumstances requiring that the pending queue of a given resource is cleared, such as before the resource is deleted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object to be flushed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reason</em>&nbsp;</td><td>Some flags to set in the information mask of every unblocked thread. Zero is an acceptable value. The following bits are pre-defined by the nucleus:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNRMID should be set to indicate that the synchronization object is about to be destroyed (see <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812" title="Resume a thread.">xnpod_resume_thread()</a>).</li>
</ul>
<ul>
<li>XNBREAK should be set to indicate that the wait has been forcibly interrupted (see <a class="el" href="group__pod.html#gae5f0d19e7a499b9b262f68a43ab545dd" title="Unblock a thread.">xnpod_unblock_thread()</a>).</li>
</ul>
<dl class="return"><dt><b>Returns:</b></dt><dd>XNSYNCH_RESCHED is returned if at least one thread is unblocked, which means the caller should invoke <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962" title="Rescheduling procedure entry point.">xnpod_schedule()</a> for applying the new scheduling state. Otherwise, XNSYNCH_DONE is returned.</dd></dl>
<p>Side-effects:</p>
<ul>
<li>The effective priority of the previous resource owner might be lowered to its base priority value as a consequence of the priority inheritance boost being cleared.</li>
</ul>
<ul>
<li>The synchronization object is no more owned by any thread.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812">xnpod_resume_thread()</a>, and <a class="el" href="group__synch.html#ga268adcf6898492eb6ff82445899d4bc8">xnsynch_clear_boost()</a>.</p>

<p>Referenced by <a class="el" href="group__posix__cond.html#gaabb82be87ab0b0a96fc68d4a83c2f343">pthread_cond_broadcast()</a>, <a class="el" href="group__posix__thread.html#ga7c275c509c26566b6dd95a2de1668a2f">pthread_detach()</a>, <a class="el" href="group__buffer.html#gaf78c43664dda8a17c5c63ad4be2da179">rt_buffer_clear()</a>, <a class="el" href="group__cond.html#ga37c6424e266f5c1df3439116dd429878">rt_cond_broadcast()</a>, <a class="el" href="group__semaphore.html#ga4a8963240e68d164a2e5bb148da44fbc">rt_sem_broadcast()</a>, <a class="el" href="group__task.html#ga99a89c21c9866e2784860e100a444b49">rt_task_send()</a>, <a class="el" href="group__rtdmsync.html#ga1217402b82034b26fe25c26f1e5b32c9">rtdm_event_signal()</a>, and <a class="el" href="group__registry.html#ga632c1545496b004eecb7ce8d41b3aabd">xnregistry_put()</a>.</p>

</div>
</div>
<a class="anchor" id="ga997e546948920193bb36ab8d120fbab7"></a><!-- doxytag: member="synch.c::xnsynch_forget_sleeper" ref="ga997e546948920193bb36ab8d120fbab7" args="(struct xnthread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_forget_sleeper </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&nbsp;</td>
          <td class="paramname"> <em>thread</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abort a wait for a resource. </p>
<p><b>For internal use only.</b></p>
<p>Performs all the necessary housekeeping chores to stop a thread from waiting on a given synchronization object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread.</td></tr>
  </table>
  </dd>
</dl>
<p>When the trace support is enabled (i.e. MVM), the idle state is posted to the synchronization object's state diagram (if any) whenever no thread remains blocked on it. The real-time interfaces must ensure that such condition (i.e. EMPTY/IDLE) is mapped to state #0.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine must be entered nklock locked, interrupts off. </dd></dl>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, and <a class="el" href="group__synch.html#ga268adcf6898492eb6ff82445899d4bc8">xnsynch_clear_boost()</a>.</p>

<p>Referenced by <a class="el" href="group__pod.html#gad2b761fb70cad30339f092edb4a89587">xnpod_delete_thread()</a>, <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812">xnpod_resume_thread()</a>, and <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4c07b8ec87b14cf18ef512f0e0aade51"></a><!-- doxytag: member="synch.c::xnsynch_init" ref="ga4c07b8ec87b14cf18ef512f0e0aade51" args="(struct xnsynch *synch, xnflags_t flags, xnarch_atomic_t *fastlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_init </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnarch_atomic_t *&nbsp;</td>
          <td class="paramname"> <em>fastlock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a synchronization object. </p>
<p>Initializes a new specialized object which can subsequently be used to synchronize real-time activities. The Xenomai nucleus provides a basic synchronization object which can be used to build higher resource objects. Nucleus threads can wait for and signal such objects in order to synchronize their activities.</p>
<p>This object has built-in support for priority inheritance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The address of a synchronization object descriptor the nucleus will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A set of creation flags affecting the operation. The valid flags are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNSYNCH_PRIO causes the threads waiting for the resource to pend in priority order. Otherwise, FIFO ordering is used (XNSYNCH_FIFO).</li>
</ul>
<ul>
<li>XNSYNCH_OWNER indicates that the synchronization object shall track its owning thread (required if XNSYNCH_PIP is selected). Note that setting this flag implies the use xnsynch_acquire and xnsynch_release instead of xnsynch_sleep_on and xnsynch_wakeup_one_sleeper/xnsynch_wakeup_this_sleeper.</li>
</ul>
<ul>
<li>XNSYNCH_PIP causes the priority inheritance mechanism to be automatically activated when a priority inversion is detected among threads using this object. Otherwise, no priority inheritance takes place upon priority inversion (XNSYNCH_NOPIP).</li>
</ul>
<ul>
<li>XNSYNCH_DREORD (Disable REORDering) tells the nucleus that the wait queue should not be reordered whenever the priority of a blocked thread it holds is changed. If this flag is not specified, changing the priority of a blocked thread using <a class="el" href="group__pod.html#ga6d535ef9821e98fd7f257b50a3c8d595" title="Change the base scheduling parameters of a thread.">xnpod_set_thread_schedparam()</a> will cause this object's wait queue to be reordered according to the new priority level, provided the synchronization object makes the waiters wait by priority order on the awaited resource (XNSYNCH_PRIO).</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fastlock</em>&nbsp;</td><td>Address of the fast lock word to be associated with the synchronization object. If NULL is passed or XNSYNCH_OWNER is not set, fast-lock support is disabled.</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>Referenced by <a class="el" href="group__posix__cond.html#gab99651c9045ffa16d75c3a4d1dfee0c4">pthread_cond_init()</a>, <a class="el" href="group__posix__thread.html#gae6e819ed048e4c4a4ee96fa6f426852c">pthread_create()</a>, <a class="el" href="group__posix__intr.html#gaf3a9c7f6f99728f07d14a64518033acb">pthread_intr_attach_np()</a>, <a class="el" href="group__alarm.html#ga22353f79379121bbebfa0e72bbde5028">rt_alarm_create()</a>, <a class="el" href="group__buffer.html#ga7aa6a3b48ba6b6ecdd7f2ad9152d2a61">rt_buffer_create()</a>, <a class="el" href="group__cond.html#ga04646a121e57765848eb2a51ed6be855">rt_cond_create()</a>, <a class="el" href="group__event.html#ga8b0fbb2b816c62081afe86bf897c503c">rt_event_create()</a>, <a class="el" href="group__native__heap.html#ga1d19ad24dc9f94b969aa0f574170bdc4">rt_heap_create()</a>, <a class="el" href="group__interrupt.html#gaa0a9d98556ec838008f408a56e79d304">rt_intr_create()</a>, <a class="el" href="group__native__queue.html#gaacad717bbd6d75338fada8f5b4a67b3f">rt_queue_create()</a>, <a class="el" href="group__semaphore.html#gaba36e3ac8972ea74feb60640e58d1ceb">rt_sem_create()</a>, <a class="el" href="group__task.html#ga03387550693c21d0223f739570ccd992">rt_task_create()</a>, <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19">rtdm_event_init()</a>, <a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5">rtdm_mutex_init()</a>, <a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d">rtdm_sem_init()</a>, <a class="el" href="group__registry.html#ga28aefd9be7367aa495753142005e1d5a">xnregistry_enter()</a>, and <a class="el" href="group__select.html#gaf5576af13d5ffd6056311c2746a706a0">xnselector_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gae02c775ea161a0c27b919d019d170bc2"></a><!-- doxytag: member="synch.c::xnsynch_peek_pendq" ref="gae02c775ea161a0c27b919d019d170bc2" args="(struct xnsynch *synch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnthread* xnsynch_peek_pendq </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&nbsp;</td>
          <td class="paramname"> <em>synch</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access the thread leading a synch object wait queue. </p>
<p>This services returns the descriptor address of to the thread leading a synchronization object wait queue.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the target synchronization object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The descriptor address of the unblocked thread.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga1208abb6b3d0017a4e0c43b9baff8cfb"></a><!-- doxytag: member="synch.c::xnsynch_release" ref="ga1208abb6b3d0017a4e0c43b9baff8cfb" args="(struct xnsynch *synch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnthread* xnsynch_release </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&nbsp;</td>
          <td class="paramname"> <em>synch</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give the resource ownership to the next waiting thread. </p>
<p>This service releases the ownership of the given synchronization object. The thread which is currently leading the object's pending list, if any, is unblocked from its pending state. However, no reschedule is performed.</p>
<p>This service must be used only with synchronization objects that track ownership (XNSYNCH_OWNER set).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object whose ownership is changed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The descriptor address of the unblocked thread.</dd></dl>
<p>Side-effects:</p>
<ul>
<li>The effective priority of the previous resource owner might be lowered to its base priority value as a consequence of the priority inheritance boost being cleared.</li>
</ul>
<ul>
<li>The synchronization object ownership is transfered to the unblocked thread.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>Referenced by <a class="el" href="group__posix__mutex.html#gab6fc0b5282dd100530311128e4f5ff19">pthread_mutex_unlock()</a>, and <a class="el" href="group__mutex.html#gac87911b7279f55ef2f5f9aefe36ff070">rt_mutex_release()</a>.</p>

</div>
</div>
<a class="anchor" id="ga51146a2d5bd0ec6a10d2fcd685946938"></a><!-- doxytag: member="synch.c::xnsynch_release_all_ownerships" ref="ga51146a2d5bd0ec6a10d2fcd685946938" args="(struct xnthread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_release_all_ownerships </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&nbsp;</td>
          <td class="paramname"> <em>thread</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release all ownerships. </p>
<p><b>For internal use only.</b></p>
<p>This call is used internally to release all the ownerships obtained by a thread on synchronization objects. This routine must be entered interrupts off.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine must be entered nklock locked, interrupts off. </dd></dl>

<p>Referenced by <a class="el" href="group__pod.html#gad2b761fb70cad30339f092edb4a89587">xnpod_delete_thread()</a>.</p>

</div>
</div>
<a class="anchor" id="ga49c975f160509b1aa04df4900614b2ce"></a><!-- doxytag: member="synch.c::xnsynch_requeue_sleeper" ref="ga49c975f160509b1aa04df4900614b2ce" args="(struct xnthread *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_requeue_sleeper </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&nbsp;</td>
          <td class="paramname"> <em>thread</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Change a sleeper's priority. </p>
<p><b>For internal use only.</b></p>
<p>This service is used by the PIP code to update the pending priority of a sleeping thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine must be entered nklock locked, interrupts off. </dd></dl>

<p>References <a class="el" href="group__nucleus__state__flags.html#gaca3bcd5615c7331c73c3eadddb3d1b89">XNBOOST</a>.</p>

</div>
</div>
<a class="anchor" id="ga2747e9834546af461f118e7c90c9613e"></a><!-- doxytag: member="synch.c::xnsynch_sleep_on" ref="ga2747e9834546af461f118e7c90c9613e" args="(struct xnsynch *synch, xnticks_t timeout, xntmode_t timeout_mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnflags_t xnsynch_sleep_on </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntmode_t&nbsp;</td>
          <td class="paramname"> <em>timeout_mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sleep on an ownerless synchronization object. </p>
<p>Makes the calling thread sleep on the specified synchronization object, waiting for it to be signaled.</p>
<p>This service should be called by upper interfaces wanting the current thread to pend on the given resource. It must not be used with synchronization objects that are supposed to track ownership (XNSYNCH_OWNER).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object to sleep on.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout which may be used to limit the time the thread pends on the resource. This value is a wait time given in ticks (see note). It can either be relative, absolute monotonic, or absolute adjustable depending on <em>timeout_mode</em>. Passing XN_INFINITE <b>and</b> setting <em>mode</em> to XN_RELATIVE specifies an unbounded wait. All other values are used to initialize a watchdog timer.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout_mode</em>&nbsp;</td><td>The mode of the <em>timeout</em> parameter. It can either be set to XN_RELATIVE, XN_ABSOLUTE, or XN_REALTIME (see also <a class="el" href="group__timer.html#ga0ad3c70bed7fe1a45b45ee0875f031ab" title="Arm a timer.">xntimer_start()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A bitmask which may include zero or one information bit among XNRMID, XNTIMEO and XNBREAK, which should be tested by the caller, for detecting respectively: object deletion, timeout or signal/unblock conditions which might have happened while waiting.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: always.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <em>timeout</em> value will be interpreted as jiffies if the current thread is bound to a periodic time base (see xnpod_init_thread), or nanoseconds otherwise. </dd></dl>

<p>References <a class="el" href="group__nucleus__info__flags.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__nucleus__state__flags.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, <a class="el" href="group__pod.html#ga767221cf87c198c5dc071e9f597dcb3a">xnpod_suspend_thread()</a>, <a class="el" href="group__nucleus__info__flags.html#gab07d9dea73645dbba353dc2452c15b40">XNRMID</a>, and <a class="el" href="group__nucleus__info__flags.html#gaa11d7fc754db50d3a1f1e41611d324e9">XNTIMEO</a>.</p>

<p>Referenced by <a class="el" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6">pthread_join()</a>, <a class="el" href="group__native__heap.html#ga52678149ff2b66e47aa8cdcddab653a4">rt_heap_alloc()</a>, <a class="el" href="group__task.html#gaa152f8f41876fc3a828a8eba74d493fe">rt_task_receive()</a>, <a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait()</a>, <a class="el" href="group__rtdmsync.html#ga8aadb120a93df5dfd717c5bac6d4c1a9">rtdm_sem_timeddown()</a>, <a class="el" href="group__registry.html#ga03ceaaa3cb5799a6b706dc9a65f493e5">xnregistry_bind()</a>, <a class="el" href="group__registry.html#ga7e98a4706164f3ff2c82dc064cf3231e">xnregistry_remove_safe()</a>, and <a class="el" href="group__select.html#ga4af23e0a42dbc61a04be36d5739a165f">xnselect()</a>.</p>

</div>
</div>
<a class="anchor" id="gad5992ddbdb81821cb29bae8900eb65ac"></a><!-- doxytag: member="synch.c::xnsynch_wakeup_one_sleeper" ref="gad5992ddbdb81821cb29bae8900eb65ac" args="(struct xnsynch *synch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnthread* xnsynch_wakeup_one_sleeper </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&nbsp;</td>
          <td class="paramname"> <em>synch</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give the resource ownership to the next waiting thread. </p>
<p>This service wakes up the thread which is currently leading the synchronization object's pending list. The sleeping thread is unblocked from its pending state, but no reschedule is performed.</p>
<p>This service should be called by upper interfaces wanting to signal the given resource so that a single waiter is resumed. It must not be used with synchronization objects that are supposed to track ownership (XNSYNCH_OWNER not set).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object whose ownership is changed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The descriptor address of the unblocked thread.</dd></dl>
<p>Side-effects:</p>
<ul>
<li>The effective priority of the previous resource owner might be lowered to its base priority value as a consequence of the priority inheritance boost being cleared.</li>
</ul>
<ul>
<li>The synchronization object ownership is transfered to the unblocked thread.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, and <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812">xnpod_resume_thread()</a>.</p>

<p>Referenced by <a class="el" href="group__posix__cond.html#ga691c7dd41acc6a4f25561a13158b0933">pthread_cond_signal()</a>, <a class="el" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6">pthread_join()</a>, <a class="el" href="group__cond.html#gab7a59ee47db48a78ca45e4655b569dc9">rt_cond_signal()</a>, <a class="el" href="group__native__queue.html#ga8b1dcb15753bdfce02f25f166e18948d">rt_queue_send()</a>, <a class="el" href="group__semaphore.html#gaa5a7927862a511a27741223e08e48270">rt_sem_v()</a>, <a class="el" href="group__rtdmsync.html#ga829dbd8c5709d798ed06947b27001fed">rtdm_sem_up()</a>, and <a class="el" href="group__posix__sem.html#ga3ceb2577b76aaad3be6fd83e959c66e3">sem_post()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e530d12df9881251231af489208762e"></a><!-- doxytag: member="synch.c::xnsynch_wakeup_this_sleeper" ref="ga9e530d12df9881251231af489208762e" args="(struct xnsynch *synch, struct xnpholder *holder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnpholder* xnsynch_wakeup_this_sleeper </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&nbsp;</td>
          <td class="paramname"> <em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnpholder *&nbsp;</td>
          <td class="paramname"> <em>holder</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give the resource ownership to a given waiting thread. </p>
<p>This service wakes up a specific thread which is currently pending on the given synchronization object. The sleeping thread is unblocked from its pending state, but no reschedule is performed.</p>
<p>This service should be called by upper interfaces wanting to signal the given resource so that a specific waiter is resumed. It must not be used with synchronization objects that are supposed to track ownership (XNSYNCH_OWNER not set).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>synch</em>&nbsp;</td><td>The descriptor address of the synchronization object whose ownership is changed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>holder</em>&nbsp;</td><td>The link holder address of the thread to unblock (&amp;thread-&gt;plink) which MUST be currently linked to the synchronization object's pending queue (i.e. synch-&gt;pendq).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The link address of the unblocked thread in the synchronization object's pending queue.</dd></dl>
<p>Side-effects:</p>
<ul>
<li>The effective priority of the previous resource owner might be lowered to its base priority value as a consequence of the priority inheritance boost being cleared.</li>
</ul>
<ul>
<li>The synchronization object ownership is transfered to the unblocked thread.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, and <a class="el" href="group__pod.html#gac3a7bf9e973782a8cfd6495a1786e812">xnpod_resume_thread()</a>.</p>

<p>Referenced by <a class="el" href="group__event.html#gafda4c544f2429005c4b15de3a7ffc902">rt_event_signal()</a>, and <a class="el" href="group__native__heap.html#ga300ca8c868d02dad99790fe39b443f6f">rt_heap_free()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jan 23 2013 13:24:04 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
