<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: Interrupt management.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Interrupt management.<br>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>]</small>
</h1>
<p>
Collaboration diagram for Interrupt management.:<center><table><tr><td><img src="group__intr.png" border="0" alt="" usemap="#group____intr_map">
<map name="group____intr_map">
<area href="group__nucleus.html" shape="rect" coords="9,8,137,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Interrupt management. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="nucleus_2intr_8c.html">intr.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupt management. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#ga11">xnintr_init</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize an interrupt object.  <a href="#ga11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#ga12">xnintr_destroy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy an interrupt object.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#ga13">xnintr_attach</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attach an interrupt object.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#ga14">xnintr_detach</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach an interrupt object.  <a href="#ga14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#ga15">xnintr_enable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable an interrupt object.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#ga16">xnintr_disable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable an interrupt object.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__intr.html#ga17">xnintr_affinity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set interrupt's processor affinity.  <a href="#ga17"></a><br></td></tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="ga17" doxytag="intr.c::xnintr_affinity"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">xnarch_cpumask_t xnintr_affinity          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set interrupt's processor affinity. 
<p>
Causes the IRQ associated with the interrupt object <em>intr</em> to be received only on processors which bits are set in <em>cpumask</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object which affinity is to be changed.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpumask</em>&nbsp;</td><td>The new processor affinity of the interrupt object.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the previous cpumask on success, or an empty mask on failure.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Depending on architectures, setting more than one bit in <em>cpumask</em> could be meaningless. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="intr.c::xnintr_attach"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int xnintr_attach          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Attach an interrupt object. 
<p>
Attach an interrupt object previously initialized by <a class="el" href="group__intr.html#ga11">xnintr_init()</a>. After this operation is completed, all IRQs received from the corresponding interrupt channel are directed to the object's ISR.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to attach.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque value which is stored into the interrupt object descriptor for further retrieval by the ISR/ISR handlers.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if a low-level error occurred while attaching the interrupt. -EBUSY is specifically returned if the interrupt object was already attached.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.<p>
<dl compact><dt><b>Note:</b></dt><dd>Attaching an interrupt resets the tracked number of receipts to zero. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="intr.c::xnintr_destroy"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int xnintr_destroy          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy an interrupt object. 
<p>
Destroys an interrupt object previously initialized by <a class="el" href="group__intr.html#ga11">xnintr_init()</a>. The interrupt object is automatically detached by a call to <a class="el" href="group__intr.html#ga14">xnintr_detach()</a>. No more IRQs will be dispatched by this object after this service has returned.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to destroy.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, -EBUSY is returned if an error occurred while detaching the interrupt (see <a class="el" href="group__intr.html#ga14">xnintr_detach()</a>).</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga14" doxytag="intr.c::xnintr_detach"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int xnintr_detach          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Detach an interrupt object. 
<p>
Detach an interrupt object previously attached by <a class="el" href="group__intr.html#ga13">xnintr_attach()</a>. After this operation is completed, no more IRQs are directed to the object's ISR, but the interrupt object itself remains valid. A detached interrupt object can be attached again by a subsequent call to <a class="el" href="group__intr.html#ga13">xnintr_attach()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to detach.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if a low-level error occurred while detaching the interrupt. Detaching a non-attached interrupt object leads to a null-effect and returns 0.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="intr.c::xnintr_disable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int xnintr_disable          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disable an interrupt object. 
<p>
Disables the hardware interrupt line associated with an interrupt object. This operation invalidates further interrupt requests from the given source until the IRQ line is re-enabled anew.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to disable.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if a low-level error occurred while disabling the interrupt.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="intr.c::xnintr_enable"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int xnintr_enable          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable an interrupt object. 
<p>
Enables the hardware interrupt line associated with an interrupt object. Over real-time control layers which mask and acknowledge IRQs, this operation is necessary to revalidate the interrupt channel so that more interrupts can be notified.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object to enable.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if a low-level error occurred while enabling the interrupt.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="intr.c::xnintr_init"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int xnintr_init          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize an interrupt object. 
<p>
Associates an interrupt object with an IRQ line.<p>
When an interrupt occurs on the given <em>irq</em> line, the ISR is fired in order to deal with the hardware event. The interrupt service code may call any non-suspensive service from the nucleus.<p>
Upon receipt of an IRQ, the ISR is immediately called on behalf of the interrupted stack context, the rescheduling procedure is locked, and the interrupt source is masked at hardware level. The status value returned by the ISR is then checked for the following bits:<p>
<ul>
<li>XN_ISR_ENABLE asks the nucleus to re-enable the IRQ line. Over some real-time control layers which mask and acknowledge IRQs, this operation is necessary to revalidate the interrupt channel so that more interrupts can be notified. The presence of such bit in the ISR's return code causes the nucleus to ask the real-time control layer to re-enable the interrupt.</li></ul>
<p>
<ul>
<li>XN_ISR_CHAINED tells the nucleus to require the real-time control layer to forward the IRQ. For instance, this would cause the Adeos control layer to propagate the interrupt down the interrupt pipeline to other Adeos domains, such as Linux. This is the regular way to share interrupts between the nucleus and the host system. At the opposite, RT_INTR_HANDLED can be used instead to indicate that the interrupt request has been fulfilled.</li></ul>
<p>
A count of interrupt receipts is tracked into the interrupt descriptor, and reset to zero each time the interrupt object is attached. Since this count could wrap around, it should be used as an indication of interrupt activity only.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The address of a interrupt object descriptor the nucleus will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>irq</em>&nbsp;</td><td>The hardware interrupt channel associated with the interrupt object. This value is architecture-dependent. An interrupt object must then be attached to the hardware interrupt vector using the <a class="el" href="group__intr.html#ga13">xnintr_attach()</a> service for the associated IRQs to be directed to this object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isr</em>&nbsp;</td><td>The address of a valid low-level interrupt service routine if this parameter is non-zero. This handler will be called each time the corresponding IRQ is delivered on behalf of an interrupt context. When called, the ISR is passed the descriptor address of the interrupt object.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iack</em>&nbsp;</td><td>The address of an optional interrupt acknowledge routine, aimed at replacing the default one. Only very specific situations actually require to override the default setting for this parameter, like having to acknowledge non-standard PIC hardware. <em>iack</em> should return a non-zero value to indicate that the interrupt has been properly acknowledged. If <em>iack</em> is NULL, the default routine will be used instead.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A set of creation flags affecting the operation. Since no flags are currently defined, zero should be passed for this parameter.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>No error condition being defined, 0 is always returned.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never.     </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Mar 16 19:28:31 2006 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
