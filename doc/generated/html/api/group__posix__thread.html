<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: Threads management services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Threads management services.<br/>
<small>
[<a class="el" href="group__posix.html">POSIX skin.</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Threads management services.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Threads management services.:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__posix__thread.png" border="0" alt="" usemap="#group____posix____thread"/>
<map name="group____posix____thread" id="group____posix____thread">
<area shape="rect" id="node3" href="group__posix__cancel.html" title="Thread cancellation." alt="" coords="449,5,599,35"/><area shape="rect" id="node4" href="group__posix__sched.html" title="Thread scheduling services." alt="" coords="421,59,627,88"/><area shape="rect" id="node5" href="group__posix__threadattr.html" title="Thread creation attributes." alt="" coords="428,112,620,141"/><area shape="rect" id="node2" href="group__posix.html" title="Xenomai POSIX skin is an implementation of a small subset of the Single Unix specification over Xenom..." alt="" coords="7,59,100,88"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__cancel.html">Thread cancellation.</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Thread cancellation. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__sched.html">Threads scheduling services.</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Thread scheduling services. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__threadattr.html">Thread creation attributes.</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Thread creation attributes. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#gafb4c3f58a873bfe7f44aa37919437320">pthread_once</a> (pthread_once_t *once, void(*init_routine)(void))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute an initialization routine.  <a href="#gafb4c3f58a873bfe7f44aa37919437320"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#gae6e819ed048e4c4a4ee96fa6f426852c">pthread_create</a> (pthread_t *tid, const pthread_attr_t *attr, void *(*start)(void *), void *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a thread.  <a href="#gae6e819ed048e4c4a4ee96fa6f426852c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga7c275c509c26566b6dd95a2de1668a2f">pthread_detach</a> (pthread_t thread)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detach a running thread.  <a href="#ga7c275c509c26566b6dd95a2de1668a2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga98ec817164a6641eda2341de473b659d">pthread_equal</a> (pthread_t t1, pthread_t t2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare thread identifiers.  <a href="#ga98ec817164a6641eda2341de473b659d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga090bdc13141e76205fab4cb3c5fab0e4">pthread_exit</a> (void *value_ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Terminate the current thread.  <a href="#ga090bdc13141e76205fab4cb3c5fab0e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6">pthread_join</a> (pthread_t thread, void **value_ptr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for termination of a specified thread.  <a href="#gaa79c99cc7b194918a2def257246f11c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pthread_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga4c4f5f3b4f8f45d9d897847d53b11aaa">pthread_self</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the identifier of the calling thread.  <a href="#ga4c4f5f3b4f8f45d9d897847d53b11aaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#gafe8deaa3c89e0a07e59f0e58f9ec1473">pthread_make_periodic_np</a> (pthread_t thread, struct timespec *starttp, struct timespec *periodtp)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a thread periodic.  <a href="#gafe8deaa3c89e0a07e59f0e58f9ec1473"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga1f18e6e7dd5342463ca8546ef3a36c34">pthread_wait_np</a> (unsigned long *overruns_r)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for current thread next period.  <a href="#ga1f18e6e7dd5342463ca8546ef3a36c34"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga9dd3db5524fccb05a8868b7c33ccaa79">pthread_set_mode_np</a> (int clrmask, int setmask)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the mode of the current thread.  <a href="#ga9dd3db5524fccb05a8868b7c33ccaa79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__thread.html#ga414a759c928f7be7ac105980d8e73431">pthread_set_name_np</a> (pthread_t thread, const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a thread name.  <a href="#ga414a759c928f7be7ac105980d8e73431"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Threads management services. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_09.html#tag_02_09">Specification.</a> </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae6e819ed048e4c4a4ee96fa6f426852c"></a><!-- doxytag: member="thread.c::pthread_create" ref="gae6e819ed048e4c4a4ee96fa6f426852c" args="(pthread_t *tid, const pthread_attr_t *attr, void *(*start)(void *), void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_create </td>
          <td>(</td>
          <td class="paramtype">pthread_t *&nbsp;</td>
          <td class="paramname"> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pthread_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a thread. </p>
<p>This service create a thread. The created thread may be used with all POSIX skin services.</p>
<p>The new thread run the <em>start</em> routine, with the <em>arg</em> argument.</p>
<p>The new thread signal mask is inherited from the current thread, if it was also created with <a class="el" href="group__posix__thread.html#gae6e819ed048e4c4a4ee96fa6f426852c" title="Create a thread.">pthread_create()</a>, otherwise the new thread signal mask is empty.</p>
<p>Other attributes of the new thread depend on the <em>attr</em> argument. If <em>attr</em> is null, default values for these attributes are used. See <a class="el" href="group__posix__threadattr.html">Thread creation attributes.</a> for a definition of thread creation attributes and their default values.</p>
<p>Returning from the <em>start</em> routine has the same effect as calling <a class="el" href="group__posix__thread.html#ga090bdc13141e76205fab4cb3c5fab0e4" title="Terminate the current thread.">pthread_exit()</a> with the return value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>address where the identifier of the new thread will be stored on success;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>thread attributes;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>thread routine;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td>thread routine argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>EINVAL, <em>attr</em> is invalid;</li>
<li>EAGAIN, insufficient memory exists in the system heap to create a new thread, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li>
<li>EINVAL, thread attribute <em>inheritsched</em> is set to PTHREAD_INHERIT_SCHED and the calling thread does not belong to the POSIX skin;</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_create.html">Specification.</a></dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>When creating or shadowing a Xenomai thread for the first time in user-space, Xenomai installs a handler for the SIGWINCH signal. If you had installed a handler before that, it will be automatically called by Xenomai for SIGWINCH signals that it has not sent.</p>
<p>If, however, you install a signal handler for SIGWINCH after creating or shadowing the first Xenomai thread, you have to explicitly call the function xeno_sigwinch_handler at the beginning of your signal handler, using its return to know if the signal was in fact an internal signal of Xenomai (in which case it returns 1), or if you should handle the signal (in which case it returns 0). xeno_sigwinch_handler prototype is:</p>
<p><b>int xeno_sigwinch_handler(int sig, siginfo_t *si, void *ctxt);</b></p>
<p>Which means that you should register your handler with sigaction, using the SA_SIGINFO flag, and pass all the arguments you received to xeno_sigwinch_handler. </p>

<p>References <a class="el" href="group__posix__sched.html#ga1af835697c5e55a2e538ea10926d11d4">pthread_getschedparam_ex()</a>, <a class="el" href="group__pod.html#gad71ebccc5b7b3d367f65127a8849c036">xnpod_init_thread()</a>, <a class="el" href="group__pod.html#ga4b8647e7a6969962c788669ff8d46d3b">xnpod_set_thread_tslice()</a>, <a class="el" href="group__pod.html#gad322f6afd62430705486a9036d0b7d66">xnpod_start_thread()</a>, and <a class="el" href="group__synch.html#ga4c07b8ec87b14cf18ef512f0e0aade51">xnsynch_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c275c509c26566b6dd95a2de1668a2f"></a><!-- doxytag: member="thread.c::pthread_detach" ref="ga7c275c509c26566b6dd95a2de1668a2f" args="(pthread_t thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_detach </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detach a running thread. </p>
<p>This service detaches a joinable thread. A detached thread is a thread which control block is automatically reclaimed when it terminates. The control block of a joinable thread, on the other hand, is only reclaimed when joined with the service <a class="el" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join()</a>.</p>
<p>If some threads are currently blocked in the <a class="el" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join()</a> service with <em>thread</em> as a target, they are unblocked and <a class="el" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join()</a> returns EINVAL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>target thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is an invalid thread identifier;</li>
<li>EINVAL, <em>thread</em> is not joinable.</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_detach.html">Specification.</a> </dd></dl>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, and <a class="el" href="group__synch.html#ga82beb68147bc5f0306ab02a61a9dc76b">xnsynch_flush()</a>.</p>

</div>
</div>
<a class="anchor" id="ga98ec817164a6641eda2341de473b659d"></a><!-- doxytag: member="thread.c::pthread_equal" ref="ga98ec817164a6641eda2341de473b659d" args="(pthread_t t1, pthread_t t2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_equal </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare thread identifiers. </p>
<p>This service compare the thread identifiers <em>t1</em> and <em>t2</em>. No attempt is made to check the threads for existence. In order to check if a thread exists, the <a class="el" href="group__posix__signal.html#ga5aafacc071cdfafd0eb992004dee3e62" title="Send a signal to a thread.">pthread_kill()</a> service should be used with the signal number 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>thread identifier;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>other thread identifier.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a non zero value if the thread identifiers are equal; </dd>
<dd>
0 otherwise.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_equal.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga090bdc13141e76205fab4cb3c5fab0e4"></a><!-- doxytag: member="thread.c::pthread_exit" ref="ga090bdc13141e76205fab4cb3c5fab0e4" args="(void *value_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pthread_exit </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value_ptr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Terminate the current thread. </p>
<p>This service terminate the current thread with the return value <em>value_ptr</em>. If the current thread is joinable, the return value is returned to any thread joining the current thread with the <a class="el" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join()</a> service.</p>
<p>When a thread terminates, cancellation cleanup handlers are executed in the reverse order that they were pushed. Then, thread-specific data destructors are executed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value_ptr</em>&nbsp;</td><td>thread return value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_exit.html">Specification.</a> </dd></dl>

<p>Referenced by <a class="el" href="group__task.html#gab6e0d411830710e8cc82d77b9df19510">rt_task_delete()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa79c99cc7b194918a2def257246f11c6"></a><!-- doxytag: member="thread.c::pthread_join" ref="gaa79c99cc7b194918a2def257246f11c6" args="(pthread_t thread, void **value_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_join </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>value_ptr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for termination of a specified thread. </p>
<p>If the thread <em>thread</em> is running and joinable, this service blocks the calling thread until the thread <em>thread</em> terminates or detaches. In this case, the calling context must be a blockable context (i.e. a Xenomai thread without the scheduler locked) or the root thread (i.e. a module initilization or cleanup routine). When <em>thread</em> terminates, the calling thread is unblocked and its return value is stored at* the address <em>value_ptr</em>.</p>
<p>If, on the other hand, the thread <em>thread</em> has already finished execution, its return value is stored at the address <em>value_ptr</em> and this service returns immediately. In this case, this service may be called from any context.</p>
<p>This service is a cancelation point for POSIX skin threads: if the calling thread is canceled while blocked in a call to this service, the cancelation request is honored and <em>thread</em> remains joinable.</p>
<p>Multiple simultaneous calls to <a class="el" href="group__posix__thread.html#gaa79c99cc7b194918a2def257246f11c6" title="Wait for termination of a specified thread.">pthread_join()</a> specifying the same running target thread block all the callers until the target thread terminates.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>identifier of the thread to wait for;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value_ptr</em>&nbsp;</td><td>address where the target thread return value will be stored on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li>
<li>EDEADLK, attempting to join the calling thread;</li>
<li>EINVAL, <em>thread</em> is detached;</li>
<li>EPERM, the caller context is invalid.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Valid contexts, if this service has to block its caller:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li>
<li>kernel module initilization or cleanup routine;</li>
<li>Xenomai user-space thread (switches to primary mode).</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_join.html">Specification.</a> </dd></dl>

<p>References <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, <a class="el" href="group__synch.html#ga2747e9834546af461f118e7c90c9613e">xnsynch_sleep_on()</a>, and <a class="el" href="group__synch.html#gad5992ddbdb81821cb29bae8900eb65ac">xnsynch_wakeup_one_sleeper()</a>.</p>

<p>Referenced by <a class="el" href="group__task.html#ga03387550693c21d0223f739570ccd992">rt_task_create()</a>, and <a class="el" href="group__task.html#ga8c77d57638578a126812e29429f61fe7">rt_task_join()</a>.</p>

</div>
</div>
<a class="anchor" id="gafe8deaa3c89e0a07e59f0e58f9ec1473"></a><!-- doxytag: member="thread.c::pthread_make_periodic_np" ref="gafe8deaa3c89e0a07e59f0e58f9ec1473" args="(pthread_t thread, struct timespec *starttp, struct timespec *periodtp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_make_periodic_np </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&nbsp;</td>
          <td class="paramname"> <em>starttp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct timespec *&nbsp;</td>
          <td class="paramname"> <em>periodtp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Make a thread periodic. </p>
<p>This service make the POSIX skin thread <em>thread</em> periodic.</p>
<p>This service is a non-portable extension of the POSIX interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>thread identifier. This thread is immediately delayed until the first periodic release point is reached.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>starttp</em>&nbsp;</td><td>start time, expressed as an absolute value of the CLOCK_REALTIME clock. The affected thread will be delayed until this point is reached.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>periodtp</em>&nbsp;</td><td>period, expressed as a time interval.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid;</li>
<li>ETIMEDOUT, the start time has already passed.</li>
</ul>
</dd></dl>
<p>Rescheduling: always, until the <em>starttp</em> start time has been reached. </p>

<p>References <a class="el" href="group__pod.html#gaed5776a428e7c59b52b1da76f0d765fa">xnpod_set_thread_periodic()</a>.</p>

</div>
</div>
<a class="anchor" id="gafb4c3f58a873bfe7f44aa37919437320"></a><!-- doxytag: member="once.c::pthread_once" ref="gafb4c3f58a873bfe7f44aa37919437320" args="(pthread_once_t *once, void(*init_routine)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_once </td>
          <td>(</td>
          <td class="paramtype">pthread_once_t *&nbsp;</td>
          <td class="paramname"> <em>once</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&nbsp;</td>
          <td class="paramname"> <em>init_routine</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute an initialization routine. </p>
<p>This service may be used by libraries which need an initialization function to be called only once.</p>
<p>The function <em>init_routine</em> will only be called, with no argument, the first time this service is called specifying the address <em>once</em>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>EINVAL, the object pointed to by <em>once</em> is invalid (it must have been initialized with PTHREAD_ONCE_INIT).</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_once.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4c4f5f3b4f8f45d9d897847d53b11aaa"></a><!-- doxytag: member="thread.c::pthread_self" ref="ga4c4f5f3b4f8f45d9d897847d53b11aaa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t pthread_self </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the identifier of the calling thread. </p>
<p>This service returns the identifier of the calling thread.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>identifier of the calling thread; </dd>
<dd>
NULL if the calling thread is not a POSIX skin thread.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/pthread_self.html">Specification.</a> </dd></dl>

<p>Referenced by <a class="el" href="group__posix__sched.html#gad5eceef44b79a09a1a86e7a1950a74e7">pthread_setschedparam_ex()</a>, and <a class="el" href="group__task.html#ga72e0a9355d06c346a95bf88b857a9749">rt_task_shadow()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9dd3db5524fccb05a8868b7c33ccaa79"></a><!-- doxytag: member="thread.c::pthread_set_mode_np" ref="ga9dd3db5524fccb05a8868b7c33ccaa79" args="(int clrmask, int setmask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_set_mode_np </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>setmask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the mode of the current thread. </p>
<p>This service sets the mode of the calling thread. <em>clrmask</em> and <em>setmask</em> are two bit masks which are respectively cleared and set in the calling thread status. They are a bitwise OR of the following values:</p>
<ul>
<li>PTHREAD_LOCK_SCHED, when set, locks the scheduler, which prevents the current thread from being switched out by the scheduler until the scheduler is unlocked;</li>
<li>PTHREAD_RPIOFF, when set, prevents the root Linux thread from inheriting the priority of the calling thread, when this thread is running in secondary mode;</li>
<li>PTHREAD_WARNSW, when set, cause the signal SIGXCPU to be sent to the current thread, whenever it involontary switches to secondary mode;</li>
<li>PTHREAD_PRIMARY, cause the migration of the current thread to primary mode.</li>
</ul>
<p>PTHREAD_LOCK_SCHED is valid for any Xenomai thread, the other bits are only valid for Xenomai user-space threads.</p>
<p>This service is a non-portable extension of the POSIX interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clrmask</em>&nbsp;</td><td>set of bits to be cleared;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>setmask</em>&nbsp;</td><td>set of bits to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>EINVAL, some bit in <em>clrmask</em> or <em>setmask</em> is invalid. </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__nucleus__state__flags.html#ga2defcfb1f04f077baeac9881cbdda627">XNLOCK</a>, <a class="el" href="group__pod.html#gacf5b53f0405351327b89b0cc4976b962">xnpod_schedule()</a>, <a class="el" href="group__pod.html#ga629c06b152dabfdb679b6e49bd9f7734">xnpod_set_thread_mode()</a>, <a class="el" href="group__nucleus__state__flags.html#gac664c3bae93da4141d2fc8e88a91afd8">XNSHADOW</a>, <a class="el" href="group__shadow.html#ga8de86a334ac2c5aeeebccf88fcee03ab">xnshadow_relax()</a>, and <a class="el" href="group__nucleus__state__flags.html#gade2e62645781aa1badafd97659cf3473">XNTRAPSW</a>.</p>

</div>
</div>
<a class="anchor" id="ga414a759c928f7be7ac105980d8e73431"></a><!-- doxytag: member="thread.c::pthread_set_name_np" ref="ga414a759c928f7be7ac105980d8e73431" args="(pthread_t thread, const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_set_name_np </td>
          <td>(</td>
          <td class="paramtype">pthread_t&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a thread name. </p>
<p>This service set to <em>name</em>, the name of <em>thread</em>. This name is used for displaying information in /proc/xenomai/sched.</p>
<p>This service is a non-portable extension of the POSIX interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>target thread;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of the thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>ESRCH, <em>thread</em> is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1f18e6e7dd5342463ca8546ef3a36c34"></a><!-- doxytag: member="thread.c::pthread_wait_np" ref="ga1f18e6e7dd5342463ca8546ef3a36c34" args="(unsigned long *overruns_r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pthread_wait_np </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>overruns_r</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for current thread next period. </p>
<p>If it is periodic, this service blocks the calling thread until the next period elapses.</p>
<p>This service is a cancelation point for POSIX skin threads.</p>
<p>This service is a non-portable extension of the POSIX interface.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overruns_r</em>&nbsp;</td><td>address where the overruns count is returned in case of overrun.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success; </dd>
<dd>
an error number if:<ul>
<li>EPERM, the calling context is invalid;</li>
<li>EWOULDBLOCK, the calling thread is not periodic;</li>
<li>EINTR, this service was interrupted by a signal;</li>
<li>ETIMEDOUT, at least one overrun occurred.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Valid contexts:</b></dt><dd><ul>
<li>Xenomai kernel-space thread;</li>
<li>Xenomai user-space thread (switches to primary mode). </li>
</ul>
</dd></dl>

<p>References <a class="el" href="group__pod.html#gaf836996e4a3378928f2a9f93a4915cfa">xnpod_wait_thread_period()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jan 23 2013 13:24:05 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
