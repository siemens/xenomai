<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Xenomai API: Buffer management services</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Buffer management services<br>
<small>
[<a class="el" href="group__driverfacilities.html">Driver API.</a>]</small>
</h1>
<p>
<div class="dynheader">
Collaboration diagram for Buffer management services:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__analogy__buffer.png" border="0" alt="" usemap="#group____analogy____buffer_map">
<map name="group____analogy____buffer_map">
<area shape="rect" href="group__driverfacilities.html" title="Driver API." alt="" coords="5,5,93,32"></map></td></tr></table></center>
</div>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Buffer management services<p>
The buffer is the key component of the Analogy infrastructure. It manages transfers between the user-space and the Analogy drivers thanks to generic functions which are described hereafter. Thanks to the buffer subsystem, the driver developer does not have to care about the way the user program retrieves or sends data.<p>
To write a classical char driver, the developer has to fill a fops structure so as to provide transfer operations to the user program (read, write, ioctl and mmap if need be).<p>
The Analogy infrastructure manages the whole interface with the userspace; the common read, write, mmap, etc. callbacks are generic Analogy functions. These functions manage (and perform, if need be) tranfers between the user-space and an asynchronous buffer thanks to lockless mechanisms.<p>
Consequently, the developer has to use the proper buffer functions in order to write / read acquired data into / from the asynchronous buffer.<p>
Here are listed the functions:<ul>
<li>a4l_buf_prepare_(abs)put() and a4l_buf_commit_(abs)put()</li><li>a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get()</li><li><a class="el" href="group__analogy__buffer.html#gec920d203e34f2020eb51ddad3461d1c" title="Copy some data from the device driver to the buffer.">a4l_buf_put()</a></li><li><a class="el" href="group__analogy__buffer.html#g6af2dcaaecfd2cd9f0deb6e9167d3cff" title="Copy some data from the buffer to the device driver.">a4l_buf_get()</a></li><li><a class="el" href="group__analogy__buffer.html#gc275c834264a50b9443304d33908f657" title="Signal some event(s) to a user-space program involved in some read / write operation...">a4l_buf_evt()</a>.</li></ul>
<p>
The functions count might seem high; however, the developer needs a few of them to write a driver. Having so many functions enables to manage any transfer cases:<ul>
<li>If some DMA controller is available, there is no need to make the driver copy the acquired data into the asynchronous buffer, the DMA controller must directly trigger DMA shots into / from the buffer. In that case, a function a4l_buf_prepare_*() must be used so as to set up the DMA transfer and a function a4l_buf_commit_*() has to be called to complete the transfer().</li><li>For DMA controllers which need to work with global counter (the transfered data count since the beginning of the acquisition), the functions a4l_buf_*_abs_*() have been made available.</li><li>If no DMA controller is available, the driver has to perform the copy between the hardware component and the asynchronous buffer. In such cases, the functions <a class="el" href="group__analogy__buffer.html#g6af2dcaaecfd2cd9f0deb6e9167d3cff" title="Copy some data from the buffer to the device driver.">a4l_buf_get()</a> and <a class="el" href="group__analogy__buffer.html#gec920d203e34f2020eb51ddad3461d1c" title="Copy some data from the device driver to the buffer.">a4l_buf_put()</a> are useful. </li></ul>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#g8ffbc9832255a701624fe874d319e5f4">a4l_buf_prepare_absput</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the absolute count of data sent from the device to the buffer since the start of the acquisition and after the next DMA shot.  <a href="#g8ffbc9832255a701624fe874d319e5f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#g8d053d9fc6e19eb47f9c08abf485cea9">a4l_buf_commit_absput</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the absolute count of data which was sent from the device to the buffer since the start of the acquisition and until the last DMA shot.  <a href="#g8d053d9fc6e19eb47f9c08abf485cea9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#g582e96ac8358717a19995e0c8c41dffc">a4l_buf_prepare_put</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the count of data which is to be sent to the buffer at the next DMA shot.  <a href="#g582e96ac8358717a19995e0c8c41dffc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gb03dcc685bcb3ad9111c9aa3dbe3baf5">a4l_buf_commit_put</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the count of data sent to the buffer during the last completed DMA shots.  <a href="#gb03dcc685bcb3ad9111c9aa3dbe3baf5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gec920d203e34f2020eb51ddad3461d1c">a4l_buf_put</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, void *bufdata, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy some data from the device driver to the buffer.  <a href="#gec920d203e34f2020eb51ddad3461d1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#g7fecd99d23d53c69381aacee4d9222d8">a4l_buf_prepare_absget</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the absolute count of data sent from the buffer to the device since the start of the acquisition and after the next DMA shot.  <a href="#g7fecd99d23d53c69381aacee4d9222d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gdadad4789e1da9236fed49a33b1b2284">a4l_buf_commit_absget</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the absolute count of data which was sent from the buffer to the device since the start of the acquisition and until the last DMA shot.  <a href="#gdadad4789e1da9236fed49a33b1b2284"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gf9fe0b2fe2279e4f753ddec776d10c5f">a4l_buf_prepare_get</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the count of data which is to be sent from the buffer to the device at the next DMA shot.  <a href="#gf9fe0b2fe2279e4f753ddec776d10c5f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gbd70bc9f8bb4615f60c0107d51ca1f29">a4l_buf_commit_get</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the count of data sent from the buffer to the device during the last completed DMA shots.  <a href="#gbd70bc9f8bb4615f60c0107d51ca1f29"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#g6af2dcaaecfd2cd9f0deb6e9167d3cff">a4l_buf_get</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, void *bufdata, unsigned long count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy some data from the buffer to the device driver.  <a href="#g6af2dcaaecfd2cd9f0deb6e9167d3cff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gc275c834264a50b9443304d33908f657">a4l_buf_evt</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd, unsigned long evts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal some event(s) to a user-space program involved in some read / write operation.  <a href="#gc275c834264a50b9443304d33908f657"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#gd9e80150586b4a869562d3d098f49d36">a4l_buf_count</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the data amount available in the Analogy buffer.  <a href="#gd9e80150586b4a869562d3d098f49d36"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structa4l__cmd__desc.html">a4l_cmd_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#g2386d5a9d84393b5db9beb22ae7674e9">a4l_get_cmd</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current Analogy command descriptor.  <a href="#g2386d5a9d84393b5db9beb22ae7674e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__analogy__buffer.html#g6e33ba6f8a06e3dbbfe3896b0258857f">a4l_get_chan</a> (<a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *subd)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the channel index according to its type.  <a href="#g6e33ba6f8a06e3dbbfe3896b0258857f"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gdadad4789e1da9236fed49a33b1b2284"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_commit_absget" ref="gdadad4789e1da9236fed49a33b1b2284" args="(a4l_subd_t *subd, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_commit_absget           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the absolute count of data which was sent from the buffer to the device since the start of the acquisition and until the last DMA shot. 
<p>
The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count transferred to the device during the last DMA shot plus the data count which have been sent since the beginning of the acquisition</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8d053d9fc6e19eb47f9c08abf485cea9"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_commit_absput" ref="g8d053d9fc6e19eb47f9c08abf485cea9" args="(a4l_subd_t *subd, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_commit_absput           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the absolute count of data which was sent from the device to the buffer since the start of the acquisition and until the last DMA shot. 
<p>
The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count transferred to the buffer during the last DMA shot plus the data count which have been sent / retrieved since the beginning of the acquisition</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbd70bc9f8bb4615f60c0107d51ca1f29"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_commit_get" ref="gbd70bc9f8bb4615f60c0107d51ca1f29" args="(a4l_subd_t *subd, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_commit_get           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the count of data sent from the buffer to the device during the last completed DMA shots. 
<p>
The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The amount of data transferred</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb03dcc685bcb3ad9111c9aa3dbe3baf5"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_commit_put" ref="gb03dcc685bcb3ad9111c9aa3dbe3baf5" args="(a4l_subd_t *subd, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_commit_put           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the count of data sent to the buffer during the last completed DMA shots. 
<p>
The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The amount of data transferred</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd9e80150586b4a869562d3d098f49d36"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_count" ref="gd9e80150586b4a869562d3d098f49d36" args="(a4l_subd_t *subd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long a4l_buf_count           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the data amount available in the Analogy buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the amount of data available in the Analogy buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc275c834264a50b9443304d33908f657"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_evt" ref="gc275c834264a50b9443304d33908f657" args="(a4l_subd_t *subd, unsigned long evts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_evt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>evts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Signal some event(s) to a user-space program involved in some read / write operation. 
<p>
The function <a class="el" href="group__analogy__buffer.html#gc275c834264a50b9443304d33908f657" title="Signal some event(s) to a user-space program involved in some read / write operation...">a4l_buf_evt()</a> is useful in many cases:<ul>
<li>To wake-up a process waiting for some data to read.</li><li>To wake-up a process waiting for some data to write.</li><li>To notify the user-process an error has occured during the acquistion.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>evts</em>&nbsp;</td><td>Some specific event to notify:<ul>
<li>A4L_BUF_ERROR to indicate some error has occured during the transfer</li><li>A4L_BUF_EOA to indicate the acquisition is complete (this event is automatically set, it should not be used).</li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6af2dcaaecfd2cd9f0deb6e9167d3cff"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_get" ref="g6af2dcaaecfd2cd9f0deb6e9167d3cff" args="(a4l_subd_t *subd, void *bufdata, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_get           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>bufdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy some data from the buffer to the device driver. 
<p>
The function <a class="el" href="group__analogy__buffer.html#g6af2dcaaecfd2cd9f0deb6e9167d3cff" title="Copy some data from the buffer to the device driver.">a4l_buf_get()</a> must copy data coming from the Analogy buffer to some acquisition device. This ring-buffer is an intermediate area between the device driver and the user-space program, which is supposed to provide the data to send to the device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufdata</em>&nbsp;</td><td>The data buffer to copy into the Analogy buffer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The amount of data to copy</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7fecd99d23d53c69381aacee4d9222d8"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_prepare_absget" ref="g7fecd99d23d53c69381aacee4d9222d8" args="(a4l_subd_t *subd, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_prepare_absget           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the absolute count of data sent from the buffer to the device since the start of the acquisition and after the next DMA shot. 
<p>
The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(absg)et() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count to be transferred during the next DMA shot plus the data count which have been copied since the start of the acquisition</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8ffbc9832255a701624fe874d319e5f4"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_prepare_absput" ref="g8ffbc9832255a701624fe874d319e5f4" args="(a4l_subd_t *subd, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_prepare_absput           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Update the absolute count of data sent from the device to the buffer since the start of the acquisition and after the next DMA shot. 
<p>
The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(absg)et() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count to be transferred during the next DMA shot plus the data count which have been copied since the start of the acquisition</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf9fe0b2fe2279e4f753ddec776d10c5f"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_prepare_get" ref="gf9fe0b2fe2279e4f753ddec776d10c5f" args="(a4l_subd_t *subd, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_prepare_get           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the count of data which is to be sent from the buffer to the device at the next DMA shot. 
<p>
The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count to be transferred</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g582e96ac8358717a19995e0c8c41dffc"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_prepare_put" ref="g582e96ac8358717a19995e0c8c41dffc" args="(a4l_subd_t *subd, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_prepare_put           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the count of data which is to be sent to the buffer at the next DMA shot. 
<p>
The functions a4l_buf_prepare_(abs)put(), a4l_buf_commit_(abs)put(), a4l_buf_prepare_(abs)get() and a4l_buf_commit_(abs)get() have been made available for DMA transfers. In such situations, no data copy is needed between the Analogy buffer and the device as some DMA controller is in charge of performing data shots from / to the Analogy buffer. However, some pointers still have to be updated so as to monitor the tranfers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The data count to be transferred</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gec920d203e34f2020eb51ddad3461d1c"></a><!-- doxytag: member="driver_facilities.c::a4l_buf_put" ref="gec920d203e34f2020eb51ddad3461d1c" args="(a4l_subd_t *subd, void *bufdata, unsigned long count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_buf_put           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>bufdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy some data from the device driver to the buffer. 
<p>
The function <a class="el" href="group__analogy__buffer.html#gec920d203e34f2020eb51ddad3461d1c" title="Copy some data from the device driver to the buffer.">a4l_buf_put()</a> must copy data coming from some acquisition device to the Analogy buffer. This ring-buffer is an intermediate area between the device driver and the user-space program, which is supposed to recover the acquired data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bufdata</em>&nbsp;</td><td>The data buffer to copy into the Analogy buffer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>The amount of data to copy</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on success, otherwise negative error code. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6e33ba6f8a06e3dbbfe3896b0258857f"></a><!-- doxytag: member="driver_facilities.c::a4l_get_chan" ref="g6e33ba6f8a06e3dbbfe3896b0258857f" args="(a4l_subd_t *subd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int a4l_get_chan           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the channel index according to its type. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the channel index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2386d5a9d84393b5db9beb22ae7674e9"></a><!-- doxytag: member="driver_facilities.c::a4l_get_cmd" ref="g2386d5a9d84393b5db9beb22ae7674e9" args="(a4l_subd_t *subd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structa4l__cmd__desc.html">a4l_cmd_t</a>* a4l_get_cmd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structa4l__subdevice.html">a4l_subd_t</a> *&nbsp;</td>
          <td class="paramname"> <em>subd</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current Analogy command descriptor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subd</em>&nbsp;</td><td>Subdevice descriptor structure</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the command descriptor. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Mar 8 13:02:08 2011 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
