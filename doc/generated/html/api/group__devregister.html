<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: Device Registration Services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Device Registration Services<br/>
<small>
[<a class="el" href="group__driverapi.html">Driver Development API</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for Device Registration Services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__devregister.png" border="0" alt="" usemap="#group____devregister"/>
<map name="group____devregister" id="group____devregister">
<area shape="rect" id="node1" href="group__rtdmsync.html" title="Synchronisation Services" alt="" coords="481,5,663,35"/><area shape="rect" id="node3" href="group__driverapi.html" title="Driver Development API" alt="" coords="7,5,180,35"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtdm__operations.html">rtdm_operations</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device operations.  <a href="structrtdm__operations.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Device context.  <a href="structrtdm__dev__context.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtdm__device.html">rtdm_device</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RTDM device.  <a href="structrtdm__device.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html">Synchronisation Services</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga765ab311ea9024a7ff210e963acd7a14">rtdm_context_to_private</a> (struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locate the driver private area associated to a device context structure.  <a href="#ga765ab311ea9024a7ff210e963acd7a14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gacc982b978fc3967b0e9d6d308f79c6ee">rtdm_private_to_context</a> (void *dev_private)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locate a device context structure from its driver private area.  <a href="#gacc982b978fc3967b0e9d6d308f79c6ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga6a191b3d206680c48cad2047adb9fc98">rtdm_dev_register</a> (struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *device)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a RTDM device.  <a href="#ga6a191b3d206680c48cad2047adb9fc98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga9cc04a9b6e1710d9ad3860de8d81bf14">rtdm_dev_unregister</a> (struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *device, unsigned int poll_delay)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unregisters a RTDM device.  <a href="#ga9cc04a9b6e1710d9ad3860de8d81bf14"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Operation Handler Prototypes</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp606463ab19d2c973586ec9a2f23a1186"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gaf987b1139579bdb16b4541ea76121fa6">rtdm_open_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int oflag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Named device open handler.  <a href="#gaf987b1139579bdb16b4541ea76121fa6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga07b8dc34cfc42f6203c510d1e982edc5">rtdm_socket_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int protocol)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Socket creation handler for protocol devices.  <a href="#ga07b8dc34cfc42f6203c510d1e982edc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga6bd6c0761590d59f67b2c1e87fdd8440">rtdm_close_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close handler.  <a href="#ga6bd6c0761590d59f67b2c1e87fdd8440"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga3adab7928c65ee8ffd06c82c705d4804">rtdm_ioctl_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, unsigned int request, void __user *arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IOCTL handler.  <a href="#ga3adab7928c65ee8ffd06c82c705d4804"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga462c61f19f6bc6a0ef93a57ab6b218bf">rtdm_select_bind_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select binding handler.  <a href="#ga462c61f19f6bc6a0ef93a57ab6b218bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga1a2f92a5ebe9f4d46fb6722ed5da047c">rtdm_read_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, void *buf, size_t nbyte)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read handler.  <a href="#ga1a2f92a5ebe9f4d46fb6722ed5da047c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gaa2b3421e29ae63cf49622765a5bc9cee">rtdm_write_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const void *buf, size_t nbyte)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write handler.  <a href="#gaa2b3421e29ae63cf49622765a5bc9cee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga8e592853e1072c8b32e2263557990a66">rtdm_recvmsg_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, struct msghdr *msg, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive message handler.  <a href="#ga8e592853e1072c8b32e2263557990a66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga2f142d15145b97e837f5e26775a4b0f1">rtdm_sendmsg_handler_t</a> )(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const struct msghdr *msg, int flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transmit message handler.  <a href="#ga2f142d15145b97e837f5e26775a4b0f1"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Device Flags</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpc95384c55dfa1b32ba3c6b72b61e79b7"></a> <a class="anchor" id="dev_flags"></a> Static flags describing a RTDM device </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga7c66ec8f269c701237437177af0704e8">RTDM_EXCLUSIVE</a>&nbsp;&nbsp;&nbsp;0x0001</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If set, only a single instance of the device can be requested by an application.  <a href="#ga7c66ec8f269c701237437177af0704e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga7651188ca1c05f7e68b36517874138b7">RTDM_NAMED_DEVICE</a>&nbsp;&nbsp;&nbsp;0x0010</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If set, the device is addressed via a clear-text name.  <a href="#ga7651188ca1c05f7e68b36517874138b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga43ced044106ae9c1f5500d0041307d8f">RTDM_PROTOCOL_DEVICE</a>&nbsp;&nbsp;&nbsp;0x0020</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If set, the device is addressed via a combination of protocol ID and socket type.  <a href="#ga43ced044106ae9c1f5500d0041307d8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gafdb542eb46679916b0100969e1033bfc">RTDM_DEVICE_TYPE_MASK</a>&nbsp;&nbsp;&nbsp;0x00F0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask selecting the device type.  <a href="#gafdb542eb46679916b0100969e1033bfc"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Context Flags</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpa55fb86227c85483b85d2d9a0769033c"></a> <a class="anchor" id="ctx_flags"></a> Dynamic flags describing the state of an open RTDM device (bit numbers) </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gaa6f17915089145982b04c51f202d950c">RTDM_CREATED_IN_NRT</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set by RTDM if the device instance was created in non-real-time context.  <a href="#gaa6f17915089145982b04c51f202d950c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga24b993fed8dae26b6597ba37f3f92eac">RTDM_CLOSING</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set by RTDM when the device is being closed.  <a href="#ga24b993fed8dae26b6597ba37f3f92eac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga187778f8d7b6e5f0b459a526e6323471"></a><!-- doxytag: member="devregister::RTDM_USER_CONTEXT_FLAG" ref="ga187778f8d7b6e5f0b459a526e6323471" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga187778f8d7b6e5f0b459a526e6323471">RTDM_USER_CONTEXT_FLAG</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lowest bit number the driver developer can use freely. <br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Driver Versioning</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp23ea1d5e756ac16354b2dad1e19b079d"></a> <a class="anchor" id="drv_versioning"></a> Current revisions of RTDM structures, encoding of driver versions. See <a class="el" href="group__rtdm.html#api_versioning">API Versioning</a> for the interface revision. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab0f99b00be17869d5c9cd844825766f4"></a><!-- doxytag: member="devregister::RTDM_DEVICE_STRUCT_VER" ref="gab0f99b00be17869d5c9cd844825766f4" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gab0f99b00be17869d5c9cd844825766f4">RTDM_DEVICE_STRUCT_VER</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of struct <a class="el" href="structrtdm__device.html" title="RTDM device.">rtdm_device</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab127a755cab544c5b318d4f4a3578e9f"></a><!-- doxytag: member="devregister::RTDM_CONTEXT_STRUCT_VER" ref="gab127a755cab544c5b318d4f4a3578e9f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gab127a755cab544c5b318d4f4a3578e9f">RTDM_CONTEXT_STRUCT_VER</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version of struct <a class="el" href="structrtdm__dev__context.html" title="Device context.">rtdm_dev_context</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadea320d3993937f37edc6fa39a29d379"></a><!-- doxytag: member="devregister::RTDM_SECURE_DEVICE" ref="gadea320d3993937f37edc6fa39a29d379" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gadea320d3993937f37edc6fa39a29d379">RTDM_SECURE_DEVICE</a>&nbsp;&nbsp;&nbsp;0x80000000</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag indicating a secure variant of RTDM (not supported here). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeddd03e63cdce1692edcc497a44756c2"></a><!-- doxytag: member="devregister::RTDM_DRIVER_VER" ref="gaeddd03e63cdce1692edcc497a44756c2" args="(major, minor, patch)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#gaeddd03e63cdce1692edcc497a44756c2">RTDM_DRIVER_VER</a>(major, minor, patch)&nbsp;&nbsp;&nbsp;(((major &amp; 0xFF) &lt;&lt; 16) | ((minor &amp; 0xFF) &lt;&lt; 8) | (patch &amp; 0xFF))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version code constructor for driver revisions. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4df977587f67fefde551a437848b9514"></a><!-- doxytag: member="devregister::RTDM_DRIVER_MAJOR_VER" ref="ga4df977587f67fefde551a437848b9514" args="(ver)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga4df977587f67fefde551a437848b9514">RTDM_DRIVER_MAJOR_VER</a>(ver)&nbsp;&nbsp;&nbsp;(((ver) &gt;&gt; 16) &amp; 0xFF)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get major version number from driver revision code. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c2cb29427406f0febbb1c143f76497f"></a><!-- doxytag: member="devregister::RTDM_DRIVER_MINOR_VER" ref="ga1c2cb29427406f0febbb1c143f76497f" args="(ver)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga1c2cb29427406f0febbb1c143f76497f">RTDM_DRIVER_MINOR_VER</a>(ver)&nbsp;&nbsp;&nbsp;(((ver) &gt;&gt; 8) &amp; 0xFF)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get minor version number from driver revision code. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga606a1554fc17b5b8d6c0fa8d6dbb8f9b"></a><!-- doxytag: member="devregister::RTDM_DRIVER_PATCH_VER" ref="ga606a1554fc17b5b8d6c0fa8d6dbb8f9b" args="(ver)" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__devregister.html#ga606a1554fc17b5b8d6c0fa8d6dbb8f9b">RTDM_DRIVER_PATCH_VER</a>(ver)&nbsp;&nbsp;&nbsp;((ver) &amp; 0xFF)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get patch version number from driver revision code. <br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga24b993fed8dae26b6597ba37f3f92eac"></a><!-- doxytag: member="rtdm_driver.h::RTDM_CLOSING" ref="ga24b993fed8dae26b6597ba37f3f92eac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_CLOSING&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set by RTDM when the device is being closed. </p>

</div>
</div>
<a class="anchor" id="gaa6f17915089145982b04c51f202d950c"></a><!-- doxytag: member="rtdm_driver.h::RTDM_CREATED_IN_NRT" ref="gaa6f17915089145982b04c51f202d950c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_CREATED_IN_NRT&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set by RTDM if the device instance was created in non-real-time context. </p>

</div>
</div>
<a class="anchor" id="gafdb542eb46679916b0100969e1033bfc"></a><!-- doxytag: member="rtdm_driver.h::RTDM_DEVICE_TYPE_MASK" ref="gafdb542eb46679916b0100969e1033bfc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_DEVICE_TYPE_MASK&nbsp;&nbsp;&nbsp;0x00F0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Mask selecting the device type. </p>

<p>Referenced by <a class="el" href="group__devregister.html#ga6a191b3d206680c48cad2047adb9fc98">rtdm_dev_register()</a>, and <a class="el" href="group__devregister.html#ga9cc04a9b6e1710d9ad3860de8d81bf14">rtdm_dev_unregister()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c66ec8f269c701237437177af0704e8"></a><!-- doxytag: member="rtdm_driver.h::RTDM_EXCLUSIVE" ref="ga7c66ec8f269c701237437177af0704e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_EXCLUSIVE&nbsp;&nbsp;&nbsp;0x0001</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If set, only a single instance of the device can be requested by an application. </p>

<p>Referenced by <a class="el" href="group__devregister.html#ga6a191b3d206680c48cad2047adb9fc98">rtdm_dev_register()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7651188ca1c05f7e68b36517874138b7"></a><!-- doxytag: member="rtdm_driver.h::RTDM_NAMED_DEVICE" ref="ga7651188ca1c05f7e68b36517874138b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_NAMED_DEVICE&nbsp;&nbsp;&nbsp;0x0010</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If set, the device is addressed via a clear-text name. </p>

<p>Referenced by <a class="el" href="group__devregister.html#ga6a191b3d206680c48cad2047adb9fc98">rtdm_dev_register()</a>, and <a class="el" href="group__devregister.html#ga9cc04a9b6e1710d9ad3860de8d81bf14">rtdm_dev_unregister()</a>.</p>

</div>
</div>
<a class="anchor" id="ga43ced044106ae9c1f5500d0041307d8f"></a><!-- doxytag: member="rtdm_driver.h::RTDM_PROTOCOL_DEVICE" ref="ga43ced044106ae9c1f5500d0041307d8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_PROTOCOL_DEVICE&nbsp;&nbsp;&nbsp;0x0020</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If set, the device is addressed via a combination of protocol ID and socket type. </p>

<p>Referenced by <a class="el" href="group__devregister.html#ga6a191b3d206680c48cad2047adb9fc98">rtdm_dev_register()</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga6bd6c0761590d59f67b2c1e87fdd8440"></a><!-- doxytag: member="rtdm_driver.h::rtdm_close_handler_t" ref="ga6bd6c0761590d59f67b2c1e87fdd8440" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__devregister.html#ga6bd6c0761590d59f67b2c1e87fdd8440">rtdm_close_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode or deferred user mode call</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, -EAGAIN to request a recall after a grace period, or a valid negative error code according to IEEE Std 1003.1.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Drivers must be prepared for that case that the close handler is invoked more than once per open context (even if the handler already completed an earlier run successfully). The driver has to avoid releasing resources twice as well as returning false errors on successive close invocations.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code><a class="el" href="group__posix__shm.html#gaafbcde67669a1b96577e735ddebd8634" title="Close a file descriptor.">close()</a></code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3adab7928c65ee8ffd06c82c705d4804"></a><!-- doxytag: member="rtdm_driver.h::rtdm_ioctl_handler_t" ref="ga3adab7928c65ee8ffd06c82c705d4804" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, unsigned int request, void __user *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__devregister.html#ga3adab7928c65ee8ffd06c82c705d4804">rtdm_ioctl_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, unsigned int request, void __user *arg)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IOCTL handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>request</em>&nbsp;</td><td>Request number as passed by the user </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>arg</em>&nbsp;</td><td>Request argument as passed by the user</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A positive value or 0 on success. On failure return either -ENOSYS, to request that the function be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code>ioctl()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf987b1139579bdb16b4541ea76121fa6"></a><!-- doxytag: member="rtdm_driver.h::rtdm_open_handler_t" ref="gaf987b1139579bdb16b4541ea76121fa6" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, int oflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__devregister.html#gaf987b1139579bdb16b4541ea76121fa6">rtdm_open_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int oflag)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Named device open handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>oflag</em>&nbsp;</td><td>Open flags as passed by the user</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code>open()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a2f92a5ebe9f4d46fb6722ed5da047c"></a><!-- doxytag: member="rtdm_driver.h::rtdm_read_handler_t" ref="ga1a2f92a5ebe9f4d46fb6722ed5da047c" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, void *buf, size_t nbyte)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* <a class="el" href="group__devregister.html#ga1a2f92a5ebe9f4d46fb6722ed5da047c">rtdm_read_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, void *buf, size_t nbyte)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Input buffer as passed by the user </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbyte</em>&nbsp;</td><td>Number of bytes the user requests to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success, the number of bytes read. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code>read()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e592853e1072c8b32e2263557990a66"></a><!-- doxytag: member="rtdm_driver.h::rtdm_recvmsg_handler_t" ref="ga8e592853e1072c8b32e2263557990a66" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, struct msghdr *msg, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* <a class="el" href="group__devregister.html#ga8e592853e1072c8b32e2263557990a66">rtdm_recvmsg_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, struct msghdr *msg, int flags)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive message handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>msg</em>&nbsp;</td><td>Message descriptor as passed by the user, automatically mirrored to safe kernel memory in case of user mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Message flags as passed by the user</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success, the number of bytes received. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code>recvmsg()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga462c61f19f6bc6a0ef93a57ab6b218bf"></a><!-- doxytag: member="rtdm_driver.h::rtdm_select_bind_handler_t" ref="ga462c61f19f6bc6a0ef93a57ab6b218bf" args=")(struct rtdm_dev_context *context, rtdm_selector_t *selector, enum rtdm_selecttype type, unsigned fd_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__devregister.html#ga462c61f19f6bc6a0ef93a57ab6b218bf">rtdm_select_bind_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Select binding handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>selector</em>&nbsp;</td><td>Object that shall be bound to the given event </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Event type the selector is interested in </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fd_index</em>&nbsp;</td><td>Opaque value, to be passed to rtdm_event_select_bind or rtdm_sem_select_bind unmodfied</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f142d15145b97e837f5e26775a4b0f1"></a><!-- doxytag: member="rtdm_driver.h::rtdm_sendmsg_handler_t" ref="ga2f142d15145b97e837f5e26775a4b0f1" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, const struct msghdr *msg, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* <a class="el" href="group__devregister.html#ga2f142d15145b97e837f5e26775a4b0f1">rtdm_sendmsg_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const struct msghdr *msg, int flags)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transmit message handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>msg</em>&nbsp;</td><td>Message descriptor as passed by the user, automatically mirrored to safe kernel memory in case of user mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Message flags as passed by the user</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success, the number of bytes transmitted. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code>sendmsg()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga07b8dc34cfc42f6203c510d1e982edc5"></a><!-- doxytag: member="rtdm_driver.h::rtdm_socket_handler_t" ref="ga07b8dc34cfc42f6203c510d1e982edc5" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, int protocol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__devregister.html#ga07b8dc34cfc42f6203c510d1e982edc5">rtdm_socket_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, int protocol)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Socket creation handler for protocol devices. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>protocol</em>&nbsp;</td><td>Protocol number as passed by the user</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code>socket()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2b3421e29ae63cf49622765a5bc9cee"></a><!-- doxytag: member="rtdm_driver.h::rtdm_write_handler_t" ref="gaa2b3421e29ae63cf49622765a5bc9cee" args=")(struct rtdm_dev_context *context, rtdm_user_info_t *user_info, const void *buf, size_t nbyte)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* <a class="el" href="group__devregister.html#gaa2b3421e29ae63cf49622765a5bc9cee">rtdm_write_handler_t</a>)(struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *context, rtdm_user_info_t *user_info, const void *buf, size_t nbyte)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write handler. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user_info</em>&nbsp;</td><td>Opaque pointer to information about user mode caller, NULL if kernel mode call </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>Output buffer as passed by the user </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nbyte</em>&nbsp;</td><td>Number of bytes the user requests to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On success, the number of bytes written. On failure return either -ENOSYS, to request that this handler be called again from the opposite realtime/non-realtime context, or another negative error code.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><code>write()</code> in IEEE Std 1003.1, <a href="http://www.opengroup.org/onlinepubs/009695399">http://www.opengroup.org/onlinepubs/009695399</a> </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga765ab311ea9024a7ff210e963acd7a14"></a><!-- doxytag: member="rtdm_driver.h::rtdm_context_to_private" ref="ga765ab311ea9024a7ff210e963acd7a14" args="(struct rtdm_dev_context *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void* rtdm_context_to_private </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a> *&nbsp;</td>
          <td class="paramname"> <em>context</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locate the driver private area associated to a device context structure. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>context</em>&nbsp;</td><td>Context structure associated with opened device instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the private driver area associated to <em>context</em>. </dd></dl>

<p>References <a class="el" href="structrtdm__dev__context.html#a720bc9395d80f0dea40c7ac3e449ea25">rtdm_dev_context::dev_private</a>.</p>

</div>
</div>
<a class="anchor" id="ga6a191b3d206680c48cad2047adb9fc98"></a><!-- doxytag: member="device.c::rtdm_dev_register" ref="ga6a191b3d206680c48cad2047adb9fc98" args="(struct rtdm_device *device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_dev_register </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *&nbsp;</td>
          <td class="paramname"> <em>device</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a RTDM device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device</em>&nbsp;</td><td>Pointer to structure describing the new device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if the device structure contains invalid entries. Check kernel log in this case.</li>
</ul>
<ul>
<li>-ENOMEM is returned if the context for an exclusive device cannot be allocated.</li>
</ul>
<ul>
<li>-EEXIST is returned if the specified device name of protocol ID is already in use.</li>
</ul>
<ul>
<li>-EAGAIN is returned if some /proc entry cannot be created.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="structrtdm__operations.html#a218dceb0ad1125f2c1c3e3e95a8d4894">rtdm_operations::close_nrt</a>, <a class="el" href="structrtdm__operations.html#a23a81aa4c48d55c937c2763c27c8372c">rtdm_operations::close_rt</a>, <a class="el" href="structrtdm__device.html#a48d67f835c341c5d27bc5886920a11da">rtdm_device::context_size</a>, <a class="el" href="structrtdm__device.html#a94aa3100258b43c812c5240b55777f07">rtdm_device::device_class</a>, <a class="el" href="structrtdm__device.html#af459bf86f0d037c99bb669f627d78764">rtdm_device::device_flags</a>, <a class="el" href="structrtdm__device.html#a376a833e95ff75eb9c8033895bc5e102">rtdm_device::device_name</a>, <a class="el" href="structrtdm__device.html#aece6c5135a6256dbb3636f66eb97cb40">rtdm_device::device_sub_class</a>, <a class="el" href="structrtdm__device.html#aebcb235c789d0698fd821124817e2330">rtdm_device::driver_version</a>, <a class="el" href="structrtdm__device.html#af05d59487bedf7d79dc6b1858c0353c9">rtdm_device::open_rt</a>, <a class="el" href="structrtdm__device.html#a5f92064ba1e7eb351b00277b17d513ef">rtdm_device::ops</a>, <a class="el" href="structrtdm__device.html#a0df5612d6bfcf6421509345384467392">rtdm_device::proc_name</a>, <a class="el" href="structrtdm__device.html#a157db58bb0025b832ca409bc40735ae9">rtdm_device::profile_version</a>, <a class="el" href="structrtdm__device.html#ae58c050e09a79b277f718d796eda2072">rtdm_device::protocol_family</a>, <a class="el" href="structrtdm__device.html#a548f89224ffc7146fd46c53a0eb48040">rtdm_device::reserved</a>, <a class="el" href="group__devregister.html#gab0f99b00be17869d5c9cd844825766f4">RTDM_DEVICE_STRUCT_VER</a>, <a class="el" href="group__devregister.html#gafdb542eb46679916b0100969e1033bfc">RTDM_DEVICE_TYPE_MASK</a>, <a class="el" href="group__devregister.html#ga7c66ec8f269c701237437177af0704e8">RTDM_EXCLUSIVE</a>, <a class="el" href="group__devregister.html#ga7651188ca1c05f7e68b36517874138b7">RTDM_NAMED_DEVICE</a>, <a class="el" href="group__devregister.html#ga43ced044106ae9c1f5500d0041307d8f">RTDM_PROTOCOL_DEVICE</a>, <a class="el" href="structrtdm__operations.html#aa052e237d48e04bfb777fde1b6eb83e7">rtdm_operations::select_bind</a>, <a class="el" href="structrtdm__device.html#ad83a8dff6e8705e442f9a7d352556267">rtdm_device::socket_rt</a>, <a class="el" href="structrtdm__device.html#a02552f2d91052bd801576b3a132ba3f9">rtdm_device::socket_type</a>, and <a class="el" href="structrtdm__device.html#aaa2844f98d874f16d802b4e0b693e4e2">rtdm_device::struct_version</a>.</p>

</div>
</div>
<a class="anchor" id="ga9cc04a9b6e1710d9ad3860de8d81bf14"></a><!-- doxytag: member="device.c::rtdm_dev_unregister" ref="ga9cc04a9b6e1710d9ad3860de8d81bf14" args="(struct rtdm_device *device, unsigned int poll_delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_dev_unregister </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrtdm__device.html">rtdm_device</a> *&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>poll_delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters a RTDM device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>device</em>&nbsp;</td><td>Pointer to structure describing the device to be unregistered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>poll_delay</em>&nbsp;</td><td>Polling delay in milliseconds to check repeatedly for open instances of <em>device</em>, or 0 for non-blocking mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENODEV is returned if the device was not registered.</li>
</ul>
<ul>
<li>-EAGAIN is returned if the device is busy with open instances and 0 has been passed for <em>poll_delay</em>.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="structrtdm__device.html#af459bf86f0d037c99bb669f627d78764">rtdm_device::device_flags</a>, <a class="el" href="structrtdm__device.html#a376a833e95ff75eb9c8033895bc5e102">rtdm_device::device_name</a>, <a class="el" href="structrtdm__device.html#ae58c050e09a79b277f718d796eda2072">rtdm_device::protocol_family</a>, <a class="el" href="structrtdm__device.html#a548f89224ffc7146fd46c53a0eb48040">rtdm_device::reserved</a>, <a class="el" href="group__devregister.html#gafdb542eb46679916b0100969e1033bfc">RTDM_DEVICE_TYPE_MASK</a>, <a class="el" href="group__devregister.html#ga7651188ca1c05f7e68b36517874138b7">RTDM_NAMED_DEVICE</a>, and <a class="el" href="structrtdm__device.html#a02552f2d91052bd801576b3a132ba3f9">rtdm_device::socket_type</a>.</p>

</div>
</div>
<a class="anchor" id="gacc982b978fc3967b0e9d6d308f79c6ee"></a><!-- doxytag: member="rtdm_driver.h::rtdm_private_to_context" ref="gacc982b978fc3967b0e9d6d308f79c6ee" args="(void *dev_private)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrtdm__dev__context.html">rtdm_dev_context</a>* rtdm_private_to_context </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dev_private</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static, read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locate a device context structure from its driver private area. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dev_private</em>&nbsp;</td><td>Address of a private context area</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address of the device context structure defining <em>dev_private</em>. </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jan 23 2013 13:24:04 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
