<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: Shared memory services.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Shared memory services.<br/>
<small>
[<a class="el" href="group__posix.html">POSIX skin.</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Shared memory services.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Shared memory services.:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__posix__shm.png" border="0" alt="" usemap="#group____posix____shm"/>
<map name="group____posix____shm" id="group____posix____shm">
<area shape="rect" id="node1" href="group__posix.html" title="Xenomai POSIX skin is an implementation of a small subset of the Single Unix specification over Xenom..." alt="" coords="7,5,100,35"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba">shm_open</a> (const char *name, int oflags, mode_t mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open a shared memory object.  <a href="#gaf765a0fa9152fbf874436c966f3af7ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__shm.html#gaafbcde67669a1b96577e735ddebd8634">close</a> (int fd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close a file descriptor.  <a href="#gaafbcde67669a1b96577e735ddebd8634"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__shm.html#ga4037e49e9537e24edd610bd1acf090da">shm_unlink</a> (const char *name)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlink a shared memory object.  <a href="#ga4037e49e9537e24edd610bd1acf090da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__shm.html#ga9da29f129638ac71727226b54d80493b">ftruncate</a> (int fd, off_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Truncate a file or shared memory object to a specified length.  <a href="#ga9da29f129638ac71727226b54d80493b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__shm.html#ga554a82c077a35cc07f80519d34b3f0e2">mmap</a> (void *addr, size_t len, int prot, int flags, int fd, off_t off)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Map pages of memory.  <a href="#ga554a82c077a35cc07f80519d34b3f0e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__posix__shm.html#ga01ff21bc70401bee9b80c350763087f7">munmap</a> (void *addr, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unmap pages of memory.  <a href="#ga01ff21bc70401bee9b80c350763087f7"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Shared memory services. </p>
<p>Shared memory objects are memory regions that can be mapped into processes address space, allowing them to share these regions as well as to share them with kernel-space modules.</p>
<p>Shared memory are also the only mean by which anonymous POSIX skin synchronization objects (mutexes, condition variables or semaphores) may be shared between kernel-space modules and user-space processes, or between several processes. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaafbcde67669a1b96577e735ddebd8634"></a><!-- doxytag: member="shm.c::close" ref="gaafbcde67669a1b96577e735ddebd8634" args="(int fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int close </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close a file descriptor. </p>
<p>This service closes the file descriptor <em>fd</em>. In kernel-space, this service only works for file descriptors opened with <a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba" title="Open a shared memory object.">shm_open()</a>, i.e. shared memory objects. A shared memory object is only destroyed once all file descriptors are closed with this service, it is unlinked with the <a class="el" href="group__posix__shm.html#ga4037e49e9537e24edd610bd1acf090da" title="Unlink a shared memory object.">shm_unlink()</a> service, and all mappings are unmapped with the <a class="el" href="group__posix__shm.html#ga01ff21bc70401bee9b80c350763087f7" title="Unmap pages of memory.">munmap()</a> service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>file descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>EBADF, <em>fd</em> is not a valid file descriptor (in kernel-space, it was not obtained with <a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba" title="Open a shared memory object.">shm_open()</a>);</li>
<li>EPERM, the caller context is invalid.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li>
<li>kernel-space cancellation cleanup routine;</li>
<li>user-space thread (Xenomai threads switch to secondary mode);</li>
<li>user-space cancellation cleanup routine.</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/close.html">Specification.</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="bufp-label_8c-example.html#a5">bufp-label.c</a>, <a class="el" href="bufp-readwrite_8c-example.html#a3">bufp-readwrite.c</a>, <a class="el" href="iddp-label_8c-example.html#a4">iddp-label.c</a>, <a class="el" href="iddp-sendrecv_8c-example.html#a3">iddp-sendrecv.c</a>, <a class="el" href="pipe_8c-example.html#a0">pipe.c</a>, and <a class="el" href="rtcan__rtt_8c-example.html#a22">rtcan_rtt.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba">shm_open()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9da29f129638ac71727226b54d80493b"></a><!-- doxytag: member="shm.c::ftruncate" ref="ga9da29f129638ac71727226b54d80493b" args="(int fd, off_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ftruncate </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Truncate a file or shared memory object to a specified length. </p>
<p>When used in kernel-space, this service set to <em>len</em> the size of a shared memory object opened with the <a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba" title="Open a shared memory object.">shm_open()</a> service. In user-space this service falls back to Linux regular ftruncate service for file descriptors not obtained with <a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba" title="Open a shared memory object.">shm_open()</a>. When this service is used to increase the size of a shared memory object, the added space is zero-filled.</p>
<p>Shared memory are suitable for direct memory access (allocated in physically contiguous memory) if O_DIRECT was passed to shm_open.</p>
<p>Shared memory objects may only be resized if they are not currently mapped.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>file descriptor;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>new length of the underlying file or shared memory object.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>EBADF, <em>fd</em> is not a valid file descriptor;</li>
<li>EPERM, the caller context is invalid;</li>
<li>EINVAL, the specified length is invalid;</li>
<li>EINVAL, the architecture can not honour the O_DIRECT flag;</li>
<li>EINTR, this service was interrupted by a signal;</li>
<li>EBUSY, <em>fd</em> is a shared memory object descriptor and the underlying shared memory is currently mapped;</li>
<li>EFBIG, allocation of system memory failed.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li>
<li>user-space thread (Xenomai threads switch to secondary mode).</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/ftruncate.html">Specification.</a> </dd></dl>

<p>References <a class="el" href="group__heap.html#gaaa8ae99881c9e6a4f8b56aa79f983bdb">xnheap_alloc()</a>, <a class="el" href="group__heap.html#ga5dc4305113cd272cfed62e20e2a12ae6">xnheap_free()</a>, and <a class="el" href="group__heap.html#gabfa339d98cfd2271b5d80d64b20c0e2c">xnheap_set_label()</a>.</p>

<p>Referenced by <a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba">shm_open()</a>.</p>

</div>
</div>
<a class="anchor" id="ga554a82c077a35cc07f80519d34b3f0e2"></a><!-- doxytag: member="shm.c::mmap" ref="ga554a82c077a35cc07f80519d34b3f0e2" args="(void *addr, size_t len, int prot, int flags, int fd, off_t off)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* mmap </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&nbsp;</td>
          <td class="paramname"> <em>off</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Map pages of memory. </p>
<p>This service allow shared memory regions to be accessed by the caller.</p>
<p>When used in kernel-space, this service returns the address of the offset <em>off</em> of the shared memory object underlying <em>fd</em>. The protection flags <em>prot</em>, are only checked for consistency with <em>fd</em> open flags, but memory protection is unsupported. An existing shared memory region exists before it is mapped, this service only increments a reference counter.</p>
<p>The only supported value for <em>flags</em> is <em>MAP_SHARED</em>.</p>
<p>When used in user-space, this service maps the specified shared memory region into the caller address-space. If <em>fd</em> is not a shared memory object descriptor (i.e. not obtained with <a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba" title="Open a shared memory object.">shm_open()</a>), this service falls back to the regular Linux mmap service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>ignored.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>size of the shared memory region to be mapped.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prot</em>&nbsp;</td><td>protection bits, checked in kernel-space, but only useful in user-space, are a bitwise or of the following values:</p>
<ul>
<li>PROT_NONE, meaning that the mapped region can not be accessed;</li>
<li>PROT_READ, meaning that the mapped region can be read;</li>
<li>PROT_WRITE, meaning that the mapped region can be written;</li>
<li>PROT_EXEC, meaning that the mapped region can be executed.</li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>only MAP_SHARED is accepted, meaning that the mapped memory region is shared.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>file descriptor, obtained with <a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba" title="Open a shared memory object.">shm_open()</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>off</em>&nbsp;</td><td>offset in the shared memory region.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MAP_FAILED</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>EINVAL, <em>len</em> is null or <em>addr</em> is not a multiple of <em>PAGE_SIZE</em>;</li>
<li>EBADF, <em>fd</em> is not a shared memory object descriptor (obtained with <a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba" title="Open a shared memory object.">shm_open()</a>);</li>
<li>EPERM, the caller context is invalid;</li>
<li>ENOTSUP, <em>flags</em> is not <em>MAP_SHARED</em>;</li>
<li>EACCES, <em>fd</em> is not opened for reading or is not opend for writing and PROT_WRITE is set in <em>prot</em>;</li>
<li>EINTR, this service was interrupted by a signal;</li>
<li>ENXIO, the range [off;off+len) is invalid for the shared memory region specified by <em>fd</em>;</li>
<li>EAGAIN, insufficient memory exists in the system heap to create the mapping, increase CONFIG_XENO_OPT_SYS_HEAPSZ.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li>
<li>user-space thread (Xenomai threads switch to secondary mode).</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/mmap.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga01ff21bc70401bee9b80c350763087f7"></a><!-- doxytag: member="shm.c::munmap" ref="ga01ff21bc70401bee9b80c350763087f7" args="(void *addr, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int munmap </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unmap pages of memory. </p>
<p>This service unmaps the shared memory region [addr;addr+len) from the caller address-space.</p>
<p>When called from kernel-space the memory region remain accessible as long as it exists, and this service only decrements a reference counter.</p>
<p>When called from user-space, if the region is not a shared memory region, this service falls back to the regular Linux <a class="el" href="group__posix__shm.html#ga01ff21bc70401bee9b80c350763087f7" title="Unmap pages of memory.">munmap()</a> service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>start address of shared memory area;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the shared memory area.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>EINVAL, <em>len</em> is null, <em>addr</em> is not a multiple of the page size or the range [addr;addr+len) is not a mapped region;</li>
<li>ENXIO, <em>addr</em> is not the address of a shared memory area;</li>
<li>EPERM, the caller context is invalid;</li>
<li>EINTR, this service was interrupted by a signal.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li>
<li>kernel-space cancellation cleanup routine;</li>
<li>user-space thread (Xenomai threads switch to secondary mode);</li>
<li>user-space cancellation cleanup routine.</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/munmap.html">Specification.</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf765a0fa9152fbf874436c966f3af7ba"></a><!-- doxytag: member="shm.c::shm_open" ref="gaf765a0fa9152fbf874436c966f3af7ba" args="(const char *name, int oflags, mode_t mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int shm_open </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>oflags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open a shared memory object. </p>
<p>This service establishes a connection between a shared memory object and a file descriptor. Further use of this descriptor will allow to dimension and map the shared memory into the calling context address space.</p>
<p>One of the following access mode should be set in <em>oflags:</em> </p>
<ul>
<li>O_RDONLY, meaning that the shared memory object may only be mapped with the PROT_READ flag;</li>
<li>O_WRONLY, meaning that the shared memory object may only be mapped with the PROT_WRITE flag;</li>
<li>O_RDWR, meaning that the shared memory object may be mapped with the PROT_READ | PROT_WRITE flag.</li>
</ul>
<p>If no shared memory object named <em>name</em> exists, and <em>oflags</em> has the <em>O_CREAT</em> bit set, the shared memory object is created by this function.</p>
<p>If <em>oflags</em> has the two bits <em>O_CREAT</em> and <em>O_EXCL</em> set and the shared memory object alread exists, this service fails.</p>
<p>If <em>oflags</em> has the bit <em>O_TRUNC</em> set, the shared memory exists and is not currently mapped, its size is truncated to 0.</p>
<p>If <em>oflags</em> has the bit <em>O_DIRECT</em> set, the shared memory will be suitable for direct memory access (allocated in physically contiguous memory).</p>
<p><em>name</em> may be any arbitrary string, in which slashes have no particular meaning. However, for portability, using a name which starts with a slash and contains no other slash is recommended.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of the shared memory object to open;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oflags</em>&nbsp;</td><td>flags.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a file descriptor on success; </dd>
<dd>
-1 with <em>errno</em> set if:<ul>
<li>ENAMETOOLONG, the length of the <em>name</em> argument exceeds 64 characters;</li>
<li>EEXIST, the bits <em>O_CREAT</em> and <em>O_EXCL</em> were set in <em>oflags</em> and the shared memory object already exists;</li>
<li>ENOENT, the bit <em>O_CREAT</em> is not set in <em>oflags</em> and the shared memory object does not exist;</li>
<li>ENOSPC, insufficient memory exists in the system heap to create the shared memory object, increase CONFIG_XENO_OPT_SYS_HEAPSZ;</li>
<li>EPERM, the caller context is invalid;</li>
<li>EINVAL, the O_TRUNC flag was specified and the shared memory object is currently mapped;</li>
<li>EMFILE, too many descriptors are currently open.</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li>
<li>user-space thread (Xenomai threads switch to secondary mode).</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/shm_open.html">Specification.</a> </dd></dl>

<p>References <a class="el" href="group__posix__shm.html#gaafbcde67669a1b96577e735ddebd8634">close()</a>, and <a class="el" href="group__posix__shm.html#ga9da29f129638ac71727226b54d80493b">ftruncate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4037e49e9537e24edd610bd1acf090da"></a><!-- doxytag: member="shm.c::shm_unlink" ref="ga4037e49e9537e24edd610bd1acf090da" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int shm_unlink </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlink a shared memory object. </p>
<p>This service unlinks the shared memory object named <em>name</em>. The shared memory object is not destroyed until every file descriptor obtained with the <a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba" title="Open a shared memory object.">shm_open()</a> service is closed with the <a class="el" href="group__posix__shm.html#gaafbcde67669a1b96577e735ddebd8634" title="Close a file descriptor.">close()</a> service and all mappings done with <a class="el" href="group__posix__shm.html#ga554a82c077a35cc07f80519d34b3f0e2" title="Map pages of memory.">mmap()</a> are unmapped with <a class="el" href="group__posix__shm.html#ga01ff21bc70401bee9b80c350763087f7" title="Unmap pages of memory.">munmap()</a>. However, after a call to this service, the unlinked shared memory object may no longer be reached with the <a class="el" href="group__posix__shm.html#gaf765a0fa9152fbf874436c966f3af7ba" title="Open a shared memory object.">shm_open()</a> service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of the shared memory obect to be unlinked.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-1</em>&nbsp;</td><td>with <em>errno</em> set if:</p>
<ul>
<li>EPERM, the caller context is invalid;</li>
<li>ENAMETOOLONG, the length of the <em>name</em> argument exceeds 64 characters;</li>
<li>ENOENT, the shared memory object does not exist.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Valid contexts:</b></dt><dd><ul>
<li>kernel module initialization or cleanup routine;</li>
<li>kernel-space cancellation cleanup routine;</li>
<li>user-space thread (Xenomai threads switch to secondary mode);</li>
<li>user-space cancellation cleanup routine.</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.opengroup.org/onlinepubs/000095399/functions/shm_unlink.html">Specification.</a> </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jan 23 2013 13:24:05 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
