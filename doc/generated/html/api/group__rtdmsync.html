<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: Synchronisation Services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Synchronisation Services<br/>
<small>
[<a class="el" href="group__driverapi.html">Driver Development API</a>,&nbsp;<a class="el" href="group__devregister.html">Device Registration Services</a>]</small>
</h1>
<p><div class="dynheader">
Collaboration diagram for Synchronisation Services:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__rtdmsync.png" border="0" alt="" usemap="#group____rtdmsync_map"/>
<map name="group____rtdmsync_map" id="group____rtdmsync">
<area shape="rect" href="group__devregister.html" title="Device Registration Services" alt="" coords="5,5,195,35"/><area shape="rect" href="group__driverapi.html" title="Driver Development API" alt="" coords="20,59,180,88"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga0f7da4cec7713ed732ffd99040e219e2">rtdm_select_bind</a> (int fd, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind a selector to specified event types of a given file descriptor.  <a href="#ga0f7da4cec7713ed732ffd99040e219e2"></a><br/></td></tr>
<tr><td colspan="2"><h2>RTDM_SELECTTYPE_xxx</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpe7c56e23b943533d601cd08637a81e10"></a> <a class="anchor" id="RTDM_SELECTTYPE_xxx"></a> Event types select can bind to </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> { <a class="el" href="group__rtdmsync.html#ggae18228df8c70c9da1f90f61b01e92501a3ddb0fbad9f52ad3646be2e5a6ba8b2b">RTDM_SELECTTYPE_READ</a> =  XNSELECT_READ, 
<a class="el" href="group__rtdmsync.html#ggae18228df8c70c9da1f90f61b01e92501a37819f609dee2b20852001e9b7ecd462">RTDM_SELECTTYPE_WRITE</a> =  XNSELECT_WRITE, 
<a class="el" href="group__rtdmsync.html#ggae18228df8c70c9da1f90f61b01e92501a2dd10c612a9e3c7e5134ee122ee3de74">RTDM_SELECTTYPE_EXCEPT</a> =  XNSELECT_EXCEPT
 }</td></tr>
<tr><td colspan="2"><h2>Spinlock with Preemption Deactivation</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpb9ad5714fd320b2b1e48dec7b5acd485"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab6398c5dab6f8614bc8310b2248ae0b6"></a><!-- doxytag: member="rtdmsync::rtdm_lock_t" ref="gab6398c5dab6f8614bc8310b2248ae0b6" args="" -->
typedef rthal_spinlock_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gab6398c5dab6f8614bc8310b2248ae0b6">rtdm_lock_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Lock variable. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7584217487c323356414e21200a57e63"></a><!-- doxytag: member="rtdmsync::rtdm_lockctx_t" ref="ga7584217487c323356414e21200a57e63" args="" -->
typedef unsigned long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga7584217487c323356414e21200a57e63">rtdm_lockctx_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Variable to save the context while holding a lock. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1dd901a6311b10ef7961b5fce7fa9d41"></a><!-- doxytag: member="rtdmsync::RTDM_LOCK_UNLOCKED" ref="ga1dd901a6311b10ef7961b5fce7fa9d41" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga1dd901a6311b10ef7961b5fce7fa9d41">RTDM_LOCK_UNLOCKED</a>&nbsp;&nbsp;&nbsp;RTHAL_SPIN_LOCK_UNLOCKED</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static lock initialisation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga6abf985ea7a0b13ec564cf0107fd8cba">rtdm_lock_init</a>(lock)&nbsp;&nbsp;&nbsp;rthal_spin_lock_init(lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamic lock initialisation.  <a href="#ga6abf985ea7a0b13ec564cf0107fd8cba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga65a4897268e15bda462b871976cb3909">rtdm_lock_get</a>(lock)&nbsp;&nbsp;&nbsp;rthal_spin_lock(lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire lock from non-preemptible contexts.  <a href="#ga65a4897268e15bda462b871976cb3909"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga963bdb01102d0076cd64f6bc72a347da">rtdm_lock_put</a>(lock)&nbsp;&nbsp;&nbsp;rthal_spin_unlock(lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release lock without preemption restoration.  <a href="#ga963bdb01102d0076cd64f6bc72a347da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga985473873f9e32af688fe8a23634693d">rtdm_lock_get_irqsave</a>(lock, context)&nbsp;&nbsp;&nbsp;rthal_spin_lock_irqsave(lock, context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acquire lock and disable preemption.  <a href="#ga985473873f9e32af688fe8a23634693d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga4f1f8e33baf33b162636f63dec61aebd">rtdm_lock_put_irqrestore</a>(lock, context)&nbsp;&nbsp;&nbsp;rthal_spin_unlock_irqrestore(lock, context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release lock and restore preemption state.  <a href="#ga4f1f8e33baf33b162636f63dec61aebd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga3d563fc5def018f743c55c452e061758">rtdm_lock_irqsave</a>(context)&nbsp;&nbsp;&nbsp;rthal_local_irq_save(context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable preemption locally.  <a href="#ga3d563fc5def018f743c55c452e061758"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gae03c387fcae8a55105dd31d7c008bbb4">rtdm_lock_irqrestore</a>(context)&nbsp;&nbsp;&nbsp;rthal_local_irq_restore(context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restore preemption state.  <a href="#gae03c387fcae8a55105dd31d7c008bbb4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Timeout Sequence Management</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpbc7abbd9a20332066922e13edce14f6e"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4">rtdm_toseq_init</a> (rtdm_toseq_t *timeout_seq, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a timeout sequence.  <a href="#ga531ddf80690059302409f760bd7f14d4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Event Services</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp4c82913578450ffbb3dfd9c16d037e25"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19">rtdm_event_init</a> (rtdm_event_t *event, unsigned long pending)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise an event.  <a href="#gaddf08d8ba5a44668bb360070a114fb19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga7b27d0206027a07958d4a09017e8a3fe">rtdm_event_destroy</a> (rtdm_event_t *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy an event.  <a href="#ga7b27d0206027a07958d4a09017e8a3fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga7c9745d1db8e6de244a6c2690cbb8b22">rtdm_event_pulse</a> (rtdm_event_t *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal an event occurrence to currently listening waiters.  <a href="#ga7c9745d1db8e6de244a6c2690cbb8b22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga1217402b82034b26fe25c26f1e5b32c9">rtdm_event_signal</a> (rtdm_event_t *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signal an event occurrence.  <a href="#ga1217402b82034b26fe25c26f1e5b32c9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga1c433b50c53d49d164b084751861e855">rtdm_event_wait</a> (rtdm_event_t *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on event occurrence.  <a href="#ga1c433b50c53d49d164b084751861e855"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait</a> (rtdm_event_t *event, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *timeout_seq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait on event occurrence with timeout.  <a href="#gaf76f858a3951ca2e20d3b1e00afa17e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga732fe3cf3370df0f296f06fc4ac7f925">rtdm_event_clear</a> (rtdm_event_t *event)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear event state.  <a href="#ga732fe3cf3370df0f296f06fc4ac7f925"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga839656c781d87069dd1bf1c84c38e9d9">rtdm_event_select_bind</a> (rtdm_event_t *event, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind a selector to an event.  <a href="#ga839656c781d87069dd1bf1c84c38e9d9"></a><br/></td></tr>
<tr><td colspan="2"><h2>Semaphore Services</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp7f05b7ebfb8314fb6e0eac1409c9e17a"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d">rtdm_sem_init</a> (rtdm_sem_t *sem, unsigned long value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a semaphore.  <a href="#gae1172824e463d7705ed3033e8aea133d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gaf16f45217e54201ff3f24753982c41f8">rtdm_sem_destroy</a> (rtdm_sem_t *sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a semaphore.  <a href="#gaf16f45217e54201ff3f24753982c41f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga59da1b60b7279c1fc4355e2e0b2cc77c">rtdm_sem_down</a> (rtdm_sem_t *sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrement a semaphore.  <a href="#ga59da1b60b7279c1fc4355e2e0b2cc77c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga8aadb120a93df5dfd717c5bac6d4c1a9">rtdm_sem_timeddown</a> (rtdm_sem_t *sem, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *timeout_seq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrement a semaphore with timeout.  <a href="#ga8aadb120a93df5dfd717c5bac6d4c1a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga829dbd8c5709d798ed06947b27001fed">rtdm_sem_up</a> (rtdm_sem_t *sem)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment a semaphore.  <a href="#ga829dbd8c5709d798ed06947b27001fed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gaf61f576b0ff06f99399b27725aef0ae1">rtdm_sem_select_bind</a> (rtdm_sem_t *sem, rtdm_selector_t *selector, enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> type, unsigned fd_index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind a selector to a semaphore.  <a href="#gaf61f576b0ff06f99399b27725aef0ae1"></a><br/></td></tr>
<tr><td colspan="2"><h2>Mutex Services</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp63f5233d8eb35e3b86f7a16e9f5cf0e6"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5">rtdm_mutex_init</a> (rtdm_mutex_t *mutex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialise a mutex.  <a href="#ga8d58a144bf71df7b38bb887d036cbbb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gad13170b569d0a4cdb46072e1e3a45527">rtdm_mutex_destroy</a> (rtdm_mutex_t *mutex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a mutex.  <a href="#gad13170b569d0a4cdb46072e1e3a45527"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gab40ed579324d8cc76387a0e06dd0f82a">rtdm_mutex_unlock</a> (rtdm_mutex_t *mutex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release a mutex.  <a href="#gab40ed579324d8cc76387a0e06dd0f82a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga67c8f85c844df1aeed806e343a1b6437">rtdm_mutex_lock</a> (rtdm_mutex_t *mutex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a mutex.  <a href="#ga67c8f85c844df1aeed806e343a1b6437"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#ga0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock</a> (rtdm_mutex_t *mutex, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *timeout_seq)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a mutex with timeout.  <a href="#ga0789968300701ba2a940f5fe8b1fd4d8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Global Lock across Scheduler Invocation</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp95e2e0328e2104d0bcadc0bf51aa8825"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdmsync.html#gabbaf52632d5dde7fa66e0b70d887493b">RTDM_EXECUTE_ATOMICALLY</a>(code_block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Execute code block atomically.  <a href="#gabbaf52632d5dde7fa66e0b70d887493b"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gabbaf52632d5dde7fa66e0b70d887493b"></a><!-- doxytag: member="rtdm_driver.h::RTDM_EXECUTE_ATOMICALLY" ref="gabbaf52632d5dde7fa66e0b70d887493b" args="(code_block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTDM_EXECUTE_ATOMICALLY</td>
          <td>(</td>
          <td class="paramtype">code_block&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                               \
        &lt;ENTER_ATOMIC_SECTION&gt;                  \
        code_block;                             \
        &lt;LEAVE_ATOMIC_SECTION&gt;                  \
}
</pre></div>
<p>Execute code block atomically. </p>
<p>Generally, it is illegal to suspend the current task by calling <a class="el" href="group__rtdmtask.html#gabfae53746165a83a75965b7b0f6710a0" title="Sleep a specified amount of time.">rtdm_task_sleep()</a>, <a class="el" href="group__rtdmsync.html#ga1c433b50c53d49d164b084751861e855" title="Wait on event occurrence.">rtdm_event_wait()</a>, etc. while holding a spinlock. In contrast, this macro allows to combine several operations including a potentially rescheduling call to an atomic code block with respect to other <a class="el" href="group__rtdmsync.html#gabbaf52632d5dde7fa66e0b70d887493b" title="Execute code block atomically.">RTDM_EXECUTE_ATOMICALLY()</a> blocks. The macro is a light-weight alternative for protecting code blocks via mutexes, and it can even be used to synchronise real-time and non-real-time contexts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>code_block</em>&nbsp;</td><td>Commands to be executed atomically</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It is not allowed to leave the code block explicitly by using <code>break</code>, <code>return</code>, <code>goto</code>, etc. This would leave the global lock held during the code block execution in an inconsistent state. Moreover, do not embed complex operations into the code bock. Consider that they will be executed under preemption lock with interrupts switched-off. Also note that invocation of rescheduling calls may break the atomicity until the task gains the CPU again.</dd></dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible, depends on functions called within <em>code_block</em>. </p>

</div>
</div>
<a class="anchor" id="ga65a4897268e15bda462b871976cb3909"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_get" ref="ga65a4897268e15bda462b871976cb3909" args="(lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_get</td>
          <td>(</td>
          <td class="paramtype">lock&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;rthal_spin_lock(lock)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Acquire lock from non-preemptible contexts. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga985473873f9e32af688fe8a23634693d"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_get_irqsave" ref="ga985473873f9e32af688fe8a23634693d" args="(lock, context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_get_irqsave</td>
          <td>(</td>
          <td class="paramtype">lock, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">context&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;rthal_spin_lock_irqsave(lock, context)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Acquire lock and disable preemption. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable to store the context in</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga6abf985ea7a0b13ec564cf0107fd8cba"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_init" ref="ga6abf985ea7a0b13ec564cf0107fd8cba" args="(lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_init</td>
          <td>(</td>
          <td class="paramtype">lock&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;rthal_spin_lock_init(lock)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dynamic lock initialisation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="gae03c387fcae8a55105dd31d7c008bbb4"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_irqrestore" ref="gae03c387fcae8a55105dd31d7c008bbb4" args="(context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_irqrestore</td>
          <td>(</td>
          <td class="paramtype">context&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;rthal_local_irq_restore(context)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restore preemption state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable which stored the context</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="ga3d563fc5def018f743c55c452e061758"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_irqsave" ref="ga3d563fc5def018f743c55c452e061758" args="(context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_irqsave</td>
          <td>(</td>
          <td class="paramtype">context&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;rthal_local_irq_save(context)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable preemption locally. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable to store the context in</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga963bdb01102d0076cd64f6bc72a347da"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_put" ref="ga963bdb01102d0076cd64f6bc72a347da" args="(lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_put</td>
          <td>(</td>
          <td class="paramtype">lock&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;rthal_spin_unlock(lock)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release lock without preemption restoration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga4f1f8e33baf33b162636f63dec61aebd"></a><!-- doxytag: member="rtdm_driver.h::rtdm_lock_put_irqrestore" ref="ga4f1f8e33baf33b162636f63dec61aebd" args="(lock, context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rtdm_lock_put_irqrestore</td>
          <td>(</td>
          <td class="paramtype">lock, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">context&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;rthal_spin_unlock_irqrestore(lock, context)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release lock and restore preemption state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Address of lock variable </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>name of local variable which stored the context</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gae18228df8c70c9da1f90f61b01e92501"></a><!-- doxytag: member="rtdm_driver.h::rtdm_selecttype" ref="gae18228df8c70c9da1f90f61b01e92501" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a3ddb0fbad9f52ad3646be2e5a6ba8b2b"></a><!-- doxytag: member="RTDM_SELECTTYPE_READ" ref="ggae18228df8c70c9da1f90f61b01e92501a3ddb0fbad9f52ad3646be2e5a6ba8b2b" args="" -->RTDM_SELECTTYPE_READ</em>&nbsp;</td><td>
<p>Select input data availability events. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a37819f609dee2b20852001e9b7ecd462"></a><!-- doxytag: member="RTDM_SELECTTYPE_WRITE" ref="ggae18228df8c70c9da1f90f61b01e92501a37819f609dee2b20852001e9b7ecd462" args="" -->RTDM_SELECTTYPE_WRITE</em>&nbsp;</td><td>
<p>Select ouput buffer availability events. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a2dd10c612a9e3c7e5134ee122ee3de74"></a><!-- doxytag: member="RTDM_SELECTTYPE_EXCEPT" ref="ggae18228df8c70c9da1f90f61b01e92501a2dd10c612a9e3c7e5134ee122ee3de74" args="" -->RTDM_SELECTTYPE_EXCEPT</em>&nbsp;</td><td>
<p>Select exceptional events. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga732fe3cf3370df0f296f06fc4ac7f925"></a><!-- doxytag: member="drvlib.c::rtdm_event_clear" ref="ga732fe3cf3370df0f296f06fc4ac7f925" args="(rtdm_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_clear </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear event state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
<a class="anchor" id="ga7b27d0206027a07958d4a09017e8a3fe"></a><!-- doxytag: member="drvlib.c::rtdm_event_destroy" ref="ga7b27d0206027a07958d4a09017e8a3fe" args="(rtdm_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_destroy </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy an event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="gaddf08d8ba5a44668bb360070a114fb19"></a><!-- doxytag: member="drvlib.c::rtdm_event_init" ref="gaddf08d8ba5a44668bb360070a114fb19" args="(rtdm_event_t *event, unsigned long pending)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_init </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>pending</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise an event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pending</em>&nbsp;</td><td>Non-zero if event shall be initialised as set, 0 otherwise</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="select_8c_source.html#l00067">xnselect_init()</a>, and <a class="el" href="synch_8c_source.html#l00106">xnsynch_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c9745d1db8e6de244a6c2690cbb8b22"></a><!-- doxytag: member="drvlib.c::rtdm_event_pulse" ref="ga7c9745d1db8e6de244a6c2690cbb8b22" args="(rtdm_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_pulse </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal an event occurrence to currently listening waiters. </p>
<p>This function wakes up all current waiters of the given event, but it does not change the event state. Subsequently callers of <a class="el" href="group__rtdmsync.html#ga1c433b50c53d49d164b084751861e855" title="Wait on event occurrence.">rtdm_event_wait()</a> or <a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait()</a> will therefore be blocked first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="ga839656c781d87069dd1bf1c84c38e9d9"></a><!-- doxytag: member="drvlib.c::rtdm_event_select_bind" ref="ga839656c781d87069dd1bf1c84c38e9d9" args="(rtdm_event_t *event, rtdm_selector_t *selector, enum rtdm_selecttype type, unsigned fd_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_event_select_bind </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_selector_t *&nbsp;</td>
          <td class="paramname"> <em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>fd_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind a selector to an event. </p>
<p>This functions binds the given selector to an event so that the former is notified when the event state changes. Typically the select binding handler will invoke this service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a> </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>selector</em>&nbsp;</td><td>Selector as passed to the select binding handler </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Type of the bound event as passed to the select binding handler </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fd_index</em>&nbsp;</td><td>File descriptor index as passed to the select binding handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EIDRM is returned if <em>event</em> has been destroyed.</li>
</ul>
<ul>
<li>-ENOMEM is returned if there is insufficient memory to establish the dynamic binding.</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>type</em> or <em>fd_index</em> are invalid.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="select_8c_source.html#l00107">xnselect_bind()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1217402b82034b26fe25c26f1e5b32c9"></a><!-- doxytag: member="drvlib.c::rtdm_event_signal" ref="ga1217402b82034b26fe25c26f1e5b32c9" args="(rtdm_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_event_signal </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Signal an event occurrence. </p>
<p>This function sets the given event and wakes up all current waiters. If no waiter is presently registered, the next call to <a class="el" href="group__rtdmsync.html#ga1c433b50c53d49d164b084751861e855" title="Wait on event occurrence.">rtdm_event_wait()</a> or <a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait()</a> will return immediately.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="pod_8h_source.html#l00251">xnpod_schedule()</a>, and <a class="el" href="synch_8c_source.html#l00850">xnsynch_flush()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf76f858a3951ca2e20d3b1e00afa17e0"></a><!-- doxytag: member="drvlib.c::rtdm_event_timedwait" ref="gaf76f858a3951ca2e20d3b1e00afa17e0" args="(rtdm_event_t *event, nanosecs_rel_t timeout, rtdm_toseq_t *timeout_seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_event_timedwait </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&nbsp;</td>
          <td class="paramname"> <em>timeout_seq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait on event occurrence with timeout. </p>
<p>This function waits or tests for the occurence of the given event, taking the provided timeout into account. On successful return, the event is reset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence.">rtdm_toseq_init()</a> or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task.">rtdm_task_unblock()</a>.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>event</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if a negative <em>timeout</em> (i.e., non-blocking operation) has been specified.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="include_2nucleus_2thread_8h_source.html#l00109">XNBREAK</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00108">XNRMID</a>, <a class="el" href="synch_8c_source.html#l00175">xnsynch_sleep_on()</a>, and <a class="el" href="include_2nucleus_2thread_8h_source.html#l00107">XNTIMEO</a>.</p>

<p>Referenced by <a class="el" href="drvlib_8c_source.html#l00898">rtdm_event_wait()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c433b50c53d49d164b084751861e855"></a><!-- doxytag: member="drvlib.c::rtdm_event_wait" ref="ga1c433b50c53d49d164b084751861e855" args="(rtdm_event_t *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_event_wait </td>
          <td>(</td>
          <td class="paramtype">rtdm_event_t *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait on event occurrence. </p>
<p>This is the light-weight version of <a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait()</a>, implying an infinite timeout.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>event</em>&nbsp;</td><td>Event handle as returned by <a class="el" href="group__rtdmsync.html#gaddf08d8ba5a44668bb360070a114fb19" title="Initialise an event.">rtdm_event_init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task.">rtdm_task_unblock()</a>.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>event</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="drvlib_8c_source.html#l00943">rtdm_event_timedwait()</a>.</p>

</div>
</div>
<a class="anchor" id="gad13170b569d0a4cdb46072e1e3a45527"></a><!-- doxytag: member="drvlib.c::rtdm_mutex_destroy" ref="gad13170b569d0a4cdb46072e1e3a45527" args="(rtdm_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a mutex. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5" title="Initialise a mutex.">rtdm_mutex_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="ga8d58a144bf71df7b38bb887d036cbbb5"></a><!-- doxytag: member="drvlib.c::rtdm_mutex_init" ref="ga8d58a144bf71df7b38bb887d036cbbb5" args="(rtdm_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_mutex_init </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise a mutex. </p>
<p>This function initalises a basic mutex with priority inversion protection. "Basic", as it does not allow a mutex owner to recursively lock the same mutex again.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="synch_8c_source.html#l00106">xnsynch_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga67c8f85c844df1aeed806e343a1b6437"></a><!-- doxytag: member="drvlib.c::rtdm_mutex_lock" ref="ga67c8f85c844df1aeed806e343a1b6437" args="(rtdm_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a mutex. </p>
<p>This is the light-weight version of <a class="el" href="group__rtdmsync.html#ga0789968300701ba2a940f5fe8b1fd4d8" title="Request a mutex with timeout.">rtdm_mutex_timedlock()</a>, implying an infinite timeout.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5" title="Initialise a mutex.">rtdm_mutex_init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EIDRM is returned if <em>mutex</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="drvlib_8c_source.html#l01521">rtdm_mutex_timedlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0789968300701ba2a940f5fe8b1fd4d8"></a><!-- doxytag: member="drvlib.c::rtdm_mutex_timedlock" ref="ga0789968300701ba2a940f5fe8b1fd4d8" args="(rtdm_mutex_t *mutex, nanosecs_rel_t timeout, rtdm_toseq_t *timeout_seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_mutex_timedlock </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&nbsp;</td>
          <td class="paramname"> <em>timeout_seq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a mutex with timeout. </p>
<p>This function tries to acquire the given mutex. If it is not available, the caller is blocked unless non-blocking operation was selected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5" title="Initialise a mutex.">rtdm_mutex_init()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence.">rtdm_toseq_init()</a> or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is negative and the semaphore value is currently not positive.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>mutex</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="include_2nucleus_2thread_8h_source.html#l00109">XNBREAK</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00108">XNRMID</a>, <a class="el" href="synch_8c_source.html#l00410">xnsynch_acquire()</a>, and <a class="el" href="include_2nucleus_2thread_8h_source.html#l00107">XNTIMEO</a>.</p>

<p>Referenced by <a class="el" href="drvlib_8c_source.html#l01480">rtdm_mutex_lock()</a>.</p>

</div>
</div>
<a class="anchor" id="gab40ed579324d8cc76387a0e06dd0f82a"></a><!-- doxytag: member="drvlib.c::rtdm_mutex_unlock" ref="gab40ed579324d8cc76387a0e06dd0f82a" args="(rtdm_mutex_t *mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">rtdm_mutex_t *&nbsp;</td>
          <td class="paramname"> <em>mutex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release a mutex. </p>
<p>This function releases the given mutex, waking up a potential waiter which was blocked upon <a class="el" href="group__rtdmsync.html#ga67c8f85c844df1aeed806e343a1b6437" title="Request a mutex.">rtdm_mutex_lock()</a> or <a class="el" href="group__rtdmsync.html#ga0789968300701ba2a940f5fe8b1fd4d8" title="Request a mutex with timeout.">rtdm_mutex_timedlock()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>mutex</em>&nbsp;</td><td>Mutex handle as returned by <a class="el" href="group__rtdmsync.html#ga8d58a144bf71df7b38bb887d036cbbb5" title="Initialise a mutex.">rtdm_mutex_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="ga0f7da4cec7713ed732ffd99040e219e2"></a><!-- doxytag: member="rtdm_driver.h::rtdm_select_bind" ref="ga0f7da4cec7713ed732ffd99040e219e2" args="(int fd, rtdm_selector_t *selector, enum rtdm_selecttype type, unsigned fd_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_select_bind </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_selector_t *&nbsp;</td>
          <td class="paramname"> <em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>fd_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind a selector to specified event types of a given file descriptor. </p>
<p><b>For internal use only.</b></p>
<p>
This function is invoked by higher RTOS layers implementing select-like services. It shall not be called directly by RTDM drivers.<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fd</em>&nbsp;</td><td>File descriptor to bind to </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>selector</em>&nbsp;</td><td>Selector object that shall be bound to the given event </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Event type the caller is interested in </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fd_index</em>&nbsp;</td><td>Index in the file descriptor set of the caller</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EBADF is returned if the file descriptor <em>fd</em> cannot be resolved.</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>type</em> or <em>fd_index</em> are invalid.</li>
</ul>
Environments:This service can be called from:<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
Rescheduling: never. </p>

<p>References <a class="el" href="rtdm__driver_8h_source.html#l00396">rtdm_dev_context::ops</a>, <a class="el" href="ksrc_2skins_2rtdm_2core_8c_source.html#l00073">rtdm_context_get()</a>, <a class="el" href="group__interdrv.html#gaa48a3e04fd74cec81691d5d2187d7ef2">rtdm_context_unlock()</a>, and <a class="el" href="rtdm__driver_8h_source.html#l00339">rtdm_operations::select_bind</a>.</p>

</div>
</div>
<a class="anchor" id="gaf16f45217e54201ff3f24753982c41f8"></a><!-- doxytag: member="drvlib.c::rtdm_sem_destroy" ref="gaf16f45217e54201ff3f24753982c41f8" args="(rtdm_sem_t *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_sem_destroy </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroy a semaphore. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d" title="Initialise a semaphore.">rtdm_sem_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

</div>
</div>
<a class="anchor" id="ga59da1b60b7279c1fc4355e2e0b2cc77c"></a><!-- doxytag: member="drvlib.c::rtdm_sem_down" ref="ga59da1b60b7279c1fc4355e2e0b2cc77c" args="(rtdm_sem_t *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_sem_down </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrement a semaphore. </p>
<p>This is the light-weight version of <a class="el" href="group__rtdmsync.html#ga8aadb120a93df5dfd717c5bac6d4c1a9" title="Decrement a semaphore with timeout.">rtdm_sem_timeddown()</a>, implying an infinite timeout.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d" title="Initialise a semaphore.">rtdm_sem_init()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task.">rtdm_task_unblock()</a>.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>sem</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="drvlib_8c_source.html#l01228">rtdm_sem_timeddown()</a>.</p>

</div>
</div>
<a class="anchor" id="gae1172824e463d7705ed3033e8aea133d"></a><!-- doxytag: member="drvlib.c::rtdm_sem_init" ref="gae1172824e463d7705ed3033e8aea133d" args="(rtdm_sem_t *sem, unsigned long value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_sem_init </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise a semaphore. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Initial value of the semaphore</td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="ksrc_2skins_2posix_2sem_8c_source.html#l00139">sem_init()</a>, <a class="el" href="select_8c_source.html#l00067">xnselect_init()</a>, and <a class="el" href="synch_8c_source.html#l00106">xnsynch_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf61f576b0ff06f99399b27725aef0ae1"></a><!-- doxytag: member="drvlib.c::rtdm_sem_select_bind" ref="gaf61f576b0ff06f99399b27725aef0ae1" args="(rtdm_sem_t *sem, rtdm_selector_t *selector, enum rtdm_selecttype type, unsigned fd_index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_sem_select_bind </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_selector_t *&nbsp;</td>
          <td class="paramname"> <em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__rtdmsync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>fd_index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind a selector to a semaphore. </p>
<p>This functions binds the given selector to the semaphore so that the former is notified when the semaphore state changes. Typically the select binding handler will invoke this service.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d" title="Initialise a semaphore.">rtdm_sem_init()</a> </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>selector</em>&nbsp;</td><td>Selector as passed to the select binding handler </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>Type of the bound event as passed to the select binding handler </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fd_index</em>&nbsp;</td><td>File descriptor index as passed to the select binding handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EIDRM is returned if <em>sem</em> has been destroyed.</li>
</ul>
<ul>
<li>-ENOMEM is returned if there is insufficient memory to establish the dynamic binding.</li>
</ul>
<ul>
<li>-EINVAL is returned if <em>type</em> or <em>fd_index</em> are invalid.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: never. </p>

<p>References <a class="el" href="select_8c_source.html#l00107">xnselect_bind()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8aadb120a93df5dfd717c5bac6d4c1a9"></a><!-- doxytag: member="drvlib.c::rtdm_sem_timeddown" ref="ga8aadb120a93df5dfd717c5bac6d4c1a9" args="(rtdm_sem_t *sem, nanosecs_rel_t timeout, rtdm_toseq_t *timeout_seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_sem_timeddown </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&nbsp;</td>
          <td class="paramname"> <em>timeout_seq</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decrement a semaphore with timeout. </p>
<p>This function tries to decrement the given semphore's value if it is positive on entry. If not, the caller is blocked unless non-blocking operation was selected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d" title="Initialise a semaphore.">rtdm_sem_init()</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Handle of a timeout sequence as returned by <a class="el" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence.">rtdm_toseq_init()</a> or NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<ul>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is negative and the semaphore value is currently not positive.</li>
</ul>
<ul>
<li>-EINTR is returned if calling task has been unblock by a signal or explicitly via <a class="el" href="group__rtdmtask.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task.">rtdm_task_unblock()</a>.</li>
</ul>
<ul>
<li>-EIDRM is returned if <em>sem</em> has been destroyed.</li>
</ul>
<ul>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="ksrc_2skins_2posix_2sem_8c_source.html#l00670">sem_timedwait()</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00109">XNBREAK</a>, <a class="el" href="include_2nucleus_2thread_8h_source.html#l00108">XNRMID</a>, <a class="el" href="synch_8c_source.html#l00175">xnsynch_sleep_on()</a>, and <a class="el" href="include_2nucleus_2thread_8h_source.html#l00107">XNTIMEO</a>.</p>

<p>Referenced by <a class="el" href="drvlib_8c_source.html#l01183">rtdm_sem_down()</a>.</p>

</div>
</div>
<a class="anchor" id="ga829dbd8c5709d798ed06947b27001fed"></a><!-- doxytag: member="drvlib.c::rtdm_sem_up" ref="ga829dbd8c5709d798ed06947b27001fed" args="(rtdm_sem_t *sem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_sem_up </td>
          <td>(</td>
          <td class="paramtype">rtdm_sem_t *&nbsp;</td>
          <td class="paramname"> <em>sem</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment a semaphore. </p>
<p>This function increments the given semphore's value, waking up a potential waiter which was blocked upon <a class="el" href="group__rtdmsync.html#ga59da1b60b7279c1fc4355e2e0b2cc77c" title="Decrement a semaphore.">rtdm_sem_down()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>sem</em>&nbsp;</td><td>Semaphore handle as returned by <a class="el" href="group__rtdmsync.html#gae1172824e463d7705ed3033e8aea133d" title="Initialise a semaphore.">rtdm_sem_init()</a></td></tr>
  </table>
  </dd>
</dl>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel module initialization/cleanup code</li>
<li>Interrupt service routine</li>
<li>Kernel-based task</li>
<li>User-space task (RT, non-RT)</li>
</ul>
<p>Rescheduling: possible. </p>

<p>References <a class="el" href="pod_8h_source.html#l00251">xnpod_schedule()</a>, and <a class="el" href="synch_8c_source.html#l00241">xnsynch_wakeup_one_sleeper()</a>.</p>

</div>
</div>
<a class="anchor" id="ga531ddf80690059302409f760bd7f14d4"></a><!-- doxytag: member="drvlib.c::rtdm_toseq_init" ref="ga531ddf80690059302409f760bd7f14d4" args="(rtdm_toseq_t *timeout_seq, nanosecs_rel_t timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_toseq_init </td>
          <td>(</td>
          <td class="paramtype">rtdm_toseq_t *&nbsp;</td>
          <td class="paramname"> <em>timeout_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialise a timeout sequence. </p>
<p>This service initialises a timeout sequence handle according to the given timeout value. Timeout sequences allow to maintain a continuous <em>timeout</em> across multiple calls of blocking synchronisation services. A typical application scenario is given below.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>timeout_seq</em>&nbsp;</td><td>Timeout sequence handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeout</em>&nbsp;</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values</td></tr>
  </table>
  </dd>
</dl>
<p>Application Scenario: </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> device_service_routine(...)
{
        rtdm_toseq_t timeout_seq;
        ...

        <a class="code" href="group__rtdmsync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence.">rtdm_toseq_init</a>(&amp;timeout_seq, timeout);
        ...
        <span class="keywordflow">while</span> (received &lt; requested) {
                ret = <a class="code" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait</a>(&amp;data_available, timeout, &amp;timeout_seq);
                <span class="keywordflow">if</span> (ret &lt; 0) <span class="comment">// including -ETIMEDOUT</span>
                        <span class="keywordflow">break</span>;

                <span class="comment">// receive some data</span>
                ...
        }
        ...
}
</pre></div><p> Using a timeout sequence in such a scenario avoids that the user-provided relative <code>timeout</code> is restarted on every call to <a class="el" href="group__rtdmsync.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout.">rtdm_event_timedwait()</a>, potentially causing an overall delay that is larger than specified by <code>timeout</code>. Moreover, all functions supporting timeout sequences also interpret special timeout values (infinite and non-blocking), disburdening the driver developer from handling them separately.</p>
<p>Environments:</p>
<p>This service can be called from:</p>
<ul>
<li>Kernel-based task</li>
<li>User-space task (RT)</li>
</ul>
<p>Rescheduling: never. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Oct 27 19:09:24 2009 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
