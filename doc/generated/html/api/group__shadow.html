<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: Real-time shadow services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Real-time shadow services.<br>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>]</small>
</h1>
<p>
Collaboration diagram for Real-time shadow services.:<center><table><tr><td><img src="group__shadow.png" border="0" alt="" usemap="#group____shadow_map">
<map name="group____shadow_map">
<area href="group__nucleus.html" shape="rect" coords="9,8,137,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Real-time shadow services. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="shadow_8c.html">shadow.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real-time shadow services. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shadow.html#ga16">xnshadow_harden</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Migrate a Linux task to the Xenomai domain.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shadow.html#ga17">xnshadow_relax</a> (int notify)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Switch a shadow thread back to the Linux domain.  <a href="#ga17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shadow.html#ga21">xnshadow_map</a> (xnthread_t *thread, xncompletion_t __user *u_completion)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a shadow thread context.  <a href="#ga21"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga16" doxytag="shadow.c::xnshadow_harden"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int xnshadow_harden           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Migrate a Linux task to the Xenomai domain. 
<p>
<p><b>For internal use only.</b></p>
<p>
This service causes the transition of "current" from the Linux domain to Xenomai. This is obtained by asking the gatekeeper to resume the shadow mated with "current" then triggering the rescheduling procedure in the Xenomai domain. The shadow will resume in the Xenomai domain as returning from schedule().<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>User-space thread operating in secondary (i.e. relaxed) mode.</li></ul>
<p>
Rescheduling: always. </p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga21" doxytag="shadow.c::xnshadow_map"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int xnshadow_map           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">xnthread_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>xncompletion_t __user *&nbsp;</td>
          <td class="mdname" nowrap> <em>u_completion</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a shadow thread context. 
<p>
<p><b>For internal use only.</b></p>
<p>
This call maps a nucleus thread to the "current" Linux task. The priority of the Linux task is set to the priority of the shadow thread bounded to the [1..MAX_RT_PRIO-1] range, and its scheduling policy is set to SCHED_FIFO. In other words, priority levels lower than 1 are mapped to 1, and levels higher than MAX_RT_PRIO-1 are mapped to the latter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the new shadow thread to be mapped to "current". This descriptor must have been previously initialized by a call to <a class="el" href="group__pod.html#ga31">xnpod_init_thread()</a>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Warning:</b></dt><dd>The thread must have been set the same magic number (i.e. xnthread_set_magic()) than the one used to register the skin it belongs to. Failing to do so might lead to unexpected results.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>u_completion</em>&nbsp;</td><td>is the address of an optional completion descriptor aimed at synchronizing our parent thread with us. If non-NULL, the information <a class="el" href="group__shadow.html#ga21">xnshadow_map()</a> will store into the completion block will be later used to wake up the parent thread when the current shadow has been initialized. In the latter case, the new shadow thread is left in a dormant state (XNDORMANT) after its creation, leading to the suspension of "current" in the Linux domain, only processing signals. Otherwise, the shadow thread is immediately started and "current" immediately resumes in the Xenomai domain from this service.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ERESTARTSYS is returned if the current Linux task has received a signal, thus preventing the final migration to the Xenomai domain (i.e. in order to process the signal in the Linux domain). This error should not be considered as fatal.</li></ul>
<p>
<ul>
<li>-EPERM is returned if the shadow thread has been killed before the current task had a chance to return to the caller. In such a case, the real-time mapping operation has failed globally, and no Xenomai resource remains attached to it.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Regular user-space process.</li></ul>
<p>
Rescheduling: always. </p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga17" doxytag="shadow.c::xnshadow_relax"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void xnshadow_relax           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>notify</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Switch a shadow thread back to the Linux domain. 
<p>
<p><b>For internal use only.</b></p>
<p>
This service yields the control of the running shadow back to Linux. This is obtained by suspending the shadow and scheduling a wake up call for the mated user task inside the Linux domain. The Linux task will resume on return from xnpod_suspend_thread() on behalf of the root thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>notify</em>&nbsp;</td><td>A boolean flag indicating whether threads monitored from secondary mode switches should be sent a SIGXCPU signal. For instance, some internal operations like task exit should not trigger such signal.</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>User-space thread operating in primary (i.e. harden) mode.</li></ul>
<p>
Rescheduling: always.<p>
<dl compact><dt><b>Note:</b></dt><dd>"current" is valid here since the shadow runs with the properties of the Linux task. </dd></dl>
</p>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Mar 28 17:21:34 2006 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
