<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Xenomai API: Real-time pod services.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.1 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Real-time pod services.<br>
<small>
[<a class="el" href="group__nucleus.html">Xenomai nucleus.</a>]</small>
</h1>
<p>
Collaboration diagram for Real-time pod services.:<center><table><tr><td><img src="group__pod.png" border="0" alt="" usemap="#group____pod_map">
<map name="group____pod_map">
<area href="group__nucleus.html" shape="rect" coords="5,5,147,32" alt="">
</map></td></tr></table></center>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Real-time pod services. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pod_8h.html">pod.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real-time pod interface header. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="pod_8c.html">pod.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real-time pod services. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnsched.html">xnsched</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheduling information structure.  <a href="structxnsched.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnpod.html">xnpod</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Real-time pod descriptor.  <a href="structxnpod.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g64b17299440834475d2c2b129ed9e6ab"></a><!-- doxytag: member="pod::xnsched_t" ref="g64b17299440834475d2c2b129ed9e6ab" args="" -->
typedef <a class="el" href="structxnsched.html">xnsched</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g64b17299440834475d2c2b129ed9e6ab">xnsched_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scheduling information structure. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g5b52d759f3994e2d16f37201f17273a6">xnpod_schedule_runnable</a> (xnthread_t *thread, int flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hidden rescheduling procedure.  <a href="#g5b52d759f3994e2d16f37201f17273a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gc98302b83af0576aec88d9568aea5336">xnpod_init</a> (<a class="el" href="structxnpod.html">xnpod_t</a> *pod, int loprio, int hiprio, xnflags_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a new pod.  <a href="#gc98302b83af0576aec88d9568aea5336"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g97f373e15e3fcfcbe410dd4cf4fb9c06">xnpod_start_timer</a> (u_long nstick, xnisr_t tickhandler)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the system timer.  <a href="#g97f373e15e3fcfcbe410dd4cf4fb9c06"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gcac8ce5804b9acf6daddaa61ec6952d9">xnpod_stop_timer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop the system timer.  <a href="#gcac8ce5804b9acf6daddaa61ec6952d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g887c74c47585349c5bd273edb0794f68">xnpod_reset_timer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset the system timer.  <a href="#g887c74c47585349c5bd273edb0794f68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g062220c5e732f846bac0e651fa5063cd">xnpod_shutdown</a> (int xtype)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown the current pod.  <a href="#g062220c5e732f846bac0e651fa5063cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g38595b2394a68d7f47e7a1b8c8dcf161">xnpod_init_thread</a> (xnthread_t *thread, const char *name, int prio, xnflags_t flags, unsigned stacksize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize a new thread.  <a href="#g38595b2394a68d7f47e7a1b8c8dcf161"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gdcc016219c648b211c3b13088d3e5eda">xnpod_start_thread</a> (xnthread_t *thread, xnflags_t mode, int imask, xnarch_cpumask_t affinity, void(*entry)(void *cookie), void *cookie)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initial start of a newly created thread.  <a href="#gdcc016219c648b211c3b13088d3e5eda"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g962fe6a3d5a31de0edd516fbfc1613fb">xnpod_restart_thread</a> (xnthread_t *thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Restart a thread.  <a href="#g962fe6a3d5a31de0edd516fbfc1613fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g8d0f583ac2b5fa24ad9285a62fdd444e">xnpod_delete_thread</a> (xnthread_t *thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a thread.  <a href="#g8d0f583ac2b5fa24ad9285a62fdd444e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">xnflags_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ge2da3ef48217a530aed35814d4954571">xnpod_set_thread_mode</a> (xnthread_t *thread, xnflags_t clrmask, xnflags_t setmask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change a thread's control mode.  <a href="#ge2da3ef48217a530aed35814d4954571"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gb0a50b55544dd14c58665ecd0a7bb079">xnpod_resume_thread</a> (xnthread_t *thread, xnflags_t mask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resume a thread.  <a href="#gb0a50b55544dd14c58665ecd0a7bb079"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga591b675aa433190b4cdf3056380718d">xnpod_unblock_thread</a> (xnthread_t *thread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unblock a thread.  <a href="#ga591b675aa433190b4cdf3056380718d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gaac7e281d1518b23d8ca03d5c5af26e9">xnpod_renice_thread</a> (xnthread_t *thread, int prio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the base priority of a thread.  <a href="#gaac7e281d1518b23d8ca03d5c5af26e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g8b9fba39f336b9bdec5bd96643bea5e2">xnpod_migrate_thread</a> (int cpu)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Migrate the current thread.  <a href="#g8b9fba39f336b9bdec5bd96643bea5e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gcfc17252c39d0d863e720143b238bebc">xnpod_rotate_readyq</a> (int prio)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotate a priority level in the ready queue.  <a href="#gcfc17252c39d0d863e720143b238bebc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g6186cd572382e52f580f0167cfae9af0">xnpod_schedule</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rescheduling procedure entry point.  <a href="#g6186cd572382e52f580f0167cfae9af0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g38178c63b6d4f3298959f2f4cef7728c">xnpod_dispatch_signals</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deliver pending asynchronous signals to the running thread.  <a href="#g38178c63b6d4f3298959f2f4cef7728c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gd03893d1272e0c2de6aee7028923482d">xnpod_activate_rr</a> (xnticks_t quantum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Globally activate the round-robin scheduling.  <a href="#gd03893d1272e0c2de6aee7028923482d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g0c8994ec826b6324ef3066ed219d6015">xnpod_deactivate_rr</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Globally deactivate the round-robin scheduling.  <a href="#g0c8994ec826b6324ef3066ed219d6015"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gbd0b2b348acbe6e6569f2e90ea29161d">xnpod_set_time</a> (xnticks_t newtime)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the nucleus idea of time.  <a href="#gbd0b2b348acbe6e6569f2e90ea29161d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g43c9d5f1cb127fd84cc7fb74c22b9879">xnpod_set_thread_periodic</a> (xnthread_t *thread, xnticks_t idate, xnticks_t period)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make a thread periodic.  <a href="#g43c9d5f1cb127fd84cc7fb74c22b9879"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g603ef7d673e880d9c8b54baf86bcca09">xnpod_wait_thread_period</a> (unsigned long *overruns_r)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the next periodic release point.  <a href="#g603ef7d673e880d9c8b54baf86bcca09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">xnticks_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gfc7d38f6951b313d8d1769268babe09d">xnpod_get_time</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the nucleus idea of time.  <a href="#gfc7d38f6951b313d8d1769268babe09d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g2e6555c717470151747f4785b640e125">xnpod_add_hook</a> (int type, void(*routine)(xnthread_t *))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Install a nucleus hook.  <a href="#g2e6555c717470151747f4785b640e125"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g8961af24aa3269ca203eac86d7c9b87b">xnpod_remove_hook</a> (int type, void(*routine)(xnthread_t *))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a nucleus hook.  <a href="#g8961af24aa3269ca203eac86d7c9b87b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#geda964adf7117f6c2c0ebfa5efb087c1">xnpod_suspend_thread</a> (xnthread_t *thread, xnflags_t mask, xnticks_t timeout, xnsynch_t *wchan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspend a thread.  <a href="#geda964adf7117f6c2c0ebfa5efb087c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gb350cf66627c484e24601f887ae7ab07">xnpod_welcome_thread</a> (xnthread_t *thread, int imask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread prologue.  <a href="#gb350cf66627c484e24601f887ae7ab07"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#g375b8042a5183326d0418519027d1dc7">xnpod_preempt_current_thread</a> (<a class="el" href="structxnsched.html">xnsched_t</a> *sched)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preempts the current thread.  <a href="#g375b8042a5183326d0418519027d1dc7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#ga8164ee9e3bed2594ae7c0021fc5388a">xnpod_trap_fault</a> (void *fltinfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default fault handler.  <a href="#ga8164ee9e3bed2594ae7c0021fc5388a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pod.html#gd8dcf50baf1e7d16c7dbfe4e609e1693">xnpod_announce_tick</a> (xnintr_t *intr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Announce a new clock tick.  <a href="#gd8dcf50baf1e7d16c7dbfe4e609e1693"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gd03893d1272e0c2de6aee7028923482d"></a><!-- doxytag: member="pod.h::xnpod_activate_rr" ref="gd03893d1272e0c2de6aee7028923482d" args="(xnticks_t quantum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_activate_rr           </td>
          <td>(</td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>quantum</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Globally activate the round-robin scheduling. 
<p>
This service activates the round-robin scheduling for all threads which have the XNRRB flag set in their status mask (see <a class="el" href="group__pod.html#ge2da3ef48217a530aed35814d4954571">xnpod_set_thread_mode()</a>). Each of them will run for the given time quantum, then preempted and moved to the end of its priority group in the ready queue. This process is repeated until the round-robin scheduling is disabled for those threads.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>quantum</em>&nbsp;</td><td>The time credit which will be given to each rr-enabled thread (in ticks).</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g2e6555c717470151747f4785b640e125"></a><!-- doxytag: member="pod.h::xnpod_add_hook" ref="g2e6555c717470151747f4785b640e125" args="(int type, void(*routine)(xnthread_t *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_add_hook           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(xnthread_t *)&nbsp;</td>
          <td class="paramname"> <em>routine</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Install a nucleus hook. 
<p>
The nucleus allows to register user-defined routines which get called whenever a specific scheduling event occurs. Multiple hooks can be chained for a single event type, and get called on a FIFO basis.<p>
The scheduling is locked while a hook is executing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Defines the kind of hook to install:</td></tr>
  </table>
</dl>
<ul>
<li>XNHOOK_THREAD_START: The user-defined routine will be called on behalf of the starter thread whenever a new thread starts. The descriptor address of the started thread is passed to the routine.</li></ul>
<p>
<ul>
<li>XNHOOK_THREAD_DELETE: The user-defined routine will be called on behalf of the deletor thread whenever a thread is deleted. The descriptor address of the deleted thread is passed to the routine.</li></ul>
<p>
<ul>
<li>XNHOOK_THREAD_SWITCH: The user-defined routine will be called on behalf of the resuming thread whenever a context switch takes place. The descriptor address of the thread which has been switched out is passed to the routine.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>routine</em>&nbsp;</td><td>The address of the user-supplied routine to call.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, one of the following error codes indicates the cause of the failure:</dd></dl>
<ul>
<li>-EINVAL is returned if type is incorrect.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if not enough memory is available from the system heap to add the new hook.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="gd8dcf50baf1e7d16c7dbfe4e609e1693"></a><!-- doxytag: member="pod.c::xnpod_announce_tick" ref="gd8dcf50baf1e7d16c7dbfe4e609e1693" args="(xnintr_t *intr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_announce_tick           </td>
          <td>(</td>
          <td class="paramtype">xnintr_t *&nbsp;</td>
          <td class="paramname"> <em>intr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Announce a new clock tick. 
<p>
This is the default service routine for clock ticks which performs the necessary housekeeping chores for time-related services managed by the nucleus. In a way or another, this routine must be called to announce each incoming clock tick to the nucleus.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>intr</em>&nbsp;</td><td>The descriptor address of the interrupt object associated to the timer interrupt.</td></tr>
  </table>
</dl>
Side-effect: Since this routine manages the round-robin scheduling, the running thread (which has been preempted by the timer interrupt) can be switched out as a result of its time credit being exhausted. The nucleus always calls the rescheduling procedure after the outer interrupt has been processed.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>XN_ISR_HANDLED|XN_ISR_NOENABLE is always returned.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Interrupt service routine, must be called with interrupts off.</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g0c8994ec826b6324ef3066ed219d6015"></a><!-- doxytag: member="pod.h::xnpod_deactivate_rr" ref="g0c8994ec826b6324ef3066ed219d6015" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_deactivate_rr           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Globally deactivate the round-robin scheduling. 
<p>
This service deactivates the round-robin scheduling for all threads which have the XNRRB flag set in their status mask (see <a class="el" href="group__pod.html#ge2da3ef48217a530aed35814d4954571">xnpod_set_thread_mode()</a>).<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g8d0f583ac2b5fa24ad9285a62fdd444e"></a><!-- doxytag: member="pod.h::xnpod_delete_thread" ref="g8d0f583ac2b5fa24ad9285a62fdd444e" args="(xnthread_t *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_delete_thread           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a thread. 
<p>
Terminates a thread and releases all the nucleus resources it currently holds. A thread exists in the system since <a class="el" href="group__pod.html#g38595b2394a68d7f47e7a1b8c8dcf161">xnpod_init_thread()</a> has been called to create it, so this service must be called in order to destroy it afterwards.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the terminated thread.</td></tr>
  </table>
</dl>
The DELETE hooks are called on behalf of the calling context (if any). The information stored in the thread control block remains valid until all hooks have been called.<p>
Self-terminating a thread is allowed. In such a case, this service does not return to the caller.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible if the current thread self-deletes. 
</div>
</div><p>
<a class="anchor" name="g38178c63b6d4f3298959f2f4cef7728c"></a><!-- doxytag: member="pod.h::xnpod_dispatch_signals" ref="g38178c63b6d4f3298959f2f4cef7728c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_dispatch_signals           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deliver pending asynchronous signals to the running thread. 
<p>
<p><b>For internal use only.</b></p>
<p>
This internal routine checks for the presence of asynchronous signals directed to the running thread, and attempts to start the asynchronous service routine (ASR) if any. Called with nklock locked, interrupts off. </p>

</div>
</div><p>
<a class="anchor" name="gfc7d38f6951b313d8d1769268babe09d"></a><!-- doxytag: member="pod.h::xnpod_get_time" ref="gfc7d38f6951b313d8d1769268babe09d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnticks_t xnpod_get_time           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the nucleus idea of time. 
<p>
This service gets the nucleus (external) clock time.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current nucleus time (in ticks) if the underlying time source runs in periodic mode, or the system time (converted to nanoseconds) as maintained by the CPU if aperiodic mode is in effect, or no timer is running.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="gc98302b83af0576aec88d9568aea5336"></a><!-- doxytag: member="pod.h::xnpod_init" ref="gc98302b83af0576aec88d9568aea5336" args="(xnpod_t *pod, int loprio, int hiprio, xnflags_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxnpod.html">xnpod_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>loprio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>hiprio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a new pod. 
<p>
Initializes a new pod which can subsequently be used to start real-time activities. Once a pod is active, real-time APIs can be stacked over. There can only be a single pod active in the host environment. Such environment can be confined to a process (e.g. simulator or UVM), or expand machine-wide (e.g. Adeos).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pod</em>&nbsp;</td><td>The address of a pod descriptor the nucleus will use to store the pod-specific data. This descriptor must always be valid while the pod is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>loprio</em>&nbsp;</td><td>The value of the lowest priority level which is valid for threads created on behalf of this pod.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hiprio</em>&nbsp;</td><td>The value of the highest priority level which is valid for threads created on behalf of this pod.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A set of creation flags affecting the operation. The only defined flag is XNREUSE, which tells the nucleus that a pre-existing pod exhibiting the same properties as the one which is being registered may be reused. In such a case, the call returns successfully, keeping the active pod unmodified.</td></tr>
  </table>
</dl>
loprio may be numerically greater than hiprio if the client real-time interface exhibits a reverse priority scheme. For instance, some APIs may define a range like loprio=255, hiprio=0 specifying that thread priorities increase as the priority level decreases numerically.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if a pod already exists. As a special exception, if the Xenomai pod is currently loaded with no active attachment onto it, it is forcibly unloaded and replaced by the new pod.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if the memory manager fails to initialize.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization code</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>No initialization code called by this routine may refer to the global "nkpod" pointer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g38595b2394a68d7f47e7a1b8c8dcf161"></a><!-- doxytag: member="pod.h::xnpod_init_thread" ref="g38595b2394a68d7f47e7a1b8c8dcf161" args="(xnthread_t *thread, const char *name, int prio, xnflags_t flags, unsigned stacksize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_init_thread           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>stacksize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a new thread. 
<p>
Initializes a new thread attached to the active pod. The thread is left in an innocuous state until it is actually started by <a class="el" href="group__pod.html#gdcc016219c648b211c3b13088d3e5eda">xnpod_start_thread()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The address of a thread descriptor the nucleus will use to store the thread-specific data. This descriptor must always be valid while the thread is active therefore it must be allocated in permanent memory.</td></tr>
  </table>
</dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Some architectures may require the descriptor to be properly aligned in memory; this is an additional reason for descriptors not to be laid in the program stack where alignement constraints might not always be satisfied.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>An ASCII string standing for the symbolic name of the thread. This name is copied to a safe place into the thread descriptor. This name might be used in various situations by the nucleus for issuing human-readable diagnostic messages, so it is usually a good idea to provide a sensible value here. The simulator even uses this name intensively to identify threads in the debugging GUI it provides. However, passing NULL here is always legal and means "anonymous".</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prio</em>&nbsp;</td><td>The base priority of the new thread. This value must range from [loprio .. hiprio] (inclusive) as specified when calling the <a class="el" href="group__pod.html#gc98302b83af0576aec88d9568aea5336">xnpod_init()</a> service.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A set of creation flags affecting the operation. The following flags can be part of this bitmask, each of them affecting the nucleus behaviour regarding the created thread:</td></tr>
  </table>
</dl>
<ul>
<li>XNSUSP creates the thread in a suspended state. In such a case, the thread will have to be explicitely resumed using the <a class="el" href="group__pod.html#gb0a50b55544dd14c58665ecd0a7bb079">xnpod_resume_thread()</a> service for its execution to actually begin, additionally to issuing <a class="el" href="group__pod.html#gdcc016219c648b211c3b13088d3e5eda">xnpod_start_thread()</a> for it. This flag can also be specified when invoking <a class="el" href="group__pod.html#gdcc016219c648b211c3b13088d3e5eda">xnpod_start_thread()</a> as a starting mode.</li></ul>
<p>
<ul>
<li>XNFPU (enable FPU) tells the nucleus that the new thread will use the floating-point unit. In such a case, the nucleus will handle the FPU context save/restore ops upon thread switches at the expense of a few additional cycles per context switch. By default, a thread is not expected to use the FPU. This flag is simply ignored when the nucleus runs on behalf of a userspace-based real-time control layer since the FPU management is always active if present.</li></ul>
<p>
<ul>
<li>XNINVPS tells the nucleus that the new thread will use an inverted priority scale with respect to the one enforced by the current pod. This means that the calling skin will still have to normalize the priority levels passed to the nucleus routines so that they conform to the pod's priority scale, but the nucleus will automatically rescale those values when displaying the priority information (e.g. /proc/xenomai/sched output). This bit must not be confused with the XNRPRIO bit, which is internally set by the nucleus during pod initialization when the low priority level is found to be numerically higher than the high priority bound. Having the XNINVPS bit set for a thread running on a pod with XNRPRIO unset means that the skin emulates a decreasing priority scale using the pod's increasing priority scale. This is typically the case for skins running over the core pod (see <a class="el" href="include_2nucleus_2core_8h-source.html">include/nucleus/core.h</a>).</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stacksize</em>&nbsp;</td><td>The size of the stack (in bytes) for the new thread. If zero is passed, the nucleus will use a reasonable pre-defined size depending on the underlying real-time control layer.</td></tr>
  </table>
</dl>
After creation, the new thread can be set a magic cookie by skins using xnthread_set_magic() to unambiguously identify threads created in their realm. This value will be copied as-is to the <em>magic</em> field of the thread struct. 0 is a conventional value for "no magic".<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, one of the following error codes indicates the cause of the failure:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>flags</em> has invalid bits set.</li></ul>
<p>
<ul>
<li>-ENOMEM is returned if not enough memory is available from the system heap to create the new thread's stack.</li></ul>
<p>
Side-effect: This routine does not call the rescheduling procedure.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g8b9fba39f336b9bdec5bd96643bea5e2"></a><!-- doxytag: member="pod.h::xnpod_migrate_thread" ref="g8b9fba39f336b9bdec5bd96643bea5e2" args="(int cpu)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_migrate_thread           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cpu</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Migrate the current thread. 
<p>
This call makes the current thread migrate to another CPU if its affinity allows it.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu</em>&nbsp;</td><td>The destination CPU.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if the thread could migrate ; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EPERM</em>&nbsp;</td><td>if the calling context is asynchronous, or the current thread affinity forbids this migration ; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EBUSY</em>&nbsp;</td><td>if the scheduler is locked. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g375b8042a5183326d0418519027d1dc7"></a><!-- doxytag: member="pod.c::xnpod_preempt_current_thread" ref="g375b8042a5183326d0418519027d1dc7" args="(xnsched_t *sched)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_preempt_current_thread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxnsched.html">xnsched_t</a> *&nbsp;</td>
          <td class="paramname"> <em>sched</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Preempts the current thread. 
<p>
<p><b>For internal use only.</b></p>
<p>
Preempts the running thread (because a higher priority thread has just been readied). The thread is re-inserted to the front of its priority group in the ready thread queue. Must be called with nklock locked, interrupts off. </p>

</div>
</div><p>
<a class="anchor" name="g8961af24aa3269ca203eac86d7c9b87b"></a><!-- doxytag: member="pod.h::xnpod_remove_hook" ref="g8961af24aa3269ca203eac86d7c9b87b" args="(int type, void(*routine)(xnthread_t *))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_remove_hook           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(xnthread_t *)&nbsp;</td>
          <td class="paramname"> <em>routine</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a nucleus hook. 
<p>
This service removes a nucleus hook previously registered using <a class="el" href="group__pod.html#g2e6555c717470151747f4785b640e125">xnpod_add_hook()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Defines the kind of hook to remove among XNHOOK_THREAD_START, XNHOOK_THREAD_DELETE and XNHOOK_THREAD_SWITCH.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>routine</em>&nbsp;</td><td>The address of the user-supplied routine to remove.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise, -EINVAL is returned if type is incorrect or if the routine has never been registered before.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="gaac7e281d1518b23d8ca03d5c5af26e9"></a><!-- doxytag: member="pod.h::xnpod_renice_thread" ref="gaac7e281d1518b23d8ca03d5c5af26e9" args="(xnthread_t *thread, int prio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_renice_thread           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prio</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change the base priority of a thread. 
<p>
Changes the base priority of a thread. If the reniced thread is currently blocked, waiting in priority-pending mode (XNSYNCH_PRIO) for a synchronization object to be signaled, the nucleus will attempt to reorder the object's wait queue so that it reflects the new sleeper's priority, unless the XNSYNCH_DREORD flag has been set for the pended object.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prio</em>&nbsp;</td><td>The new thread priority.</td></tr>
  </table>
</dl>
It is absolutely required to use this service to change a thread priority, in order to have all the needed housekeeping chores correctly performed. i.e. Do *not* change the thread.cprio field by hand, unless the thread is known to be in an innocuous state (e.g. dormant).<p>
Side-effects:<p>
<ul>
<li>This service does not call the rescheduling procedure but may affect the ready queue.</li></ul>
<p>
<ul>
<li>Assigning the same priority to a running or ready thread moves it to the end of the ready queue, thus causing a manual round-robin.</li></ul>
<p>
<ul>
<li>If the reniced thread is a user-space shadow, propagate the request to the mated Linux task.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g887c74c47585349c5bd273edb0794f68"></a><!-- doxytag: member="pod.h::xnpod_reset_timer" ref="g887c74c47585349c5bd273edb0794f68" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_reset_timer           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset the system timer. 
<p>
Reset the system timer to its default setup. The default setup data are obtained, by order of priority, from:<p>
<ul>
<li>the "tick_arg" module parameter when passed to the nucleus. Zero means aperiodic timing, any other value is used as the constant period to use for undergoing the periodic timing mode.</li></ul>
<p>
<ul>
<li>or, the value of the CONFIG_XENO_OPT_TIMING_PERIOD configuration parameter if CONFIG_XENO_OPT_TIMING_PERIODIC is also set. If the latter is unset, the aperiodic mode will be used.</li></ul>
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if the timer has already been set with incompatible requirements (different mode, different period if periodic, or non-default tick handler). <a class="el" href="group__pod.html#gcac8ce5804b9acf6daddaa61ec6952d9">xnpod_stop_timer()</a> must be issued before <a class="el" href="group__pod.html#g887c74c47585349c5bd273edb0794f68">xnpod_reset_timer()</a> is called again.</li></ul>
<p>
<ul>
<li>-ENODEV is returned if the underlying architecture does not support the requested periodic timing.</li></ul>
<p>
<ul>
<li>-ENOSYS is returned if no active pod exists.</li></ul>
<p>
Side-effect: A host timing service is started in order to relay the canonical periodical tick to the underlying architecture, regardless of the frequency used for Xenomai's system tick. This routine does not call the rescheduling procedure.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>User-space task in secondary mode</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g962fe6a3d5a31de0edd516fbfc1613fb"></a><!-- doxytag: member="pod.h::xnpod_restart_thread" ref="g962fe6a3d5a31de0edd516fbfc1613fb" args="(xnthread_t *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_restart_thread           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restart a thread. 
<p>
Restarts a previously started thread. The thread is first terminated then respawned using the same information that prevailed when it was first started, including the mode bits and interrupt mask initially passed to the <a class="el" href="group__pod.html#gdcc016219c648b211c3b13088d3e5eda">xnpod_start_thread()</a> service. As a consequence of this call, the thread entry point is rerun.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread which must have been previously started by the <a class="el" href="group__pod.html#gdcc016219c648b211c3b13088d3e5eda">xnpod_start_thread()</a> service.</td></tr>
  </table>
</dl>
Self-restarting a thread is allowed. However, restarting the root thread is not.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="gb0a50b55544dd14c58665ecd0a7bb079"></a><!-- doxytag: member="pod.h::xnpod_resume_thread" ref="gb0a50b55544dd14c58665ecd0a7bb079" args="(xnthread_t *thread, xnflags_t mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_resume_thread           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resume a thread. 
<p>
Resumes the execution of a thread previously suspended by one or more calls to xnpod_suspend_thread(). This call removes a suspensive condition affecting the target thread. When all suspensive conditions are gone, the thread is left in a READY state at which point it becomes eligible anew for scheduling.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the resumed thread.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The suspension mask specifying the suspensive condition to remove from the thread's wait mask. Possible values usable by the caller are:</td></tr>
  </table>
</dl>
<ul>
<li>XNSUSP. This flag removes the explicit suspension condition. This condition might be additive to the XNPEND condition.</li></ul>
<p>
<ul>
<li>XNDELAY. This flag removes the counted delay wait condition.</li></ul>
<p>
<ul>
<li>XNPEND. This flag removes the resource wait condition. If a watchdog is armed, it is automatically disarmed by this call. Unlike the two previous conditions, only the current thread can set this condition for itself, i.e. no thread can force another one to pend on a resource.</li></ul>
<p>
When the thread is eventually resumed by one or more calls to <a class="el" href="group__pod.html#gb0a50b55544dd14c58665ecd0a7bb079">xnpod_resume_thread()</a>, the caller of xnpod_suspend_thread() in the awakened thread that suspended itself should check for the following bits in its own information mask to determine what caused its wake up:<p>
<ul>
<li>XNRMID means that the caller must assume that the pended synchronization object has been destroyed (see <a class="el" href="group__synch.html#g8721485ec686002925449e6181cea897">xnsynch_flush()</a>).</li></ul>
<p>
<ul>
<li>XNTIMEO means that the delay elapsed, or the watchdog went off before the corresponding synchronization object was signaled.</li></ul>
<p>
<ul>
<li>XNBREAK means that the wait has been forcibly broken by a call to <a class="el" href="group__pod.html#ga591b675aa433190b4cdf3056380718d">xnpod_unblock_thread()</a>.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="gcfc17252c39d0d863e720143b238bebc"></a><!-- doxytag: member="pod.h::xnpod_rotate_readyq" ref="gcfc17252c39d0d863e720143b238bebc" args="(int prio)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_rotate_readyq           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>prio</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotate a priority level in the ready queue. 
<p>
The thread at the head of the ready queue of the given priority level is moved to the end of this queue. Therefore, the execution of threads having the same priority is switched. Round-robin scheduling policies may be implemented by periodically issuing this call in a given period of time. It should be noted that the nucleus already provides a built-in round-robin mode though (see <a class="el" href="group__pod.html#gd03893d1272e0c2de6aee7028923482d">xnpod_activate_rr()</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prio</em>&nbsp;</td><td>The priority level to rotate. if XNPOD_RUNPRIO is given, the running thread priority is used to rotate the queue.</td></tr>
  </table>
</dl>
The priority level which is considered is always the base priority of a thread, not the possibly PIP-boosted current priority value. Specifying a priority level with no thread on it is harmless, and will simply lead to a null-effect.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g6186cd572382e52f580f0167cfae9af0"></a><!-- doxytag: member="pod.h::xnpod_schedule" ref="g6186cd572382e52f580f0167cfae9af0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_schedule           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rescheduling procedure entry point. 
<p>
This is the central rescheduling routine which should be called to validate and apply changes which have previously been made to the nucleus scheduling state, such as suspending, resuming or changing the priority of threads. This call first determines if a thread switch should take place, and performs it as needed. <a class="el" href="group__pod.html#g6186cd572382e52f580f0167cfae9af0">xnpod_schedule()</a> actually switches threads if:<p>
<ul>
<li>the running thread has been blocked or deleted.</li><li>or, the running thread has a lower priority than the first ready to run thread.</li><li>or, the running thread does not lead no more the ready threads (round-robin).</li></ul>
<p>
The nucleus implements a lazy rescheduling scheme so that most of the services affecting the threads state MUST be followed by a call to the rescheduling procedure for the new scheduling state to be applied. In other words, multiple changes on the scheduler state can be done in a row, waking threads up, blocking others, without being immediately translated into the corresponding context switches, like it would be necessary would it appear that a higher priority thread than the current one became runnable for instance. When all changes have been applied, the rescheduling procedure is then called to consider those changes, and possibly replace the current thread by another one.<p>
As a notable exception to the previous principle however, every action which ends up suspending or deleting the current thread begets an immediate call to the rescheduling procedure on behalf of the service causing the state transition. For instance, self-suspension, self-destruction, or sleeping on a synchronization object automatically leads to a call to the rescheduling procedure, therefore the caller does not need to explicitely issue <a class="el" href="group__pod.html#g6186cd572382e52f580f0167cfae9af0">xnpod_schedule()</a> after such operations.<p>
The rescheduling procedure always leads to a null-effect if it is called on behalf of an ISR or callout. Any outstanding scheduler lock held by the outgoing thread will be restored when the thread is scheduled back in.<p>
Calling this procedure with no applicable context switch pending is harmless and simply leads to a null-effect.<p>
Side-effects:<p>
<ul>
<li>If an asynchronous service routine exists, the pending asynchronous signals are delivered to a resuming thread or on behalf of the caller before it returns from the procedure if no context switch has taken place. This behaviour can be disabled by setting the XNASDI flag in the thread's status mask by calling <a class="el" href="group__pod.html#ge2da3ef48217a530aed35814d4954571">xnpod_set_thread_mode()</a>.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine, although this leads to a no-op.</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The switch hooks are called on behalf of the resuming thread. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5b52d759f3994e2d16f37201f17273a6"></a><!-- doxytag: member="pod.h::xnpod_schedule_runnable" ref="g5b52d759f3994e2d16f37201f17273a6" args="(xnthread_t *thread, int flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_schedule_runnable           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hidden rescheduling procedure. 
<p>
<p><b>For internal use only.</b></p>
<p>
This internal routine should NEVER be used directly by the client interfaces. It reinserts the given thread into the ready queue then switches to the highest priority runnable thread. It must be called with nklock locked, interrupts off.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the thread to reinsert into the ready queue.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>A bitmask composed as follows:</td></tr>
  </table>
</dl>
<ul>
<li>XNPOD_SCHEDLIFO causes the target thread to be inserted at front of its priority group in the ready queue. Otherwise, the FIFO ordering is applied.</li></ul>
<p>
<ul>
<li>XNPOD_NOSWITCH reorders the ready queue without switching contexts. This feature is used to preserve the atomicity of some operations. </li></ul>
</p>

</div>
</div><p>
<a class="anchor" name="ge2da3ef48217a530aed35814d4954571"></a><!-- doxytag: member="pod.h::xnpod_set_thread_mode" ref="ge2da3ef48217a530aed35814d4954571" args="(xnthread_t *thread, xnflags_t clrmask, xnflags_t setmask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnflags_t xnpod_set_thread_mode           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>setmask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Change a thread's control mode. 
<p>
Change the control mode of a given thread. The control mode affects the behaviour of the nucleus regarding the specified thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clrmask</em>&nbsp;</td><td>Clears the corresponding bits from the control field before setmask is applied. The scheduler lock held by the current thread can be forcibly released by passing the XNLOCK bit in this mask. In this case, the lock nesting count is also reset to zero.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>setmask</em>&nbsp;</td><td>The new thread mode. The following flags can be part of this bitmask, each of them affecting the nucleus behaviour regarding the thread:</td></tr>
  </table>
</dl>
<ul>
<li>XNLOCK causes the thread to lock the scheduler. The target thread will have to call the xnpod_unlock_sched() service to unlock the scheduler or clear the XNLOCK bit forcibly using this service. A non-preemptible thread may still block, in which case, the lock is reasserted when the thread is scheduled back in.</li></ul>
<p>
<ul>
<li>XNRRB causes the thread to be marked as undergoing the round-robin scheduling policy. The contents of the thread.rrperiod field determines the time quantum (in ticks) allowed for its next slice. If the thread is already undergoing the round-robin scheduling policy at the time this service is called, the time quantum remains unchanged.</li></ul>
<p>
<ul>
<li>XNASDI disables the asynchronous signal handling for this thread. See <a class="el" href="group__pod.html#g6186cd572382e52f580f0167cfae9af0">xnpod_schedule()</a> for more on this.</li></ul>
<p>
<ul>
<li>XNSHIELD enables the interrupt shield for the current user-space task. When engaged, the interrupt shield protects the shadow task running in secondary mode from any preemption by the regular Linux interrupt handlers, without delaying in any way Xenomai's interrupt handling. The shield is operated on a per-task basis at each context switch, depending on the setting of this flag. This feature is only available if the CONFIG_XENO_OPT_ISHIELD option has been enabled at configuration time; otherwise, this flag is simply ignored.</li></ul>
<p>
<ul>
<li>XNRPIOFF disables thread priority coupling between Xenomai and Linux schedulers. This bit prevents the root Linux thread from inheriting the priority of the running shadow Xenomai thread. Use CONFIG_XENO_OPT_RPIOFF to globally disable priority coupling.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel-based task</li><li>User-space task in primary mode.</li></ul>
<p>
Rescheduling: never, therefore, the caller should reschedule if XNLOCK has been passed into <em>clrmask</em>. 
</div>
</div><p>
<a class="anchor" name="g43c9d5f1cb127fd84cc7fb74c22b9879"></a><!-- doxytag: member="pod.h::xnpod_set_thread_periodic" ref="g43c9d5f1cb127fd84cc7fb74c22b9879" args="(xnthread_t *thread, xnticks_t idate, xnticks_t period)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_set_thread_periodic           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>idate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>period</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make a thread periodic. 
<p>
Make a thread periodic by programming its first release point and its period in the processor time line. Subsequent calls to <a class="el" href="group__pod.html#g603ef7d673e880d9c8b54baf86bcca09">xnpod_wait_thread_period()</a> will delay the thread until the next periodic release point in the processor timeline is reached.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread. This thread is immediately delayed until the first periodic release point is reached.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>idate</em>&nbsp;</td><td>The initial (absolute) date of the first release point, expressed in clock ticks (see note). The affected thread will be delayed until this point is reached. If <em>idate</em> is equal to XN_INFINITE, the current system date is used, and no initial delay takes place.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>period</em>&nbsp;</td><td>The period of the thread, expressed in clock ticks (see note). As a side-effect, passing XN_INFINITE attempts to stop the thread's periodic timer; in the latter case, the routine always exits succesfully, regardless of the previous state of this timer.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned <em>idate</em> is different from XN_INFINITE and represents a date in the past.</li></ul>
<p>
<ul>
<li>-EWOULDBLOCK is returned if the system timer has not been started using <a class="el" href="group__pod.html#g97f373e15e3fcfcbe410dd4cf4fb9c06">xnpod_start_timer()</a>.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if <em>period</em> is different from XN_INFINITE but shorter than the scheduling latency value for the target system, as available from /proc/xenomai/latency.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible if the operation affects the current thread and <em>idate</em> has not elapsed yet.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__pod.html#g97f373e15e3fcfcbe410dd4cf4fb9c06">xnpod_start_timer()</a> service. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbd0b2b348acbe6e6569f2e90ea29161d"></a><!-- doxytag: member="pod.h::xnpod_set_time" ref="gbd0b2b348acbe6e6569f2e90ea29161d" args="(xnticks_t newtime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_set_time           </td>
          <td>(</td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>newtime</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the nucleus idea of time. 
<p>
The nucleus tracks the current time as a monotonously increasing count of ticks announced by the timer source since the epoch. The epoch is initially the same as the underlying architecture system time. This service changes the epoch. Running timers use a different time base thus are not affected by this operation.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g062220c5e732f846bac0e651fa5063cd"></a><!-- doxytag: member="pod.h::xnpod_shutdown" ref="g062220c5e732f846bac0e651fa5063cd" args="(int xtype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_shutdown           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>xtype</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shutdown the current pod. 
<p>
Forcibly shutdowns the active pod. All existing nucleus threads (but the root one) are terminated, and the system heap is freed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xtype</em>&nbsp;</td><td>An exit code passed to the host environment who started the nucleus. Zero is always interpreted as a successful return.</td></tr>
  </table>
</dl>
The nucleus never calls this routine directly. Skins should provide their own shutdown handlers which end up calling <a class="el" href="group__pod.html#g062220c5e732f846bac0e651fa5063cd">xnpod_shutdown()</a> after their own housekeeping chores have been carried out.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="gdcc016219c648b211c3b13088d3e5eda"></a><!-- doxytag: member="pod.h::xnpod_start_thread" ref="gdcc016219c648b211c3b13088d3e5eda" args="(xnthread_t *thread, xnflags_t mode, int imask, xnarch_cpumask_t affinity, void(*entry)(void *cookie), void *cookie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_start_thread           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>imask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnarch_cpumask_t&nbsp;</td>
          <td class="paramname"> <em>affinity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *cookie)&nbsp;</td>
          <td class="paramname"> <em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initial start of a newly created thread. 
<p>
Starts a (newly) created thread, scheduling it for the first time. This call releases the target thread from the XNDORMANT state. This service also sets the initial mode and interrupt mask for the new thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the affected thread which must have been previously initialized by the <a class="el" href="group__pod.html#g38595b2394a68d7f47e7a1b8c8dcf161">xnpod_init_thread()</a> service.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The initial thread mode. The following flags can be part of this bitmask, each of them affecting the nucleus behaviour regarding the started thread:</td></tr>
  </table>
</dl>
<ul>
<li>XNLOCK causes the thread to lock the scheduler when it starts. The target thread will have to call the xnpod_unlock_sched() service to unlock the scheduler. A non-preemptible thread may still block, in which case, the lock is reasserted when the thread is scheduled back in.</li></ul>
<p>
<ul>
<li>XNRRB causes the thread to be marked as undergoing the round-robin scheduling policy at startup. The contents of the thread.rrperiod field determines the time quantum (in ticks) allowed for its next slice.</li></ul>
<p>
<ul>
<li>XNASDI disables the asynchronous signal handling for this thread. See <a class="el" href="group__pod.html#g6186cd572382e52f580f0167cfae9af0">xnpod_schedule()</a> for more on this.</li></ul>
<p>
<ul>
<li>XNSUSP makes the thread start in a suspended state. In such a case, the thread will have to be explicitely resumed using the <a class="el" href="group__pod.html#gb0a50b55544dd14c58665ecd0a7bb079">xnpod_resume_thread()</a> service for its execution to actually begin.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>imask</em>&nbsp;</td><td>The interrupt mask that should be asserted when the thread starts. The processor interrupt state will be set to the given value when the thread starts running. The interpretation of this value might be different across real-time layers, but a non-zero value should always mark an interrupt masking in effect (e.g. cli()). Conversely, a zero value should always mark a fully preemptible state regarding interrupts (i.e. sti()).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>affinity</em>&nbsp;</td><td>The processor affinity of this thread. Passing XNPOD_ALL_CPUS or an empty affinity set means "any cpu".</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>The address of the thread's body routine. In other words, it is the thread entry point.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>A user-defined opaque cookie the nucleus will pass to the emerging thread as the sole argument of its entry point.</td></tr>
  </table>
</dl>
The START hooks are called on behalf of the calling context (if any).<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>if <em>thread</em> could be started ;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EBUSY</em>&nbsp;</td><td>if <em>thread</em> was already started ;</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>if the value of <em>affinity</em> is invalid.</td></tr>
  </table>
</dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible. 
</div>
</div><p>
<a class="anchor" name="g97f373e15e3fcfcbe410dd4cf4fb9c06"></a><!-- doxytag: member="pod.h::xnpod_start_timer" ref="g97f373e15e3fcfcbe410dd4cf4fb9c06" args="(u_long nstick, xnisr_t tickhandler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_start_timer           </td>
          <td>(</td>
          <td class="paramtype">u_long&nbsp;</td>
          <td class="paramname"> <em>nstick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnisr_t&nbsp;</td>
          <td class="paramname"> <em>tickhandler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start the system timer. 
<p>
The nucleus needs a time source to provide the time-related services to the upper interfaces. <a class="el" href="group__pod.html#g97f373e15e3fcfcbe410dd4cf4fb9c06">xnpod_start_timer()</a> tunes the timer hardware so that a user-defined routine is called according to a given frequency. On architectures that provide a oneshot-programmable time source, the system timer can operate either in aperiodic or periodic mode. Using the aperiodic mode still allows to run periodic timings over it: the underlying hardware will simply be reprogrammed after each tick by the timer manager using the appropriate interval value (see xntimer_start()).<p>
The time interval that elapses between two consecutive invocations of the handler is called a tick.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nstick</em>&nbsp;</td><td>The timer period in nanoseconds. XNPOD_DEFAULT_TICK can be used to set this value according to the arch-dependent settings. If this parameter is equal to XN_APERIODIC_TICK, the underlying hardware timer is set to operate in oneshot-programming mode. In this mode, timing accuracy is higher - since it is not rounded to a constant time slice. The aperiodic mode gives better results in configuration involving threads requesting timing services over different time scales that cannot be easily expressed as multiples of a single base tick, or would lead to a waste of high frequency periodical ticks.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tickhandler</em>&nbsp;</td><td>The address of the tick handler which will process each incoming tick. XNPOD_DEFAULT_TICKHANDLER can be passed to use the system-defined entry point (i.e. xnpod_announce_tick()). In any case, a user-supplied handler should end up calling xnpod_announce_tick() to inform the nucleus of the incoming tick.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if the timer has already been set with incompatible requirements (different mode, different period if periodic, or different handler). <a class="el" href="group__pod.html#gcac8ce5804b9acf6daddaa61ec6952d9">xnpod_stop_timer()</a> must be issued before <a class="el" href="group__pod.html#g97f373e15e3fcfcbe410dd4cf4fb9c06">xnpod_start_timer()</a> is called again.</li></ul>
<p>
<ul>
<li>-EINVAL is returned if an invalid null tick handler has been passed, or if the timer precision cannot represent the duration of a single host tick.</li></ul>
<p>
<ul>
<li>-ENODEV is returned if the underlying architecture does not support the requested periodic timing.</li></ul>
<p>
<ul>
<li>-ENOSYS is returned if no active pod exists.</li></ul>
<p>
Side-effect: A host timing service is started in order to relay the canonical periodical tick to the underlying architecture, regardless of the frequency used for Xenomai's system tick. This routine does not call the rescheduling procedure.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>User-space task in secondary mode</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="gcac8ce5804b9acf6daddaa61ec6952d9"></a><!-- doxytag: member="pod.h::xnpod_stop_timer" ref="gcac8ce5804b9acf6daddaa61ec6952d9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_stop_timer           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stop the system timer. 
<p>
Stops the system timer previously started by a call to <a class="el" href="group__pod.html#g97f373e15e3fcfcbe410dd4cf4fb9c06">xnpod_start_timer()</a>.<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>User-space task in secondary mode</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="geda964adf7117f6c2c0ebfa5efb087c1"></a><!-- doxytag: member="pod.c::xnpod_suspend_thread" ref="geda964adf7117f6c2c0ebfa5efb087c1" args="(xnthread_t *thread, xnflags_t mask, xnticks_t timeout, xnsynch_t *wchan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_suspend_thread           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnflags_t&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnsynch_t *&nbsp;</td>
          <td class="paramname"> <em>wchan</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Suspend a thread. 
<p>
Suspends the execution of a thread according to a given suspensive condition. This thread will not be eligible for scheduling until it all the pending suspensive conditions set by this service are removed by one or more calls to <a class="el" href="group__pod.html#gb0a50b55544dd14c58665ecd0a7bb079">xnpod_resume_thread()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the suspended thread.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>The suspension mask specifying the suspensive condition to add to the thread's wait mask. Possible values usable by the caller are:</td></tr>
  </table>
</dl>
<ul>
<li>XNSUSP. This flag forcibly suspends a thread, regardless of any resource to wait for. A reverse call to <a class="el" href="group__pod.html#gb0a50b55544dd14c58665ecd0a7bb079">xnpod_resume_thread()</a> specifying the XNSUSP bit must be issued to remove this condition, which is cumulative with other suspension bits.<em>wchan</em> should be NULL when using this suspending mode.</li></ul>
<p>
<ul>
<li>XNDELAY. This flags denotes a counted delay wait (in ticks) which duration is defined by the value of the timeout parameter.</li></ul>
<p>
<ul>
<li>XNPEND. This flag denotes a wait for a synchronization object to be signaled. The wchan argument must points to this object. A timeout value can be passed to bound the wait. This suspending mode should not be used directly by the client interface, but rather through the <a class="el" href="group__synch.html#g6e42a0d4e6e9f744bdc6cd63ffe288ac">xnsynch_sleep_on()</a> call.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The timeout which may be used to limit the time the thread pends for a resource. This value is a wait time given in ticks (see note). Passing XN_INFINITE specifies an unbounded wait. All other values are used to initialize a watchdog timer. If the current operation mode is oneshot and <em>timeout</em> elapses before xnpod_suspend_thread() has completed, then the target thread will not be suspended, and this routine leads to a null effect.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wchan</em>&nbsp;</td><td>The address of a pended resource. This parameter is used internally by the synchronization object implementation code to specify on which object the suspended thread pends. NULL is a legitimate value when this parameter does not apply to the current suspending mode (e.g. XNSUSP).</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>If the target thread is a shadow which has received a Linux-originated signal, then this service immediately exits without suspending the thread, but raises the XNBREAK condition in its information mask.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: possible if the current thread suspends itself.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This service is sensitive to the current operation mode of the system timer, as defined by the <a class="el" href="group__pod.html#g97f373e15e3fcfcbe410dd4cf4fb9c06">xnpod_start_timer()</a> service. In periodic mode, clock ticks are interpreted as periodic jiffies. In oneshot mode, clock ticks are interpreted as nanoseconds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga8164ee9e3bed2594ae7c0021fc5388a"></a><!-- doxytag: member="pod.c::xnpod_trap_fault" ref="ga8164ee9e3bed2594ae7c0021fc5388a" args="(void *fltinfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_trap_fault           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>fltinfo</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default fault handler. 
<p>
This is the default handler which is called whenever an uncontrolled exception or fault is caught. If the fault is caught on behalf of a real-time thread, the fault handler stored into the service table (svctable.faulthandler) is invoked and the fault is not propagated to the host system. Otherwise, the fault is unhandled by the nucleus and simply propagated.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fltinfo</em>&nbsp;</td><td>An opaque pointer to the arch-specific buffer describing the fault. The actual layout is defined by the xnarch_fltinfo_t type in each arch-dependent layer file. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ga591b675aa433190b4cdf3056380718d"></a><!-- doxytag: member="pod.h::xnpod_unblock_thread" ref="ga591b675aa433190b4cdf3056380718d" args="(xnthread_t *thread)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_unblock_thread           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unblock a thread. 
<p>
Breaks the thread out of any wait it is currently in. This call removes the XNDELAY and XNPEND suspensive conditions previously put by xnpod_suspend_thread() on the target thread. If all suspensive conditions are gone, the thread is left in a READY state at which point it becomes eligible anew for scheduling.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>thread</em>&nbsp;</td><td>The descriptor address of the unblocked thread.</td></tr>
  </table>
</dl>
This call neither releases the thread from the XNSUSP, XNRELAX nor the XNDORMANT suspensive conditions.<p>
When the thread resumes execution, the XNBREAK bit is set in the unblocked thread's information mask. Unblocking a non-blocked thread is perfectly harmless.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>non-zero is returned if the thread was actually unblocked from a pending wait state, 0 otherwise.</dd></dl>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Interrupt service routine</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: never. 
</div>
</div><p>
<a class="anchor" name="g603ef7d673e880d9c8b54baf86bcca09"></a><!-- doxytag: member="pod.h::xnpod_wait_thread_period" ref="g603ef7d673e880d9c8b54baf86bcca09" args="(unsigned long *overruns_r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnpod_wait_thread_period           </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>overruns_r</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Wait for the next periodic release point. 
<p>
Make the current thread wait for the next periodic release point in the processor time line.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>overruns_r</em>&nbsp;</td><td>If non-NULL, <em>overruns_r</em> must be a pointer to a memory location which will be written with the count of pending overruns. This value is copied only when <a class="el" href="group__pod.html#g603ef7d673e880d9c8b54baf86bcca09">xnpod_wait_thread_period()</a> returns -ETIMEDOUT or success; the memory location remains unmodified otherwise. If NULL, this count will never be copied back.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 is returned upon success; if <em>overruns_r</em> is valid, zero is copied to the pointed memory location. Otherwise:</dd></dl>
<ul>
<li>-EWOULDBLOCK is returned if <a class="el" href="group__pod.html#g43c9d5f1cb127fd84cc7fb74c22b9879">xnpod_set_thread_periodic()</a> has not previously been called for the calling thread.</li></ul>
<p>
<ul>
<li>-EINTR is returned if <a class="el" href="group__pod.html#ga591b675aa433190b4cdf3056380718d">xnpod_unblock_thread()</a> has been called for the waiting thread before the next periodic release point has been reached. In this case, the overrun counter is reset too.</li></ul>
<p>
<ul>
<li>-ETIMEDOUT is returned if the timer has overrun, which indicates that one or more previous release points have been missed by the calling thread. If <em>overruns_r</em> is valid, the count of pending overruns is copied to the pointed memory location.</li></ul>
<p>
Environments:<p>
This service can be called from:<p>
<ul>
<li>Kernel module initialization/cleanup code</li><li>Kernel-based task</li><li>User-space task</li></ul>
<p>
Rescheduling: always, unless the current release point has already been reached. In the latter case, the current thread immediately returns from this service without being delayed. 
</div>
</div><p>
<a class="anchor" name="gb350cf66627c484e24601f887ae7ab07"></a><!-- doxytag: member="pod.c::xnpod_welcome_thread" ref="gb350cf66627c484e24601f887ae7ab07" args="(xnthread_t *thread, int imask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnpod_welcome_thread           </td>
          <td>(</td>
          <td class="paramtype">xnthread_t *&nbsp;</td>
          <td class="paramname"> <em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>imask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Thread prologue. 
<p>
<p><b>For internal use only.</b></p>
<p>
This internal routine is called on behalf of a (re)starting thread's prologue before the user entry point is invoked. This call is reserved for internal housekeeping chores and cannot be inlined.<p>
Entered with nklock locked, irqs off. </p>

</div>
</div><p>
<hr size="1"><address style="align: right;"><small>Generated on Wed Jul 25 09:40:26 2007 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.1 </small></address>
</body>
</html>
