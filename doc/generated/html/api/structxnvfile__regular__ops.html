<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Xenomai API: xnvfile_regular_ops Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<h1>xnvfile_regular_ops Struct Reference<br/>
<small>
[<a class="el" href="group__vfile.html">Virtual file services</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="xnvfile_regular_ops" -->
<p>Regular vfile operation descriptor.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#a054ed8bb69da0a0c6e3c4f5d239b0dcf">rewind</a> )(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#aaf7b735bddab35a238045e3d2b7e2484">begin</a> )(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#aeb55d4c32cc11813068a0fc055996462">next</a> )(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#a29ba8b1f5ff72e70411c977397b91877">end</a> )(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#ac1d48ccaa785342eaa4c80360a560c70">show</a> )(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it, void *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html#ad2b85a790c9a10c62a96f7bd5d3bde6f">store</a> )(struct xnvfile_input *input)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Regular vfile operation descriptor. </p>
<p><a class="anchor" id="regular_ops"></a></p>
<p>This structure describes the operations available with a regular vfile. It defines handlers for sending back formatted kernel data upon a user-space read request, and for obtaining user data upon a user-space write request. </p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="aaf7b735bddab35a238045e3d2b7e2484"></a><!-- doxytag: member="xnvfile_regular_ops::begin" ref="aaf7b735bddab35a238045e3d2b7e2484" args=")(struct xnvfile_regular_iterator *it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* <a class="el" href="structxnvfile__regular__ops.html#aaf7b735bddab35a238045e3d2b7e2484">xnvfile_regular_ops::begin</a>)(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="regular_begin"></a> This handler should prepare for iterating over the records upon a read request, starting from the specified position.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>A pointer to the current vfile iterator. On entry, it-&gt;pos is set to the (0-based) position of the first record to output. This handler may be called multiple times with different position requests.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the first record to format and output, to be passed to the <a class="el" href="structxnvfile__regular__ops.html#regular_show">show() handler</a> as its <em>data</em> parameter, if the call succeeds. Otherwise:</dd></dl>
<ul>
<li>NULL in case no record is available, in which case the read operation will terminate immediately with no output.</li>
</ul>
<ul>
<li>VFILE_SEQ_START, a special value indicating that <a class="el" href="structxnvfile__regular__ops.html#regular_show">the show() handler</a> should receive a NULL data pointer first, in order to output a header.</li>
</ul>
<ul>
<li>ERR_PTR(errno), where errno is a negative error code; upon error, the current operation will be aborted immediately.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>This handler is optional; if none is given in the operation descriptor (i.e. NULL value), the <a class="el" href="structxnvfile__regular__ops.html#regular_show">show() handler()</a> will be called only once for a read operation, with a NULL <em>data</em> parameter. This particular setting is convenient for simple regular vfiles having a single, fixed record to output. </dd></dl>

</div>
</div>
<a class="anchor" id="a29ba8b1f5ff72e70411c977397b91877"></a><!-- doxytag: member="xnvfile_regular_ops::end" ref="a29ba8b1f5ff72e70411c977397b91877" args=")(struct xnvfile_regular_iterator *it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* <a class="el" href="structxnvfile__regular__ops.html#a29ba8b1f5ff72e70411c977397b91877">xnvfile_regular_ops::end</a>)(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="regular_end"></a> This handler is called after all records have been output.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>A pointer to the current vfile iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This handler is optional and the pointer may be NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb55d4c32cc11813068a0fc055996462"></a><!-- doxytag: member="xnvfile_regular_ops::next" ref="aeb55d4c32cc11813068a0fc055996462" args=")(struct xnvfile_regular_iterator *it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void*(* <a class="el" href="structxnvfile__regular__ops.html#aeb55d4c32cc11813068a0fc055996462">xnvfile_regular_ops::next</a>)(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="regular_next"></a> This handler should return the address of the next record to format and output by the <a class="el" href="structxnvfile__regular__ops.html#regular_show">show()</a> handler".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>A pointer to the current vfile iterator. On entry, it-&gt;pos is set to the (0-based) position of the next record to output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the next record to format and output, to be passed to the <a class="el" href="structxnvfile__regular__ops.html#regular_show">show() handler</a> as its <em>data</em> parameter, if the call succeeds. Otherwise:</dd></dl>
<ul>
<li>NULL in case no record is available, in which case the read operation will terminate immediately with no output.</li>
</ul>
<ul>
<li>ERR_PTR(errno), where errno is a negative error code; upon error, the current operation will be aborted immediately.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>This handler is optional; if none is given in the operation descriptor (i.e. NULL value), the read operation will stop after the first invocation of the <a class="el" href="structxnvfile__regular__ops.html#regular_show">show() handler</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a054ed8bb69da0a0c6e3c4f5d239b0dcf"></a><!-- doxytag: member="xnvfile_regular_ops::rewind" ref="a054ed8bb69da0a0c6e3c4f5d239b0dcf" args=")(struct xnvfile_regular_iterator *it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structxnvfile__regular__ops.html#a054ed8bb69da0a0c6e3c4f5d239b0dcf">xnvfile_regular_ops::rewind</a>)(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="regular_rewind"></a> This handler is called only once, when the virtual file is opened, before the <a class="el" href="structxnvfile__regular__ops.html#regular_begin">begin() handler</a> is invoked.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>A pointer to the vfile iterator which will be used to read the file contents.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Zero should be returned upon success. Otherwise, a negative error code aborts the operation, and is passed back to the reader.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This handler is optional. It should not be used to allocate resources but rather to perform consistency checks, since no closure call is issued in case the open sequence eventually fails. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1d48ccaa785342eaa4c80360a560c70"></a><!-- doxytag: member="xnvfile_regular_ops::show" ref="ac1d48ccaa785342eaa4c80360a560c70" args=")(struct xnvfile_regular_iterator *it, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* <a class="el" href="structxnvfile__regular__ops.html#ac1d48ccaa785342eaa4c80360a560c70">xnvfile_regular_ops::show</a>)(struct <a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a> *it, void *data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="regular_show"></a> This handler should format and output a record.</p>
<p>xnvfile_printf(), xnvfile_write(), xnvfile_puts() and xnvfile_putc() are available to format and/or emit the output. All routines take the iterator argument <em>it</em> as their first parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>it</em>&nbsp;</td><td>A pointer to the current vfile iterator.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to the record to format then output. The first call to the handler may receive a NULL <em>data</em> pointer, depending on the presence and/or return of a <a class="el" href="structxnvfile__regular__ops.html#regular_begin">hander</a>; the show handler should test this special value to output any header that fits, prior to receiving more calls with actual records.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>zero if the call succeeds, also indicating that the handler should be called for the next record if any. Otherwise:</dd></dl>
<ul>
<li>A negative error code. This will abort the output phase, and return this status to the reader.</li>
</ul>
<ul>
<li>VFILE_SEQ_SKIP, a special value indicating that the current record should be skipped and will not be output. </li>
</ul>

</div>
</div>
<a class="anchor" id="ad2b85a790c9a10c62a96f7bd5d3bde6f"></a><!-- doxytag: member="xnvfile_regular_ops::store" ref="ad2b85a790c9a10c62a96f7bd5d3bde6f" args=")(struct xnvfile_input *input)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t(* <a class="el" href="structxnvfile__regular__ops.html#ad2b85a790c9a10c62a96f7bd5d3bde6f">xnvfile_regular_ops::store</a>)(struct xnvfile_input *input)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="anchor" id="regular_store"></a> This handler receives data written to the vfile, likely for updating some kernel setting, or triggering any other action which fits. This is the only handler which deals with the write-side of a vfile. It is called when writing to the /proc entry of the vfile from a user-space process.</p>
<p>The input data is described by a descriptor passed to the handler, which may be subsequently passed to parsing helper routines. For instance, <a class="el" href="group__vfile.html#gae45ea5410707367c9e032dc36fc30916" title="Read in a C-string written to the vfile.">xnvfile_get_string()</a> will accept the input descriptor for returning the written data as a null-terminated character string. On the other hand, <a class="el" href="group__vfile.html#ga18746b2aae928c0281ae57ef47086600" title="Evaluate the string written to the vfile as a long integer.">xnvfile_get_integer()</a> will attempt to return a long integer from the input data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>input</em>&nbsp;</td><td>A pointer to an input descriptor. It refers to an opaque data from the handler's standpoint.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of bytes read from the input descriptor if the call succeeds. Otherwise, a negative error code. Return values from parsing helper routines are commonly passed back to the caller by the <a class="el" href="structxnvfile__regular__ops.html#ad2b85a790c9a10c62a96f7bd5d3bde6f">store() handler</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This handler is optional, and may be omitted for read-only vfiles. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/nucleus/<a class="el" href="vfile_8h_source.html">vfile.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Jan 23 2013 13:24:05 for Xenomai API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
