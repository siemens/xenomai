<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Timer services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cobalt__core__timer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Timer services<div class="ingroups"><a class="el" href="group__cobalt.html">Cobalt</a> &raquo; <a class="el" href="group__cobalt__core.html">Cobalt kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The Xenomai timer facility depends on a clock source (xnclock) for scheduling the next activation times.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Timer services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__cobalt__core__timer.png" border="0" alt="" usemap="#group____cobalt____core____timer"/>
<map name="group____cobalt____core____timer" id="group____cobalt____core____timer">
<area shape="rect" id="node2" href="group__cobalt__core.html" title="The Cobalt core is a co&#45;kernel which supplements the Linux kernel for delivering real&#45;time services w..." alt="" coords="5,5,104,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad3df99cd50604063f66cf58c88074161"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#gad3df99cd50604063f66cf58c88074161">xntimer_destroy</a> (struct xntimer *timer)</td></tr>
<tr class="memdesc:gad3df99cd50604063f66cf58c88074161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a timer object.  <a href="#gad3df99cd50604063f66cf58c88074161">More...</a><br /></td></tr>
<tr class="separator:gad3df99cd50604063f66cf58c88074161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf378e71fd5fd53fd220ab609c950fc47"><td class="memItemLeft" align="right" valign="top">static xnticks_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#gaf378e71fd5fd53fd220ab609c950fc47">xntimer_interval</a> (struct xntimer *timer)</td></tr>
<tr class="memdesc:gaf378e71fd5fd53fd220ab609c950fc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the timer interval value.  <a href="#gaf378e71fd5fd53fd220ab609c950fc47">More...</a><br /></td></tr>
<tr class="separator:gaf378e71fd5fd53fd220ab609c950fc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5105f0fe627798b588a5f124715cb31b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b">xntimer_start</a> (struct xntimer *timer, xnticks_t value, xnticks_t interval, xntmode_t mode)</td></tr>
<tr class="memdesc:ga5105f0fe627798b588a5f124715cb31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arm a timer.  <a href="#ga5105f0fe627798b588a5f124715cb31b">More...</a><br /></td></tr>
<tr class="separator:ga5105f0fe627798b588a5f124715cb31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f30d84a34abe93b6ab600b5842f4cbf"><td class="memItemLeft" align="right" valign="top">xnticks_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#ga1f30d84a34abe93b6ab600b5842f4cbf">xntimer_get_date</a> (struct xntimer *timer)</td></tr>
<tr class="memdesc:ga1f30d84a34abe93b6ab600b5842f4cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute expiration date.  <a href="#ga1f30d84a34abe93b6ab600b5842f4cbf">More...</a><br /></td></tr>
<tr class="separator:ga1f30d84a34abe93b6ab600b5842f4cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcacfa3e2ac39463f57384fb14afa23f"><td class="memItemLeft" align="right" valign="top">xnticks_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#gafcacfa3e2ac39463f57384fb14afa23f">xntimer_get_timeout</a> (struct xntimer *timer)</td></tr>
<tr class="memdesc:gafcacfa3e2ac39463f57384fb14afa23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the relative expiration date.  <a href="#gafcacfa3e2ac39463f57384fb14afa23f">More...</a><br /></td></tr>
<tr class="separator:gafcacfa3e2ac39463f57384fb14afa23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aaa5a0dcfeb46e0e322fa7464fdb997"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#ga9aaa5a0dcfeb46e0e322fa7464fdb997">xntimer_stop</a> (struct xntimer *timer)</td></tr>
<tr class="memdesc:ga9aaa5a0dcfeb46e0e322fa7464fdb997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disarm a timer.  <a href="#ga9aaa5a0dcfeb46e0e322fa7464fdb997">More...</a><br /></td></tr>
<tr class="separator:ga9aaa5a0dcfeb46e0e322fa7464fdb997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga189c3dfeb6047ad3eddc41c45ad176d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#ga189c3dfeb6047ad3eddc41c45ad176d6">xntimer_init</a> (struct xntimer *timer, struct xnclock *clock, void(*handler)(struct xntimer *timer), struct <a class="el" href="structxnsched.html">xnsched</a> *sched, int flags)</td></tr>
<tr class="memdesc:ga189c3dfeb6047ad3eddc41c45ad176d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a timer object.  <a href="#ga189c3dfeb6047ad3eddc41c45ad176d6">More...</a><br /></td></tr>
<tr class="separator:ga189c3dfeb6047ad3eddc41c45ad176d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcea9e49706bb130bb63ada53ec4bd87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#gabcea9e49706bb130bb63ada53ec4bd87">__xntimer_migrate</a> (struct xntimer *timer, struct <a class="el" href="structxnsched.html">xnsched</a> *sched)</td></tr>
<tr class="memdesc:gabcea9e49706bb130bb63ada53ec4bd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate a timer.  <a href="#gabcea9e49706bb130bb63ada53ec4bd87">More...</a><br /></td></tr>
<tr class="separator:gabcea9e49706bb130bb63ada53ec4bd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43632fbc3c902df8a710c3d85ca7457c"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#ga43632fbc3c902df8a710c3d85ca7457c">xntimer_get_overruns</a> (struct xntimer *timer, xnticks_t now)</td></tr>
<tr class="memdesc:ga43632fbc3c902df8a710c3d85ca7457c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the count of overruns for the last tick.  <a href="#ga43632fbc3c902df8a710c3d85ca7457c">More...</a><br /></td></tr>
<tr class="separator:ga43632fbc3c902df8a710c3d85ca7457c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40dc6da3c5f849e4d6629f9d804fa7d7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#ga40dc6da3c5f849e4d6629f9d804fa7d7">program_htick_shot</a> (unsigned long delay, struct clock_event_device *cdev)</td></tr>
<tr class="memdesc:ga40dc6da3c5f849e4d6629f9d804fa7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program next host tick as a Xenomai timer event.  <a href="#ga40dc6da3c5f849e4d6629f9d804fa7d7">More...</a><br /></td></tr>
<tr class="separator:ga40dc6da3c5f849e4d6629f9d804fa7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8c47fc1d2fa949791500f9435fc96a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#ga1f8c47fc1d2fa949791500f9435fc96a">switch_htick_mode</a> (enum clock_event_mode mode, struct clock_event_device *cdev)</td></tr>
<tr class="memdesc:ga1f8c47fc1d2fa949791500f9435fc96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tick mode switch emulation callback.  <a href="#ga1f8c47fc1d2fa949791500f9435fc96a">More...</a><br /></td></tr>
<tr class="separator:ga1f8c47fc1d2fa949791500f9435fc96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae32695b66e4f3f05b2db32f335f88c9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#gae32695b66e4f3f05b2db32f335f88c9d">xntimer_grab_hardware</a> (void)</td></tr>
<tr class="memdesc:gae32695b66e4f3f05b2db32f335f88c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grab the hardware timer on all real-time CPUs.  <a href="#gae32695b66e4f3f05b2db32f335f88c9d">More...</a><br /></td></tr>
<tr class="separator:gae32695b66e4f3f05b2db32f335f88c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ce3fc9fcfba5f93722b6ce2024e09cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__timer.html#ga9ce3fc9fcfba5f93722b6ce2024e09cf">xntimer_release_hardware</a> (void)</td></tr>
<tr class="memdesc:ga9ce3fc9fcfba5f93722b6ce2024e09cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release hardware timers.  <a href="#ga9ce3fc9fcfba5f93722b6ce2024e09cf">More...</a><br /></td></tr>
<tr class="separator:ga9ce3fc9fcfba5f93722b6ce2024e09cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Xenomai timer facility depends on a clock source (xnclock) for scheduling the next activation times. </p>
<p>The core provides and depends on a monotonic clock source (nkclock) with nanosecond resolution, driving the platform timer hardware exposed by the interrupt pipeline. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabcea9e49706bb130bb63ada53ec4bd87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __xntimer_migrate </td>
          <td>(</td>
          <td class="paramtype">struct xntimer *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxnsched.html">xnsched</a> *&#160;</td>
          <td class="paramname"><em>sched</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate a timer. </p>
<p>This call migrates a timer to another cpu. In order to avoid pathological cases, it must be called from the CPU to which <em>timer</em> is currently attached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The address of the timer object to be migrated.</td></tr>
    <tr><td class="paramname">sched</td><td>The address of the destination per-CPU scheduler slot.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, atomic-entry</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__timer.html#ga9aaa5a0dcfeb46e0e322fa7464fdb997">xntimer_stop()</a>.</p>

<p>Referenced by <a class="el" href="group__cobalt__core__thread.html#gae78ee27f53ae4d947b271b98748c78e9">xnthread_migrate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga40dc6da3c5f849e4d6629f9d804fa7d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int program_htick_shot </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct clock_event_device *&#160;</td>
          <td class="paramname"><em>cdev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Program next host tick as a Xenomai timer event. </p>
<p>Program the next shot for the host tick on the current CPU. Emulation is done using a nucleus timer attached to the master timebase.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>The time delta from the current date to the next tick, expressed as a count of nanoseconds.</td></tr>
    <tr><td class="paramname">cdev</td><td>An pointer to the clock device which notifies us.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

<p>References <a class="el" href="structxnsched.html#ae2818d36a93ef25f121c67f2ff34d236">xnsched::htimer</a>, and <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b">xntimer_start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f8c47fc1d2fa949791500f9435fc96a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void switch_htick_mode </td>
          <td>(</td>
          <td class="paramtype">enum clock_event_mode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct clock_event_device *&#160;</td>
          <td class="paramname"><em>cdev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tick mode switch emulation callback. </p>
<p>Changes the host tick mode for the tick device of the current CPU.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The new mode to switch to. The possible values are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>CLOCK_EVT_MODE_ONESHOT, for a switch to oneshot mode.</li>
<li>CLOCK_EVT_MODE_PERIODIC, for a switch to periodic mode. The current implementation for the generic clockevent layer Linux exhibits should never downgrade from a oneshot to a periodic tick mode, so this mode should not be encountered. This said, the associated code is provided, basically for illustration purposes.</li>
<li>CLOCK_EVT_MODE_SHUTDOWN, indicates the removal of the current tick device. Normally, the nucleus only interposes on tick devices which should never be shut down, so this mode should not be encountered.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cdev</td><td>An opaque pointer to the clock device which notifies us.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>GENERIC_CLOCKEVENTS is required from the host kernel. </dd></dl>

<p>References <a class="el" href="structxnsched.html#ae2818d36a93ef25f121c67f2ff34d236">xnsched::htimer</a>, <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b">xntimer_start()</a>, and <a class="el" href="group__cobalt__core__timer.html#ga9aaa5a0dcfeb46e0e322fa7464fdb997">xntimer_stop()</a>.</p>

</div>
</div>
<a class="anchor" id="gad3df99cd50604063f66cf58c88074161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_destroy </td>
          <td>(</td>
          <td class="paramtype">struct xntimer *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a timer object. </p>
<p>Destroys a timer. After it has been destroyed, all resources associated with the timer have been released. The timer is automatically deactivated before deletion if active on entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__timer.html#ga9aaa5a0dcfeb46e0e322fa7464fdb997">xntimer_stop()</a>.</p>

<p>Referenced by <a class="el" href="group__rtdm__timer.html#gac75c6e2f7c838b11d8e261be3a7a0326">rtdm_timer_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f30d84a34abe93b6ab600b5842f4cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnticks_t xntimer_get_date </td>
          <td>(</td>
          <td class="paramtype">struct xntimer *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the absolute expiration date. </p>
<p>Return the next expiration date of a timer as an absolute count of nanoseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The expiration date in nanoseconds. The special value XN_INFINITE is returned if <em>timer</em> is currently disabled.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, atomic-entry</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga43632fbc3c902df8a710c3d85ca7457c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long xntimer_get_overruns </td>
          <td>(</td>
          <td class="paramtype">struct xntimer *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>now</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the count of overruns for the last tick. </p>
<p>This service returns the count of pending overruns for the last tick of a given timer, as measured by the difference between the expected expiry date of the timer and the date <em>now</em> passed as argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The address of a valid timer descriptor.</td></tr>
    <tr><td class="paramname">now</td><td>current date (as xnclock_read_raw(xntimer_clock(timer)))</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of overruns of <em>timer</em> at date <em>now</em> </dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, atomic-entry</a> </dd></dl>

<p>Referenced by <a class="el" href="group__cobalt__core__thread.html#ga002449afde30d3b736ac558895ff5ab2">xnthread_wait_period()</a>.</p>

</div>
</div>
<a class="anchor" id="gafcacfa3e2ac39463f57384fb14afa23f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xnticks_t xntimer_get_timeout </td>
          <td>(</td>
          <td class="paramtype">struct xntimer *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the relative expiration date. </p>
<p>This call returns the count of nanoseconds remaining until the timer expires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The count of nanoseconds until expiry. The special value XN_INFINITE is returned if <em>timer</em> is currently disabled. It might happen that the timer expires when this service runs (even if the associated handler has not been fired yet); in such a case, 1 is returned.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, atomic-entry</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae32695b66e4f3f05b2db32f335f88c9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xntimer_grab_hardware </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Grab the hardware timer on all real-time CPUs. </p>
<p><a class="el" href="group__cobalt__core__timer.html#gae32695b66e4f3f05b2db32f335f88c9d" title="Grab the hardware timer on all real-time CPUs. ">xntimer_grab_hardware()</a> grabs and tunes the hardware timer for all real-time CPUs.</p>
<p>Host tick emulation is performed for sharing the clock chip between Linux and Xenomai.</p>
<dl class="section return"><dt>Returns</dt><dd>a positive value is returned on success, representing the duration of a Linux periodic tick expressed as a count of nanoseconds; zero should be returned when the Linux kernel does not undergo periodic timing on the given CPU (e.g. oneshot mode). Otherwise:</dd></dl>
<ul>
<li>-EBUSY is returned if the hardware timer has already been grabbed. <a class="el" href="group__cobalt__core__timer.html#ga9ce3fc9fcfba5f93722b6ce2024e09cf" title="Release hardware timers. ">xntimer_release_hardware()</a> must be issued before <a class="el" href="group__cobalt__core__timer.html#gae32695b66e4f3f05b2db32f335f88c9d" title="Grab the hardware timer on all real-time CPUs. ">xntimer_grab_hardware()</a> is called again.</li>
<li>-ENODEV is returned if the hardware timer cannot be used. This situation may occur after the kernel disabled the timer due to invalid calibration results; in such a case, such hardware is unusable for any timing duties.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p>References <a class="el" href="structxnsched.html#a311abccab49fc3209aff4895a2de4f45">xnsched::cpu</a>, <a class="el" href="structxnsched.html#ae2818d36a93ef25f121c67f2ff34d236">xnsched::htimer</a>, <a class="el" href="group__cobalt__core__irq.html#ga2bcb3882ee1fc8f5580db7f66b2730b9">xnintr_init()</a>, <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b">xntimer_start()</a>, and <a class="el" href="group__cobalt__core__timer.html#ga9aaa5a0dcfeb46e0e322fa7464fdb997">xntimer_stop()</a>.</p>

</div>
</div>
<a class="anchor" id="ga189c3dfeb6047ad3eddc41c45ad176d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_init </td>
          <td>(</td>
          <td class="paramtype">struct xntimer *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnclock *&#160;</td>
          <td class="paramname"><em>clock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(struct xntimer *timer)&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxnsched.html">xnsched</a> *&#160;</td>
          <td class="paramname"><em>sched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a timer object. </p>
<p>Creates a timer. When created, a timer is left disarmed; it must be started using <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b" title="Arm a timer. ">xntimer_start()</a> in order to be activated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The address of a timer descriptor the nucleus will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td class="paramname">clock</td><td>The clock the timer relates to. Xenomai defines a monotonic system clock, with nanosecond resolution, named nkclock. In addition, external clocks driven by other tick sources may be created dynamically if CONFIG_XENO_OPT_EXTCLOCK is defined.</td></tr>
    <tr><td class="paramname">handler</td><td>The routine to call upon expiration of the timer.</td></tr>
    <tr><td class="paramname">sched</td><td>An optional pointer to the per-CPU scheduler slot the new timer is affine to. If non-NULL, the timer will fire on the CPU <em>sched</em> is bound to, otherwise it will fire either on the current CPU if real-time, or on the first real-time CPU.</td></tr>
    <tr><td class="paramname">flags</td><td>A set of flags describing the timer. The valid flags are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNTIMER_NOBLCK, the timer won't be frozen while GDB takes over control of the application.</li>
</ul>
<p>A set of clock gravity hints can be passed via the <em>flags</em> argument, used for optimizing the built-in heuristics aimed at latency reduction:</p>
<ul>
<li>XNTIMER_IGRAVITY, the timer activates a leaf timer handler.</li>
<li>XNTIMER_KGRAVITY, the timer activates a kernel thread.</li>
<li>XNTIMER_UGRAVITY, the timer activates a user-space thread.</li>
</ul>
<p>There is no limitation on the number of timers which can be created/active concurrently.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf378e71fd5fd53fd220ab609c950fc47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xnticks_t xntimer_interval </td>
          <td>(</td>
          <td class="paramtype">struct xntimer *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the timer interval value. </p>
<p>Return the timer interval value in nanoseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The duration of a period in nanoseconds. The special value XN_INFINITE is returned if <em>timer</em> is currently disabled or one shot.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, atomic-entry</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ce3fc9fcfba5f93722b6ce2024e09cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xntimer_release_hardware </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release hardware timers. </p>
<p>Releases hardware timers previously grabbed by a call to <a class="el" href="group__cobalt__core__timer.html#gae32695b66e4f3f05b2db32f335f88c9d" title="Grab the hardware timer on all real-time CPUs. ">xntimer_grab_hardware()</a>.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p>References <a class="el" href="structxnsched.html#a311abccab49fc3209aff4895a2de4f45">xnsched::cpu</a>, and <a class="el" href="group__cobalt__core__irq.html#ga2f4d355b8f1e30ac47eb6cdf5b15052a">xnintr_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5105f0fe627798b588a5f124715cb31b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xntimer_start </td>
          <td>(</td>
          <td class="paramtype">struct xntimer *&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntmode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arm a timer. </p>
<p>Activates a timer so that the associated timeout handler will be fired after each expiration time. A timer can be either periodic or one-shot, depending on the reload value passed to this routine. The given timer must have been previously initialized.</p>
<p>A timer is attached to the clock specified in <a class="el" href="group__cobalt__core__timer.html#ga189c3dfeb6047ad3eddc41c45ad176d6" title="Initialize a timer object. ">xntimer_init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The address of a valid timer descriptor.</td></tr>
    <tr><td class="paramname">value</td><td>The date of the initial timer shot, expressed in nanoseconds.</td></tr>
    <tr><td class="paramname">interval</td><td>The reload value of the timer. It is a periodic interval value to be used for reprogramming the next timer shot, expressed in nanoseconds. If <em>interval</em> is equal to XN_INFINITE, the timer will not be reloaded after it has expired.</td></tr>
    <tr><td class="paramname">mode</td><td>The timer mode. It can be XN_RELATIVE if <em>value</em> shall be interpreted as a relative date, XN_ABSOLUTE for an absolute date based on the monotonic clock of the related time base (as returned my xnclock_read_monotonic()), or XN_REALTIME if the absolute date is based on the adjustable real-time date for the relevant clock (obtained from xnclock_read_realtime()).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success, or -ETIMEDOUT if an absolute date in the past has been given. In such an event, the timer is nevertheless armed for the next shot in the timeline if <em>interval</em> is different from XN_INFINITE.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, atomic-entry</a> </dd></dl>

<p>Referenced by <a class="el" href="group__cobalt__core__timer.html#ga40dc6da3c5f849e4d6629f9d804fa7d7">program_htick_shot()</a>, <a class="el" href="group__rtdm__timer.html#ga429ca4935762583edb6e1ebc955fe958">rtdm_timer_start()</a>, <a class="el" href="group__cobalt__core__timer.html#ga1f8c47fc1d2fa949791500f9435fc96a">switch_htick_mode()</a>, <a class="el" href="group__cobalt__core__thread.html#gad0b5bb03ce22a7ef882729d24bfe2804">xnthread_set_periodic()</a>, <a class="el" href="group__cobalt__core__thread.html#ga92e19fc9deb691b7851e0f9fe21a825c">xnthread_set_slice()</a>, <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc">xnthread_suspend()</a>, and <a class="el" href="group__cobalt__core__timer.html#gae32695b66e4f3f05b2db32f335f88c9d">xntimer_grab_hardware()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9aaa5a0dcfeb46e0e322fa7464fdb997"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int xntimer_stop </td>
          <td>(</td>
          <td class="paramtype">struct xntimer *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disarm a timer. </p>
<p>This service deactivates a timer previously armed using <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b" title="Arm a timer. ">xntimer_start()</a>. Once disarmed, the timer can be subsequently re-armed using the latter service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The address of a valid timer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, atomic-entry</a> </dd></dl>

<p>Referenced by <a class="el" href="group__cobalt__core__timer.html#gabcea9e49706bb130bb63ada53ec4bd87">__xntimer_migrate()</a>, <a class="el" href="group__rtdm__timer.html#ga7f2accf693db9ed5a537b86a58bccd94">rtdm_timer_stop()</a>, <a class="el" href="group__cobalt__core__timer.html#ga1f8c47fc1d2fa949791500f9435fc96a">switch_htick_mode()</a>, <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115">xnthread_resume()</a>, <a class="el" href="group__cobalt__core__thread.html#gad0b5bb03ce22a7ef882729d24bfe2804">xnthread_set_periodic()</a>, <a class="el" href="group__cobalt__core__thread.html#ga92e19fc9deb691b7851e0f9fe21a825c">xnthread_set_slice()</a>, <a class="el" href="group__cobalt__core__timer.html#gad3df99cd50604063f66cf58c88074161">xntimer_destroy()</a>, and <a class="el" href="group__cobalt__core__timer.html#gae32695b66e4f3f05b2db32f335f88c9d">xntimer_grab_hardware()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
