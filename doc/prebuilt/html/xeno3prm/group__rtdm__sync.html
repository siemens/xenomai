<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Synchronisation Services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__rtdm__sync.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Synchronisation Services<div class="ingroups"><a class="el" href="group__rtdm.html">RTDM</a> &raquo; <a class="el" href="group__rtdm__driver__interface.html">Driver programming interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Synchronisation Services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__rtdm__sync.png" border="0" alt="" usemap="#group____rtdm____sync"/>
<map name="group____rtdm____sync" id="group____rtdm____sync">
<area shape="rect" id="node1" href="group__rtdm__sync__sem.html" title="Semaphore Services" alt="" coords="421,5,563,32"/>
<area shape="rect" id="node2" href="group__rtdm__sync__mutex.html" title="Mutex services" alt="" coords="437,56,547,83"/>
<area shape="rect" id="node3" href="group__rtdm__sync__biglock.html" title="Big dual kernel lock" alt="" coords="424,107,560,133"/>
<area shape="rect" id="node4" href="group__rtdm__driver__interface.html" title="RTDM driver programming interface. " alt="" coords="5,99,141,141"/>
<area shape="rect" id="node5" href="group__rtdm__sync__spinlock.html" title="Spinlock with preemption\l deactivation" alt="" coords="408,158,576,199"/>
<area shape="rect" id="node7" href="group__rtdm__sync__event.html" title="Event Services" alt="" coords="437,224,547,251"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__rtdm__sync__biglock"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync__biglock.html">Big dual kernel lock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__rtdm__sync__spinlock"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync__spinlock.html">Spinlock with preemption deactivation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__rtdm__sync__event"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync__event.html">Event Services</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__rtdm__sync__sem"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync__sem.html">Semaphore Services</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__rtdm__sync__mutex"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync__mutex.html">Mutex services</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacad00aabb32f45db716014d22a59ea54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#gacad00aabb32f45db716014d22a59ea54">rtdm_waitqueue_init</a> (struct rtdm_waitqueue *wq)</td></tr>
<tr class="memdesc:gacad00aabb32f45db716014d22a59ea54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a RTDM wait queue.  <a href="#gacad00aabb32f45db716014d22a59ea54">More...</a><br /></td></tr>
<tr class="separator:gacad00aabb32f45db716014d22a59ea54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a582c32e371e0a74e4161169dfea85f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga8a582c32e371e0a74e4161169dfea85f">rtdm_waitqueue_destroy</a> (struct rtdm_waitqueue *wq)</td></tr>
<tr class="memdesc:ga8a582c32e371e0a74e4161169dfea85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a RTDM wait queue.  <a href="#ga8a582c32e371e0a74e4161169dfea85f">More...</a><br /></td></tr>
<tr class="separator:ga8a582c32e371e0a74e4161169dfea85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga326d1cf2d9a2542b5af71b3751afd214"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga326d1cf2d9a2542b5af71b3751afd214">rtdm_timedwait_condition_locked</a> (struct rtdm_wait_queue *wq, C_expr condition, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *toseq)</td></tr>
<tr class="memdesc:ga326d1cf2d9a2542b5af71b3751afd214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a locked waitqueue until a condition gets true.  <a href="#ga326d1cf2d9a2542b5af71b3751afd214">More...</a><br /></td></tr>
<tr class="separator:ga326d1cf2d9a2542b5af71b3751afd214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7d93fdcfa827df90060981f5d9455da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#gab7d93fdcfa827df90060981f5d9455da">rtdm_wait_condition_locked</a> (struct rtdm_wait_queue *wq, C_expr condition)</td></tr>
<tr class="memdesc:gab7d93fdcfa827df90060981f5d9455da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep on a locked waitqueue until a condition gets true.  <a href="#gab7d93fdcfa827df90060981f5d9455da">More...</a><br /></td></tr>
<tr class="separator:gab7d93fdcfa827df90060981f5d9455da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64a106cb23564a64214da75cb62909d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#gaa64a106cb23564a64214da75cb62909d">rtdm_timedwait_condition</a> (struct rtdm_wait_queue *wq, C_expr condition, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *toseq)</td></tr>
<tr class="memdesc:gaa64a106cb23564a64214da75cb62909d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a waitqueue until a condition gets true.  <a href="#gaa64a106cb23564a64214da75cb62909d">More...</a><br /></td></tr>
<tr class="separator:gaa64a106cb23564a64214da75cb62909d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace3e1f53d2dec9ec56156d6ea106bc7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#gace3e1f53d2dec9ec56156d6ea106bc7f">rtdm_timedwait</a> (struct rtdm_wait_queue *wq, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *toseq)</td></tr>
<tr class="memdesc:gace3e1f53d2dec9ec56156d6ea106bc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a waitqueue unconditionally.  <a href="#gace3e1f53d2dec9ec56156d6ea106bc7f">More...</a><br /></td></tr>
<tr class="separator:gace3e1f53d2dec9ec56156d6ea106bc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga937817382e84b0fb04b64f590ea49bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga937817382e84b0fb04b64f590ea49bfd">rtdm_timedwait_locked</a> (struct rtdm_wait_queue *wq, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout, rtdm_toseq_t *toseq)</td></tr>
<tr class="memdesc:ga937817382e84b0fb04b64f590ea49bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timed sleep on a locked waitqueue unconditionally.  <a href="#ga937817382e84b0fb04b64f590ea49bfd">More...</a><br /></td></tr>
<tr class="separator:ga937817382e84b0fb04b64f590ea49bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16d020cefc20213de5929ed2e72fe918"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga16d020cefc20213de5929ed2e72fe918">rtdm_wait_condition</a> (struct rtdm_wait_queue *wq, C_expr condition)</td></tr>
<tr class="memdesc:ga16d020cefc20213de5929ed2e72fe918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep on a waitqueue until a condition gets true.  <a href="#ga16d020cefc20213de5929ed2e72fe918">More...</a><br /></td></tr>
<tr class="separator:ga16d020cefc20213de5929ed2e72fe918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dacb9f8ed1fb7ac603b23707e4037a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga0dacb9f8ed1fb7ac603b23707e4037a9">rtdm_wait</a> (struct rtdm_wait_queue *wq)</td></tr>
<tr class="memdesc:ga0dacb9f8ed1fb7ac603b23707e4037a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep on a waitqueue unconditionally.  <a href="#ga0dacb9f8ed1fb7ac603b23707e4037a9">More...</a><br /></td></tr>
<tr class="separator:ga0dacb9f8ed1fb7ac603b23707e4037a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ba9e7856be7279bb7cd1c544ea2eb77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga8ba9e7856be7279bb7cd1c544ea2eb77">rtdm_wait_locked</a> (struct rtdm_wait_queue *wq)</td></tr>
<tr class="memdesc:ga8ba9e7856be7279bb7cd1c544ea2eb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep on a locked waitqueue unconditionally.  <a href="#ga8ba9e7856be7279bb7cd1c544ea2eb77">More...</a><br /></td></tr>
<tr class="separator:ga8ba9e7856be7279bb7cd1c544ea2eb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad48c02c6080bc0462ae932431f7ea022"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#gad48c02c6080bc0462ae932431f7ea022">rtdm_waitqueue_lock</a> (struct rtdm_wait_queue *wq, <a class="el" href="group__rtdm__sync__spinlock.html#ga7584217487c323356414e21200a57e63">rtdm_lockctx_t</a> context)</td></tr>
<tr class="memdesc:gad48c02c6080bc0462ae932431f7ea022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a waitqueue.  <a href="#gad48c02c6080bc0462ae932431f7ea022">More...</a><br /></td></tr>
<tr class="separator:gad48c02c6080bc0462ae932431f7ea022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3500d1bf5ed5d77385deb241ede355f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga3500d1bf5ed5d77385deb241ede355f5">rtdm_waitqueue_unlock</a> (struct rtdm_wait_queue *wq, <a class="el" href="group__rtdm__sync__spinlock.html#ga7584217487c323356414e21200a57e63">rtdm_lockctx_t</a> context)</td></tr>
<tr class="memdesc:ga3500d1bf5ed5d77385deb241ede355f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a waitqueue.  <a href="#ga3500d1bf5ed5d77385deb241ede355f5">More...</a><br /></td></tr>
<tr class="separator:ga3500d1bf5ed5d77385deb241ede355f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dff689ef2cdc0bb94a143c8bc753a65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga2dff689ef2cdc0bb94a143c8bc753a65">rtdm_waitqueue_signal</a> (struct rtdm_wait_queue *wq)</td></tr>
<tr class="memdesc:ga2dff689ef2cdc0bb94a143c8bc753a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a waitqueue.  <a href="#ga2dff689ef2cdc0bb94a143c8bc753a65">More...</a><br /></td></tr>
<tr class="separator:ga2dff689ef2cdc0bb94a143c8bc753a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9aa704827003402283014c47868d54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga0d9aa704827003402283014c47868d54">rtdm_waitqueue_broadcast</a> (struct rtdm_wait_queue *wq)</td></tr>
<tr class="memdesc:ga0d9aa704827003402283014c47868d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a waitqueue.  <a href="#ga0d9aa704827003402283014c47868d54">More...</a><br /></td></tr>
<tr class="separator:ga0d9aa704827003402283014c47868d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d336f1c5722192f21112133ccec04af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga6d336f1c5722192f21112133ccec04af">rtdm_waitqueue_flush</a> (struct rtdm_wait_queue *wq)</td></tr>
<tr class="memdesc:ga6d336f1c5722192f21112133ccec04af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush a waitqueue.  <a href="#ga6d336f1c5722192f21112133ccec04af">More...</a><br /></td></tr>
<tr class="separator:ga6d336f1c5722192f21112133ccec04af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e022df54d9ce21108a950afec8c7c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#gab6e022df54d9ce21108a950afec8c7c6">rtdm_waitqueue_wakeup</a> (struct rtdm_wait_queue *wq, rtdm_task_t waiter)</td></tr>
<tr class="memdesc:gab6e022df54d9ce21108a950afec8c7c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a particular waiter on a waitqueue.  <a href="#gab6e022df54d9ce21108a950afec8c7c6">More...</a><br /></td></tr>
<tr class="separator:gab6e022df54d9ce21108a950afec8c7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa06735fb5c996f8bc60aff71234f000d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#gaa06735fb5c996f8bc60aff71234f000d">rtdm_for_each_waiter</a> (rtdm_task_t pos, struct rtdm_wait_queue *wq)</td></tr>
<tr class="memdesc:gaa06735fb5c996f8bc60aff71234f000d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple iterator for waitqueues.  <a href="#gaa06735fb5c996f8bc60aff71234f000d">More...</a><br /></td></tr>
<tr class="separator:gaa06735fb5c996f8bc60aff71234f000d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga801d8a385eeee9820547a803076d0368"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga801d8a385eeee9820547a803076d0368">rtdm_for_each_waiter_safe</a> (rtdm_task_t pos, rtdm_task_t tmp, struct rtdm_wait_queue *wq)</td></tr>
<tr class="memdesc:ga801d8a385eeee9820547a803076d0368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe iterator for waitqueues.  <a href="#ga801d8a385eeee9820547a803076d0368">More...</a><br /></td></tr>
<tr class="separator:ga801d8a385eeee9820547a803076d0368"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RTDM_SELECTTYPE_xxx</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpe7c56e23b943533d601cd08637a81e10"></a><a class="anchor" id="RTDM_SELECTTYPE_xxx"></a>Event types select can bind to </p>
</td></tr>
<tr class="memitem:gae18228df8c70c9da1f90f61b01e92501"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a> { <a class="el" href="group__rtdm__sync.html#ggae18228df8c70c9da1f90f61b01e92501a3ddb0fbad9f52ad3646be2e5a6ba8b2b">RTDM_SELECTTYPE_READ</a> = XNSELECT_READ, 
<a class="el" href="group__rtdm__sync.html#ggae18228df8c70c9da1f90f61b01e92501a37819f609dee2b20852001e9b7ecd462">RTDM_SELECTTYPE_WRITE</a> = XNSELECT_WRITE, 
<a class="el" href="group__rtdm__sync.html#ggae18228df8c70c9da1f90f61b01e92501a2dd10c612a9e3c7e5134ee122ee3de74">RTDM_SELECTTYPE_EXCEPT</a> = XNSELECT_EXCEPT
 }<tr class="separator:gae18228df8c70c9da1f90f61b01e92501"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Timeout Sequence Management</h2></td></tr>
<tr class="memitem:ga531ddf80690059302409f760bd7f14d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4">rtdm_toseq_init</a> (rtdm_toseq_t *timeout_seq, <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> timeout)</td></tr>
<tr class="memdesc:ga531ddf80690059302409f760bd7f14d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a timeout sequence.  <a href="#ga531ddf80690059302409f760bd7f14d4">More...</a><br /></td></tr>
<tr class="separator:ga531ddf80690059302409f760bd7f14d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gae18228df8c70c9da1f90f61b01e92501"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__rtdm__sync.html#gae18228df8c70c9da1f90f61b01e92501">rtdm_selecttype</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a3ddb0fbad9f52ad3646be2e5a6ba8b2b"></a>RTDM_SELECTTYPE_READ&#160;</td><td class="fielddoc">
<p>Select input data availability events. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a37819f609dee2b20852001e9b7ecd462"></a>RTDM_SELECTTYPE_WRITE&#160;</td><td class="fielddoc">
<p>Select ouput buffer availability events. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae18228df8c70c9da1f90f61b01e92501a2dd10c612a9e3c7e5134ee122ee3de74"></a>RTDM_SELECTTYPE_EXCEPT&#160;</td><td class="fielddoc">
<p>Select exceptional events. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa06735fb5c996f8bc60aff71234f000d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtdm_for_each_waiter </td>
          <td>(</td>
          <td class="paramtype">rtdm_task_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple iterator for waitqueues. </p>
<p>This construct traverses the wait list of a given waitqueue <em>wq</em>, assigning each RTDM task pointer to the cursor variable <em>pos</em>, which must be of type rtdm_task_t.</p>
<p><em>wq</em> must have been locked by a call to <a class="el" href="group__rtdm__sync.html#gad48c02c6080bc0462ae932431f7ea022" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to traversing its wait list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>cursor variable holding a pointer to the RTDM task being fetched.</td></tr>
    <tr><td class="paramname">wq</td><td>waitqueue to scan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The waitqueue should not be signaled, broadcast or flushed during the traversal, unless the loop is aborted immediately after. Should multiple waiters be readied while iterating, the safe form <a class="el" href="group__rtdm__sync.html#ga801d8a385eeee9820547a803076d0368" title="Safe iterator for waitqueues. ">rtdm_for_each_waiter_safe()</a> must be used for traversal instead.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga801d8a385eeee9820547a803076d0368"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtdm_for_each_waiter_safe </td>
          <td>(</td>
          <td class="paramtype">rtdm_task_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_task_t&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe iterator for waitqueues. </p>
<p>This construct traverses the wait list of a given waitqueue <em>wq</em>, assigning each RTDM task pointer to the cursor variable <em>pos</em>, which must be of type rtdm_task_t.</p>
<p>Unlike with <a class="el" href="group__rtdm__sync.html#gaa06735fb5c996f8bc60aff71234f000d" title="Simple iterator for waitqueues. ">rtdm_for_each_waiter()</a>, the waitqueue may be signaled, broadcast or flushed during the traversal.</p>
<p><em>wq</em> must have been locked by a call to <a class="el" href="group__rtdm__sync.html#gad48c02c6080bc0462ae932431f7ea022" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to traversing its wait list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>cursor variable holding a pointer to the RTDM task being fetched.</td></tr>
    <tr><td class="paramname">tmp</td><td>temporary cursor variable.</td></tr>
    <tr><td class="paramname">wq</td><td>waitqueue to scan.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gace3e1f53d2dec9ec56156d6ea106bc7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_timedwait </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&#160;</td>
          <td class="paramname"><em>toseq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed sleep on a waitqueue unconditionally. </p>
<p>The calling task is put to sleep until the waitqueue is signaled by either <a class="el" href="group__rtdm__sync.html#ga2dff689ef2cdc0bb94a143c8bc753a65" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> or <a class="el" href="group__rtdm__sync.html#ga0d9aa704827003402283014c47868d54" title="Broadcast a waitqueue. ">rtdm_waitqueue_broadcast()</a>, or flushed by a call to <a class="el" href="group__rtdm__sync.html#ga6d336f1c5722192f21112133ccec04af" title="Flush a waitqueue. ">rtdm_waitqueue_flush()</a>, or a timeout occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">wq</td><td>waitqueue to wait on.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if the waitqueue has been flushed, or the calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Passing RTDM_TIMEOUT_NONE to <em>timeout</em> makes no sense for such service, and might cause unexpected behavior.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa64a106cb23564a64214da75cb62909d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtdm_timedwait_condition </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C_expr&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&#160;</td>
          <td class="paramname"><em>toseq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed sleep on a waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>condition</em> evaluates to true or a timeout occurs. The condition is checked each time the waitqueue <em>wq</em> is signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">wq</td><td>waitqueue to wait on.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">condition</td><td>C expression for the event to wait for.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdm__sync.html#ga2dff689ef2cdc0bb94a143c8bc753a65" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd>
<dd>
Passing RTDM_TIMEOUT_NONE to <em>timeout</em> makes no sense for such service, and might cause unexpected behavior.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga326d1cf2d9a2542b5af71b3751afd214"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtdm_timedwait_condition_locked </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C_expr&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&#160;</td>
          <td class="paramname"><em>toseq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed sleep on a locked waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>condition</em> evaluates to true or a timeout occurs. The condition is checked each time the waitqueue <em>wq</em> is signaled.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdm__sync.html#gad48c02c6080bc0462ae932431f7ea022" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">condition</td><td>C expression for the event to wait for.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdm__sync.html#ga2dff689ef2cdc0bb94a143c8bc753a65" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd>
<dd>
Passing RTDM_TIMEOUT_NONE to <em>timeout</em> makes no sense for such service, and might cause unexpected behavior.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga937817382e84b0fb04b64f590ea49bfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_timedwait_locked </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_toseq_t *&#160;</td>
          <td class="paramname"><em>toseq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Timed sleep on a locked waitqueue unconditionally. </p>
<p>The calling task is put to sleep until the waitqueue is signaled by either <a class="el" href="group__rtdm__sync.html#ga2dff689ef2cdc0bb94a143c8bc753a65" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> or <a class="el" href="group__rtdm__sync.html#ga0d9aa704827003402283014c47868d54" title="Broadcast a waitqueue. ">rtdm_waitqueue_broadcast()</a>, or flushed by a call to <a class="el" href="group__rtdm__sync.html#ga6d336f1c5722192f21112133ccec04af" title="Flush a waitqueue. ">rtdm_waitqueue_flush()</a>, or a timeout occurs.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdm__sync.html#gad48c02c6080bc0462ae932431f7ea022" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">timeout</td><td>relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values.</td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">toseq</td><td>handle of a timeout sequence as returned by <a class="el" href="group__rtdm__sync.html#ga531ddf80690059302409f760bd7f14d4" title="Initialise a timeout sequence. ">rtdm_toseq_init()</a> or NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if the waitqueue has been flushed, or the calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
<li>-ETIMEDOUT is returned if the if the request has not been satisfied within the specified amount of time.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Passing RTDM_TIMEOUT_NONE to <em>timeout</em> makes no sense for such service, and might cause unexpected behavior.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga531ddf80690059302409f760bd7f14d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_toseq_init </td>
          <td>(</td>
          <td class="paramtype">rtdm_toseq_t *&#160;</td>
          <td class="paramname"><em>timeout_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a timeout sequence. </p>
<p>This service initialises a timeout sequence handle according to the given timeout value. Timeout sequences allow to maintain a continuous <em>timeout</em> across multiple calls of blocking synchronisation services. A typical application scenario is given below.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">timeout_seq</td><td>Timeout sequence handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Relative timeout in nanoseconds, see <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">RTDM_TIMEOUT_xxx</a> for special values</td></tr>
  </table>
  </dd>
</dl>
<p>Application Scenario: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;int device_service_routine(...)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        rtdm_toseq_t timeout_seq;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;        ...</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        rtdm_toseq_init(&amp;timeout_seq, timeout);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        ...</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;        while (received &lt; requested) {</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;                ret = rtdm_event_timedwait(&amp;data_available, timeout, &amp;timeout_seq);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;                if (ret &lt; 0) // including -ETIMEDOUT</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;                        break;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;                // receive some data</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;                ...</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        }</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        ...</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div>
</div><!-- fragment --><p> Using a timeout sequence in such a scenario avoids that the user-provided relative <code>timeout</code> is restarted on every call to <a class="el" href="group__rtdm__sync__event.html#gaf76f858a3951ca2e20d3b1e00afa17e0" title="Wait on event occurrence with timeout. ">rtdm_event_timedwait()</a>, potentially causing an overall delay that is larger than specified by <code>timeout</code>. Moreover, all functions supporting timeout sequences also interpret special timeout values (infinite and non-blocking), disburdening the driver developer from handling them separately.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0dacb9f8ed1fb7ac603b23707e4037a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_wait </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep on a waitqueue unconditionally. </p>
<p>The calling task is put to sleep until the waitqueue is signaled by either <a class="el" href="group__rtdm__sync.html#ga2dff689ef2cdc0bb94a143c8bc753a65" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> or <a class="el" href="group__rtdm__sync.html#ga0d9aa704827003402283014c47868d54" title="Broadcast a waitqueue. ">rtdm_waitqueue_broadcast()</a>, or flushed by a call to <a class="el" href="group__rtdm__sync.html#ga6d336f1c5722192f21112133ccec04af" title="Flush a waitqueue. ">rtdm_waitqueue_flush()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to wait on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if the waitqueue has been flushed, or the calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga16d020cefc20213de5929ed2e72fe918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtdm_wait_condition </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C_expr&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep on a waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>condition</em> evaluates to true. The condition is checked each time the waitqueue <em>wq</em> is signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to wait on</td></tr>
    <tr><td class="paramname">condition</td><td>C expression for the event to wait for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdm__sync.html#ga2dff689ef2cdc0bb94a143c8bc753a65" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab7d93fdcfa827df90060981f5d9455da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtdm_wait_condition_locked </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C_expr&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep on a locked waitqueue until a condition gets true. </p>
<p>The calling task is put to sleep until <em>condition</em> evaluates to true. The condition is checked each time the waitqueue <em>wq</em> is signaled.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdm__sync.html#gad48c02c6080bc0462ae932431f7ea022" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
    <tr><td class="paramname">condition</td><td>C expression for the event to wait for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__rtdm__sync.html#ga2dff689ef2cdc0bb94a143c8bc753a65" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> has to be called after changing any variable that could change the result of the wait condition.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ba9e7856be7279bb7cd1c544ea2eb77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_wait_locked </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep on a locked waitqueue unconditionally. </p>
<p>The calling task is put to sleep until the waitqueue is signaled by either <a class="el" href="group__rtdm__sync.html#ga2dff689ef2cdc0bb94a143c8bc753a65" title="Signal a waitqueue. ">rtdm_waitqueue_signal()</a> or <a class="el" href="group__rtdm__sync.html#ga0d9aa704827003402283014c47868d54" title="Broadcast a waitqueue. ">rtdm_waitqueue_broadcast()</a>, or flushed by a call to <a class="el" href="group__rtdm__sync.html#ga6d336f1c5722192f21112133ccec04af" title="Flush a waitqueue. ">rtdm_waitqueue_flush()</a>.</p>
<p>The waitqueue must have been locked by a call to <a class="el" href="group__rtdm__sync.html#gad48c02c6080bc0462ae932431f7ea022" title="Lock a waitqueue. ">rtdm_waitqueue_lock()</a> prior to calling this service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>locked waitqueue to wait on. The waitqueue lock is dropped when sleeping, then reacquired before this service returns to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if the waitqueue has been flushed, or the calling task has received a Linux signal or has been forcibly unblocked by a call to <a class="el" href="group__rtdm__task.html#gae52cca97ebaf78eec2e31553a4dacd5e" title="Activate a blocked real-time task. ">rtdm_task_unblock()</a>.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d9aa704827003402283014c47868d54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_waitqueue_broadcast </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcast a waitqueue. </p>
<p>Broadcast the waitqueue <em>wq</em>, waking up all waiters. Each readied task may assume to have received the wake up event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to broadcast.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if at least one task has been readied as a result of this call, zero otherwise.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a582c32e371e0a74e4161169dfea85f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_waitqueue_destroy </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_waitqueue *&#160;</td>
          <td class="paramname"><em>wq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a RTDM wait queue. </p>
<p>Dismantles a wait queue structure, releasing all resources attached to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to delete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d336f1c5722192f21112133ccec04af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_waitqueue_flush </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush a waitqueue. </p>
<p>Flushes the waitqueue <em>wq</em>, unblocking all waiters with an error status (-EINTR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to flush.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if at least one task has been readied as a result of this call, zero otherwise.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacad00aabb32f45db716014d22a59ea54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_waitqueue_init </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_waitqueue *&#160;</td>
          <td class="paramname"><em>wq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a RTDM wait queue. </p>
<p>Sets up a wait queue structure for further use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to initialize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad48c02c6080bc0462ae932431f7ea022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_waitqueue_lock </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm__sync__spinlock.html#ga7584217487c323356414e21200a57e63">rtdm_lockctx_t</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a waitqueue. </p>
<p>Acquires the lock on the waitqueue <em>wq</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to lock.</td></tr>
    <tr><td class="paramname">context</td><td>name of local variable to store the context in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Recursive locking might lead to unexpected behavior, including lock up.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2dff689ef2cdc0bb94a143c8bc753a65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_waitqueue_signal </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal a waitqueue. </p>
<p>Signals the waitqueue <em>wq</em>, waking up a single waiter (if any).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if a task has been readied as a result of this call, zero otherwise.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3500d1bf5ed5d77385deb241ede355f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_waitqueue_unlock </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rtdm__sync__spinlock.html#ga7584217487c323356414e21200a57e63">rtdm_lockctx_t</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a waitqueue. </p>
<p>Releases the lock on the waitqueue <em>wq</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to unlock.</td></tr>
    <tr><td class="paramname">context</td><td>name of local variable to retrieve the context from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab6e022df54d9ce21108a950afec8c7c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_waitqueue_wakeup </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_wait_queue *&#160;</td>
          <td class="paramname"><em>wq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rtdm_task_t&#160;</td>
          <td class="paramname"><em>waiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal a particular waiter on a waitqueue. </p>
<p>Signals the waitqueue <em>wq</em>, waking up waiter <em>waiter</em> only, which must be currently sleeping on the waitqueue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wq</td><td>waitqueue to signal.</td></tr>
    <tr><td class="paramname">waiter</td><td>RTDM task to wake up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, might-switch</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
