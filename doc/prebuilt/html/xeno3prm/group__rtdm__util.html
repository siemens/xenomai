<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Utility Services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__rtdm__util.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utility Services<div class="ingroups"><a class="el" href="group__rtdm.html">RTDM</a> &raquo; <a class="el" href="group__rtdm__driver__interface.html">Driver programming interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Utility Services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__rtdm__util.png" border="0" alt="" usemap="#group____rtdm____util"/>
<map name="group____rtdm____util" id="group____rtdm____util">
<area shape="rect" id="node2" href="group__rtdm__driver__interface.html" title="RTDM driver programming interface. " alt="" coords="5,5,141,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga819ed9b5bbfd95e4f833c7f70732cebd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga819ed9b5bbfd95e4f833c7f70732cebd">rtdm_mmap_to_user</a> (struct rtdm_fd *fd, void *src_addr, size_t len, int prot, void **pptr, struct vm_operations_struct *vm_ops, void *vm_private_data)</td></tr>
<tr class="memdesc:ga819ed9b5bbfd95e4f833c7f70732cebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a kernel memory range into the address space of the user.  <a href="#ga819ed9b5bbfd95e4f833c7f70732cebd">More...</a><br /></td></tr>
<tr class="separator:ga819ed9b5bbfd95e4f833c7f70732cebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374220cb7e82c9bd09c83f0c6bf63dae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga374220cb7e82c9bd09c83f0c6bf63dae">rtdm_iomap_to_user</a> (struct rtdm_fd *fd, phys_addr_t src_addr, size_t len, int prot, void **pptr, struct vm_operations_struct *vm_ops, void *vm_private_data)</td></tr>
<tr class="memdesc:ga374220cb7e82c9bd09c83f0c6bf63dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an I/O memory range into the address space of the user.  <a href="#ga374220cb7e82c9bd09c83f0c6bf63dae">More...</a><br /></td></tr>
<tr class="separator:ga374220cb7e82c9bd09c83f0c6bf63dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aee69f7a5fa8c0e2302c8b159b1915a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga3aee69f7a5fa8c0e2302c8b159b1915a">rtdm_mmap_kmem</a> (struct vm_area_struct *vma, void *va)</td></tr>
<tr class="memdesc:ga3aee69f7a5fa8c0e2302c8b159b1915a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a kernel logical memory range to a virtual user area.  <a href="#ga3aee69f7a5fa8c0e2302c8b159b1915a">More...</a><br /></td></tr>
<tr class="separator:ga3aee69f7a5fa8c0e2302c8b159b1915a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaad8fa06fc8607fc44bcc6314afeda1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#gacaad8fa06fc8607fc44bcc6314afeda1">rtdm_mmap_vmem</a> (struct vm_area_struct *vma, void *va)</td></tr>
<tr class="memdesc:gacaad8fa06fc8607fc44bcc6314afeda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a virtual memory range to a virtual user area.  <a href="#gacaad8fa06fc8607fc44bcc6314afeda1">More...</a><br /></td></tr>
<tr class="separator:gacaad8fa06fc8607fc44bcc6314afeda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5b1c69962cac7abf2db3ee04e1cc06b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#gab5b1c69962cac7abf2db3ee04e1cc06b">rtdm_mmap_iomem</a> (struct vm_area_struct *vma, phys_addr_t pa)</td></tr>
<tr class="memdesc:gab5b1c69962cac7abf2db3ee04e1cc06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map an I/O memory range to a virtual user area.  <a href="#gab5b1c69962cac7abf2db3ee04e1cc06b">More...</a><br /></td></tr>
<tr class="separator:gab5b1c69962cac7abf2db3ee04e1cc06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga086b839d1584bd839258b554ea8f2b78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga086b839d1584bd839258b554ea8f2b78">rtdm_munmap</a> (void *ptr, size_t len)</td></tr>
<tr class="memdesc:ga086b839d1584bd839258b554ea8f2b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap a user memory range.  <a href="#ga086b839d1584bd839258b554ea8f2b78">More...</a><br /></td></tr>
<tr class="separator:ga086b839d1584bd839258b554ea8f2b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0b2db892afe1bd77a80f6b8367eb0c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#gab0b2db892afe1bd77a80f6b8367eb0c9">rtdm_ratelimit</a> (struct rtdm_ratelimit_state *rs, const char *func)</td></tr>
<tr class="memdesc:gab0b2db892afe1bd77a80f6b8367eb0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforces a rate limit.  <a href="#gab0b2db892afe1bd77a80f6b8367eb0c9">More...</a><br /></td></tr>
<tr class="separator:gab0b2db892afe1bd77a80f6b8367eb0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac164efcdc1eff8bffe9e22aa933d52f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#gac164efcdc1eff8bffe9e22aa933d52f4">rtdm_printk_ratelimited</a> (const char *format,...)</td></tr>
<tr class="memdesc:gac164efcdc1eff8bffe9e22aa933d52f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-time safe rate-limited message printing on kernel console.  <a href="#gac164efcdc1eff8bffe9e22aa933d52f4">More...</a><br /></td></tr>
<tr class="separator:gac164efcdc1eff8bffe9e22aa933d52f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fe4c8a85d03bec31852634a681791e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga7fe4c8a85d03bec31852634a681791e3">rtdm_printk</a> (const char *format,...)</td></tr>
<tr class="memdesc:ga7fe4c8a85d03bec31852634a681791e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real-time safe message printing on kernel console.  <a href="#ga7fe4c8a85d03bec31852634a681791e3">More...</a><br /></td></tr>
<tr class="separator:ga7fe4c8a85d03bec31852634a681791e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34dfd5c060c67acc684eb4b4256cd4ba"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga34dfd5c060c67acc684eb4b4256cd4ba">rtdm_malloc</a> (size_t size)</td></tr>
<tr class="memdesc:ga34dfd5c060c67acc684eb4b4256cd4ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory block.  <a href="#ga34dfd5c060c67acc684eb4b4256cd4ba">More...</a><br /></td></tr>
<tr class="separator:ga34dfd5c060c67acc684eb4b4256cd4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d15b2cbb2fbf35b88362491af4e6a36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga8d15b2cbb2fbf35b88362491af4e6a36">rtdm_free</a> (void *ptr)</td></tr>
<tr class="memdesc:ga8d15b2cbb2fbf35b88362491af4e6a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release real-time memory block.  <a href="#ga8d15b2cbb2fbf35b88362491af4e6a36">More...</a><br /></td></tr>
<tr class="separator:ga8d15b2cbb2fbf35b88362491af4e6a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af76dc0e9718b977c9c5cf3227bc568"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga0af76dc0e9718b977c9c5cf3227bc568">rtdm_read_user_ok</a> (struct rtdm_fd *fd, const void __user *ptr, size_t size)</td></tr>
<tr class="memdesc:ga0af76dc0e9718b977c9c5cf3227bc568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if read access to user-space memory block is safe.  <a href="#ga0af76dc0e9718b977c9c5cf3227bc568">More...</a><br /></td></tr>
<tr class="separator:ga0af76dc0e9718b977c9c5cf3227bc568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b64192201c51e59766381296c041e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga21b64192201c51e59766381296c041e2">rtdm_rw_user_ok</a> (struct rtdm_fd *fd, const void __user *ptr, size_t size)</td></tr>
<tr class="memdesc:ga21b64192201c51e59766381296c041e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if read/write access to user-space memory block is safe.  <a href="#ga21b64192201c51e59766381296c041e2">More...</a><br /></td></tr>
<tr class="separator:ga21b64192201c51e59766381296c041e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22760692b207b495d109a605bcb6415f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga22760692b207b495d109a605bcb6415f">rtdm_copy_from_user</a> (struct rtdm_fd *fd, void *dst, const void __user *src, size_t size)</td></tr>
<tr class="memdesc:ga22760692b207b495d109a605bcb6415f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy user-space memory block to specified buffer.  <a href="#ga22760692b207b495d109a605bcb6415f">More...</a><br /></td></tr>
<tr class="separator:ga22760692b207b495d109a605bcb6415f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6c47d152ecb633126f8341e749cbfb9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#gaf6c47d152ecb633126f8341e749cbfb9">rtdm_safe_copy_from_user</a> (struct rtdm_fd *fd, void *dst, const void __user *src, size_t size)</td></tr>
<tr class="memdesc:gaf6c47d152ecb633126f8341e749cbfb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if read access to user-space memory block and copy it to specified buffer.  <a href="#gaf6c47d152ecb633126f8341e749cbfb9">More...</a><br /></td></tr>
<tr class="separator:gaf6c47d152ecb633126f8341e749cbfb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b91a150f5462d504616a3193059637"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga71b91a150f5462d504616a3193059637">rtdm_copy_to_user</a> (struct rtdm_fd *fd, void __user *dst, const void *src, size_t size)</td></tr>
<tr class="memdesc:ga71b91a150f5462d504616a3193059637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy specified buffer to user-space memory block.  <a href="#ga71b91a150f5462d504616a3193059637">More...</a><br /></td></tr>
<tr class="separator:ga71b91a150f5462d504616a3193059637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4102000f42918d3a04420dbb601cf17f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga4102000f42918d3a04420dbb601cf17f">rtdm_safe_copy_to_user</a> (struct rtdm_fd *fd, void __user *dst, const void *src, size_t size)</td></tr>
<tr class="memdesc:ga4102000f42918d3a04420dbb601cf17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if read/write access to user-space memory block is safe and copy specified buffer to it.  <a href="#ga4102000f42918d3a04420dbb601cf17f">More...</a><br /></td></tr>
<tr class="separator:ga4102000f42918d3a04420dbb601cf17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb119c817cb05628d8afd3f25319ac75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#gaeb119c817cb05628d8afd3f25319ac75">rtdm_strncpy_from_user</a> (struct rtdm_fd *fd, char *dst, const char __user *src, size_t count)</td></tr>
<tr class="memdesc:gaeb119c817cb05628d8afd3f25319ac75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy user-space string to specified buffer.  <a href="#gaeb119c817cb05628d8afd3f25319ac75">More...</a><br /></td></tr>
<tr class="separator:gaeb119c817cb05628d8afd3f25319ac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f9fcd0e274324096628dfede6fb10f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#ga8f9fcd0e274324096628dfede6fb10f2">rtdm_in_rt_context</a> (void)</td></tr>
<tr class="memdesc:ga8f9fcd0e274324096628dfede6fb10f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if running in a real-time task.  <a href="#ga8f9fcd0e274324096628dfede6fb10f2">More...</a><br /></td></tr>
<tr class="separator:ga8f9fcd0e274324096628dfede6fb10f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab42031be84dba5825ac90dbf28606c54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__util.html#gab42031be84dba5825ac90dbf28606c54">rtdm_rt_capable</a> (struct rtdm_fd *fd)</td></tr>
<tr class="memdesc:gab42031be84dba5825ac90dbf28606c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the caller is capable of running in real-time context.  <a href="#gab42031be84dba5825ac90dbf28606c54">More...</a><br /></td></tr>
<tr class="separator:gab42031be84dba5825ac90dbf28606c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga22760692b207b495d109a605bcb6415f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_copy_from_user </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_fd *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void __user *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy user-space memory block to specified buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>RTDM file descriptor as passed to the invoked device operation handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Destination buffer address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Address of the user-space memory block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if an invalid memory area was accessed.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Before invoking this service, verify via <a class="el" href="group__rtdm__util.html#ga0af76dc0e9718b977c9c5cf3227bc568" title="Check if read access to user-space memory block is safe. ">rtdm_read_user_ok()</a> that the provided user-space address can securely be accessed.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga71b91a150f5462d504616a3193059637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_copy_to_user </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_fd *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void __user *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy specified buffer to user-space memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>RTDM file descriptor as passed to the invoked device operation handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Address of the user-space memory block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source buffer address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if an invalid memory area was accessed.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Before invoking this service, verify via <a class="el" href="group__rtdm__util.html#ga21b64192201c51e59766381296c041e2" title="Check if read/write access to user-space memory block is safe. ">rtdm_rw_user_ok()</a> that the provided user-space address can securely be accessed.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8d15b2cbb2fbf35b88362491af4e6a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release real-time memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to memory block as returned by <a class="el" href="group__rtdm__util.html#ga34dfd5c060c67acc684eb4b4256cd4ba" title="Allocate memory block. ">rtdm_malloc()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f9fcd0e274324096628dfede6fb10f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_in_rt_context </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if running in a real-time task. </p>
<dl class="section return"><dt>Returns</dt><dd>Non-zero is returned if the caller resides in real-time context, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga374220cb7e82c9bd09c83f0c6bf63dae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_iomap_to_user </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_fd *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">phys_addr_t&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct vm_operations_struct *&#160;</td>
          <td class="paramname"><em>vm_ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vm_private_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map an I/O memory range into the address space of the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>RTDM file descriptor as passed to the invoked device operation handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_addr</td><td>physical I/O address to be mapped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the memory range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prot</td><td>Protection flags for the user's memory range, typically either PROT_READ or PROT_READ|PROT_WRITE </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pptr</td><td>Address of a pointer containing the desired user address or NULL on entry and the finally assigned address on return </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vm_ops</td><td>vm_operations to be executed on the vm_area of the user memory range or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vm_private_data</td><td>Private data to be stored in the vm_area, primarily useful for vm_operation handlers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise (most common values):</dd></dl>
<ul>
<li>-EINVAL is returned if an invalid start address, size, or destination address was passed.</li>
<li>-ENOMEM is returned if there is insufficient free memory or the limit of memory mapping for the user process was reached.</li>
<li>-EAGAIN is returned if too much memory has been already locked by the user process.</li>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>RTDM supports two models for unmapping the memory area:<ul>
<li>manual unmapping via <a class="el" href="group__rtdm__util.html#ga086b839d1584bd839258b554ea8f2b78" title="Unmap a user memory range. ">rtdm_munmap()</a>, which may be issued from a driver in response to an IOCTL call, or by a call to the regular munmap() call from the application.</li>
<li>automatic unmapping, triggered by the termination of the process which owns the mapping. To track the number of references pending on the resource mapped, the driver can pass the address of a close handler for the vm_area considered, in the <em>vm_ops</em> descriptor. See the relevant Linux kernel programming documentation (e.g. Linux Device Drivers book) on virtual memory management for details.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga34dfd5c060c67acc684eb4b4256cd4ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rtdm_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Requested size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the allocated block is returned on success, NULL otherwise.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

<p>Referenced by <a class="el" href="group__analogy__subdevice.html#ga217ced9454482fabc81d15beeea71b13">a4l_alloc_subd()</a>.</p>

</div>
</div>
<a class="anchor" id="gab5b1c69962cac7abf2db3ee04e1cc06b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_mmap_iomem </td>
          <td>(</td>
          <td class="paramtype">struct vm_area_struct *&#160;</td>
          <td class="paramname"><em>vma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">phys_addr_t&#160;</td>
          <td class="paramname"><em>pa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map an I/O memory range to a virtual user area. </p>
<p>This routine is commonly used from a -&gt;mmap() handler of a RTDM driver, for mapping an I/O memory area over the user address space referred to by <em>vma</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vma</td><td>The VMA descriptor to receive the mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>The physical I/O address to be mapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise a negated error code is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>To map a chunk of logical space obtained from kmalloc(), or a purely virtual area with no direct physical mapping to a VMA, call <a class="el" href="group__rtdm__util.html#ga3aee69f7a5fa8c0e2302c8b159b1915a" title="Map a kernel logical memory range to a virtual user area. ">rtdm_mmap_kmem()</a> or <a class="el" href="group__rtdm__util.html#gacaad8fa06fc8607fc44bcc6314afeda1" title="Map a virtual memory range to a virtual user area. ">rtdm_mmap_vmem()</a> respectively instead.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3aee69f7a5fa8c0e2302c8b159b1915a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_mmap_kmem </td>
          <td>(</td>
          <td class="paramtype">struct vm_area_struct *&#160;</td>
          <td class="paramname"><em>vma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>va</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a kernel logical memory range to a virtual user area. </p>
<p>This routine is commonly used from a -&gt;mmap() handler of a RTDM driver, for mapping a virtual memory area with a direct physical mapping over the user address space referred to by <em>vma</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vma</td><td>The VMA descriptor to receive the mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">va</td><td>The kernel logical address to be mapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise a negated error code is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This service works on memory regions allocated via kmalloc(). To map a chunk of virtual space with no direct physical mapping, or a physical I/O memory to a VMA, call <a class="el" href="group__rtdm__util.html#gacaad8fa06fc8607fc44bcc6314afeda1" title="Map a virtual memory range to a virtual user area. ">rtdm_mmap_vmem()</a> or <a class="el" href="group__rtdm__util.html#gab5b1c69962cac7abf2db3ee04e1cc06b" title="Map an I/O memory range to a virtual user area. ">rtdm_mmap_iomem()</a> respectively instead.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga819ed9b5bbfd95e4f833c7f70732cebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_mmap_to_user </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_fd *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct vm_operations_struct *&#160;</td>
          <td class="paramname"><em>vm_ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vm_private_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a kernel memory range into the address space of the user. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>RTDM file descriptor as passed to the invoked device operation handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_addr</td><td>Kernel virtual address to be mapped </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the memory range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prot</td><td>Protection flags for the user's memory range, typically either PROT_READ or PROT_READ|PROT_WRITE </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pptr</td><td>Address of a pointer containing the desired user address or NULL on entry and the finally assigned address on return </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vm_ops</td><td>vm_operations to be executed on the vm_area of the user memory range or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vm_private_data</td><td>Private data to be stored in the vm_area, primarily useful for vm_operation handlers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise (most common values):</dd></dl>
<ul>
<li>-EINVAL is returned if an invalid start address, size, or destination address was passed.</li>
<li>-ENOMEM is returned if there is insufficient free memory or the limit of memory mapping for the user process was reached.</li>
<li>-EAGAIN is returned if too much memory has been already locked by the user process.</li>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This service only works on memory regions allocated via kmalloc() or vmalloc(). To map physical I/O memory to user-space use <a class="el" href="group__rtdm__util.html#ga374220cb7e82c9bd09c83f0c6bf63dae" title="Map an I/O memory range into the address space of the user. ">rtdm_iomap_to_user()</a> instead.</dd>
<dd>
RTDM supports two models for unmapping the memory area:<ul>
<li>manual unmapping via <a class="el" href="group__rtdm__util.html#ga086b839d1584bd839258b554ea8f2b78" title="Unmap a user memory range. ">rtdm_munmap()</a>, which may be issued from a driver in response to an IOCTL call, or by a call to the regular munmap() call from the application.</li>
<li>automatic unmapping, triggered by the termination of the process which owns the mapping. To track the number of references pending on the resource mapped, the driver can pass the address of a close handler for the vm_area considered, in the <em>vm_ops</em> descriptor. See the relevant Linux kernel programming documentation (e.g. Linux Device Drivers book) on virtual memory management for details.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gacaad8fa06fc8607fc44bcc6314afeda1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_mmap_vmem </td>
          <td>(</td>
          <td class="paramtype">struct vm_area_struct *&#160;</td>
          <td class="paramname"><em>vma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>va</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a virtual memory range to a virtual user area. </p>
<p>This routine is commonly used from a -&gt;mmap() handler of a RTDM driver, for mapping a purely virtual memory area over the user address space referred to by <em>vma</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vma</td><td>The VMA descriptor to receive the mapping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">va</td><td>The virtual address to be mapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise a negated error code is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This service works on memory regions allocated via vmalloc(). To map a chunk of logical space obtained from kmalloc(), or a physical I/O memory to a VMA, call <a class="el" href="group__rtdm__util.html#ga3aee69f7a5fa8c0e2302c8b159b1915a" title="Map a kernel logical memory range to a virtual user area. ">rtdm_mmap_kmem()</a> or <a class="el" href="group__rtdm__util.html#gab5b1c69962cac7abf2db3ee04e1cc06b" title="Map an I/O memory range to a virtual user area. ">rtdm_mmap_iomem()</a> respectively instead.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga086b839d1584bd839258b554ea8f2b78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_munmap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmap a user memory range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>User address or the memory range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the memory range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if an invalid address or size was passed.</li>
<li>-EPERM <em>may</em> be returned if an illegal invocation environment is detected.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7fe4c8a85d03bec31852634a681791e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_printk </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real-time safe message printing on kernel console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format string (conforming standard <code>printf()</code>) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">...</td><td>Arguments referred by <em>format</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, this service returns the number of characters printed. Otherwise, a negative error code is returned.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac164efcdc1eff8bffe9e22aa933d52f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtdm_printk_ratelimited </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Real-time safe rate-limited message printing on kernel console. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>Format string (conforming standard <code>printf()</code>) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">...</td><td>Arguments referred by <em>format</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, this service returns the number of characters printed. Otherwise, a negative error code is returned.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab0b2db892afe1bd77a80f6b8367eb0c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_ratelimit </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_ratelimit_state *&#160;</td>
          <td class="paramname"><em>rs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enforces a rate limit. </p>
<p>This function enforces a rate limit: not more than <em>rs-&gt;burst</em> callbacks in every <em>rs-&gt;interval</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rs</td><td>rtdm_ratelimit_state data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>name of calling function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 means callback will be suppressed and 1 means go ahead and do it</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

<p>References <a class="el" href="group__rtdm__clock.html#ga6cca1db0fd4c207ad92cdc9e9442afa5">rtdm_clock_read()</a>, <a class="el" href="group__rtdm__sync__spinlock.html#ga24e0b97e35b976fbabd52f4213dc222a">rtdm_lock_get_irqsave</a>, and <a class="el" href="group__rtdm__sync__spinlock.html#gac1c060a2fe602261fa93fdb26a26c69a">rtdm_lock_put_irqrestore()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0af76dc0e9718b977c9c5cf3227bc568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_read_user_ok </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_fd *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void __user *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if read access to user-space memory block is safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>RTDM file descriptor as passed to the invoked device operation handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Address of the user-provided memory block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero is return when it is safe to read from the specified memory block, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab42031be84dba5825ac90dbf28606c54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_rt_capable </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_fd *&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the caller is capable of running in real-time context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>RTDM file descriptor as passed to the invoked device operation handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero is returned if the caller is able to execute in real-time context (independent of its current execution mode), 0 otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function can be used by drivers that provide different implementations for the same service depending on the execution mode of the caller. If a caller requests such a service in non-real-time context but is capable of running in real-time as well, it might be appropriate for the driver to reject the request via -ENOSYS so that RTDM can switch the caller and restart the request in real-time context.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga21b64192201c51e59766381296c041e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_rw_user_ok </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_fd *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void __user *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if read/write access to user-space memory block is safe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>RTDM file descriptor as passed to the invoked device operation handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Address of the user-provided memory block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero is return when it is safe to read from or write to the specified memory block, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6c47d152ecb633126f8341e749cbfb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_safe_copy_from_user </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_fd *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void __user *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if read access to user-space memory block and copy it to specified buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>RTDM file descriptor as passed to the invoked device operation handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Destination buffer address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Address of the user-space memory block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if an invalid memory area was accessed.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This service is a combination of rtdm_read_user_ok and rtdm_copy_from_user.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4102000f42918d3a04420dbb601cf17f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_safe_copy_to_user </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_fd *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void __user *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if read/write access to user-space memory block is safe and copy specified buffer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>RTDM file descriptor as passed to the invoked device operation handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Address of the user-space memory block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Source buffer address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the memory block</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if an invalid memory area was accessed.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This service is a combination of rtdm_rw_user_ok and rtdm_copy_to_user.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb119c817cb05628d8afd3f25319ac75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtdm_strncpy_from_user </td>
          <td>(</td>
          <td class="paramtype">struct rtdm_fd *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char __user *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy user-space string to specified buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>RTDM file descriptor as passed to the invoked device operation handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Destination buffer address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Address of the user-space string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Maximum number of bytes to copy, including the trailing '0'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the string on success (not including the trailing '0'), otherwise:</dd></dl>
<ul>
<li>-EFAULT is returned if an invalid memory area was accessed.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This services already includes a check of the source address, calling <a class="el" href="group__rtdm__util.html#ga0af76dc0e9718b977c9c5cf3227bc568" title="Check if read access to user-space memory block is safe. ">rtdm_read_user_ok()</a> for <em>src</em> explicitly is not required.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
