<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Semaphore services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__alchemy__sem.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Semaphore services<div class="ingroups"><a class="el" href="group__alchemy.html">Alchemy API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Counting semaphore IPC mechanism.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Semaphore services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__alchemy__sem.png" border="0" alt="" usemap="#group____alchemy____sem"/>
<map name="group____alchemy____sem" id="group____alchemy____sem">
<area shape="rect" id="node2" href="group__alchemy.html" title="A programming interface reminiscent from traditional RTOS APIs. " alt="" coords="5,5,104,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRT__SEM__INFO.html">RT_SEM_INFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semaphore status descriptor.  <a href="structRT__SEM__INFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa156922a223af72f82168d17e844488c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__sem.html#gaa156922a223af72f82168d17e844488c">S_PRIO</a>&#160;&#160;&#160;0x1	/* Pend by task priority order. */</td></tr>
<tr class="memdesc:gaa156922a223af72f82168d17e844488c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation flags.  <a href="#gaa156922a223af72f82168d17e844488c">More...</a><br /></td></tr>
<tr class="separator:gaa156922a223af72f82168d17e844488c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaba36e3ac8972ea74feb60640e58d1ceb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__sem.html#gaba36e3ac8972ea74feb60640e58d1ceb">rt_sem_create</a> (RT_SEM *sem, const char *name, unsigned long icount, int mode)</td></tr>
<tr class="memdesc:gaba36e3ac8972ea74feb60640e58d1ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a counting semaphore.  <a href="#gaba36e3ac8972ea74feb60640e58d1ceb">More...</a><br /></td></tr>
<tr class="separator:gaba36e3ac8972ea74feb60640e58d1ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa14cefc4dae46a7c95859e7fe46df888"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__sem.html#gaa14cefc4dae46a7c95859e7fe46df888">rt_sem_delete</a> (RT_SEM *sem)</td></tr>
<tr class="memdesc:gaa14cefc4dae46a7c95859e7fe46df888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a semaphore.  <a href="#gaa14cefc4dae46a7c95859e7fe46df888">More...</a><br /></td></tr>
<tr class="separator:gaa14cefc4dae46a7c95859e7fe46df888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe37d9f5900d80cdb5f729050b74482d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__sem.html#gabe37d9f5900d80cdb5f729050b74482d">rt_sem_p_timed</a> (RT_SEM *sem, const struct timespec *abs_timeout)</td></tr>
<tr class="memdesc:gabe37d9f5900d80cdb5f729050b74482d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pend on a semaphore.  <a href="#gabe37d9f5900d80cdb5f729050b74482d">More...</a><br /></td></tr>
<tr class="separator:gabe37d9f5900d80cdb5f729050b74482d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac481c1f1a2184a998deb2110f2c5b04d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__sem.html#gac481c1f1a2184a998deb2110f2c5b04d">rt_sem_p_until</a> (RT_SEM *sem, RTIME timeout)</td></tr>
<tr class="memdesc:gac481c1f1a2184a998deb2110f2c5b04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pend on a semaphore (with absolute scalar timeout).  <a href="#gac481c1f1a2184a998deb2110f2c5b04d">More...</a><br /></td></tr>
<tr class="separator:gac481c1f1a2184a998deb2110f2c5b04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd299dfe4a53194870bf4e158ca89d1f"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__sem.html#gadd299dfe4a53194870bf4e158ca89d1f">rt_sem_p</a> (RT_SEM *sem, RTIME timeout)</td></tr>
<tr class="memdesc:gadd299dfe4a53194870bf4e158ca89d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pend on a semaphore (with relative scalar timeout).  <a href="#gadd299dfe4a53194870bf4e158ca89d1f">More...</a><br /></td></tr>
<tr class="separator:gadd299dfe4a53194870bf4e158ca89d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5a7927862a511a27741223e08e48270"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__sem.html#gaa5a7927862a511a27741223e08e48270">rt_sem_v</a> (RT_SEM *sem)</td></tr>
<tr class="memdesc:gaa5a7927862a511a27741223e08e48270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a semaphore.  <a href="#gaa5a7927862a511a27741223e08e48270">More...</a><br /></td></tr>
<tr class="separator:gaa5a7927862a511a27741223e08e48270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a8963240e68d164a2e5bb148da44fbc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__sem.html#ga4a8963240e68d164a2e5bb148da44fbc">rt_sem_broadcast</a> (RT_SEM *sem)</td></tr>
<tr class="memdesc:ga4a8963240e68d164a2e5bb148da44fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a semaphore.  <a href="#ga4a8963240e68d164a2e5bb148da44fbc">More...</a><br /></td></tr>
<tr class="separator:ga4a8963240e68d164a2e5bb148da44fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48235bfa78df58a71d7a38582898cb07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__sem.html#ga48235bfa78df58a71d7a38582898cb07">rt_sem_inquire</a> (RT_SEM *sem, <a class="el" href="structRT__SEM__INFO.html">RT_SEM_INFO</a> *info)</td></tr>
<tr class="memdesc:ga48235bfa78df58a71d7a38582898cb07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query semaphore status.  <a href="#ga48235bfa78df58a71d7a38582898cb07">More...</a><br /></td></tr>
<tr class="separator:ga48235bfa78df58a71d7a38582898cb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1520b55854f94b99852d24d1cbd0b29d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__sem.html#ga1520b55854f94b99852d24d1cbd0b29d">rt_sem_bind</a> (RT_SEM *sem, const char *name, RTIME timeout)</td></tr>
<tr class="memdesc:ga1520b55854f94b99852d24d1cbd0b29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to a semaphore.  <a href="#ga1520b55854f94b99852d24d1cbd0b29d">More...</a><br /></td></tr>
<tr class="separator:ga1520b55854f94b99852d24d1cbd0b29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga851cc0b485d43b52f580f75c72afe2a3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__sem.html#ga851cc0b485d43b52f580f75c72afe2a3">rt_sem_unbind</a> (RT_SEM *sem)</td></tr>
<tr class="memdesc:ga851cc0b485d43b52f580f75c72afe2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind from a semaphore.  <a href="#ga851cc0b485d43b52f580f75c72afe2a3">More...</a><br /></td></tr>
<tr class="separator:ga851cc0b485d43b52f580f75c72afe2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Counting semaphore IPC mechanism. </p>
<p>A counting semaphore is a synchronization object for controlling the concurrency level allowed in accessing a resource from multiple real-time tasks, based on the value of a count variable accessed atomically. The semaphore is used through the P ("Proberen", from the Dutch "test and decrement") and V ("Verhogen", increment) operations. The P operation decrements the semaphore count by one if non-zero, or waits until a V operation is issued by another task. Conversely, the V operation releases a resource by incrementing the count by one, unblocking the heading task waiting on the P operation if any. Waiting on a semaphore may cause a priority inversion.</p>
<p>If no more than a single resource is made available at any point in time, the semaphore enforces mutual exclusion and thus can be used to serialize access to a critical section. However, mutexes should be used instead in order to prevent priority inversions, based on the priority inheritance protocol. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaa156922a223af72f82168d17e844488c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define S_PRIO&#160;&#160;&#160;0x1	/* Pend by task priority order. */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation flags. </p>

<p>Referenced by <a class="el" href="group__alchemy__sem.html#gaba36e3ac8972ea74feb60640e58d1ceb">rt_sem_create()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1520b55854f94b99852d24d1cbd0b29d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_bind </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind to a semaphore. </p>
<p>This routine creates a new descriptor to refer to an existing semaphore identified by its symbolic name. If the object does not exist on entry, the caller may block until a semaphore of the given name is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The address of a semaphore descriptor filled in by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td class="paramname">name</td><td>A valid NULL-terminated name which identifies the semaphore to bind to. This string should match the object name argument passed to <a class="el" href="group__alchemy__sem.html#gaba36e3ac8972ea74feb60640e58d1ceb" title="Create a counting semaphore. ">rt_sem_create()</a>.</td></tr>
    <tr><td class="paramname">timeout</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before the retrieval has completed.</li>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a8963240e68d164a2e5bb148da44fbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_broadcast </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcast a semaphore. </p>
<p>All tasks currently waiting on the semaphore are immediately unblocked. The semaphore count is set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The semaphore descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a valid semaphore descriptor.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaba36e3ac8972ea74feb60640e58d1ceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_create </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>icount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a counting semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The address of a semaphore descriptor which can be later used to identify uniquely the created object, upon success of this call.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the semaphore. When non-NULL and non-empty, a copy of this string is used for indexing the created semaphore into the object registry.</td></tr>
    <tr><td class="paramname">icount</td><td>The initial value of the counting semaphore.</td></tr>
    <tr><td class="paramname">mode</td><td>The semaphore creation mode. The following flags can be OR'ed into this bitmask:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>S_FIFO makes tasks pend in FIFO order on the semaphore.</li>
<li>S_PRIO makes tasks pend in priority order on the semaphore.</li>
<li>S_PULSE causes the semaphore to behave in "pulse" mode. In this mode, the V (signal) operation attempts to release a single waiter each time it is called, without incrementing the semaphore count, even if no waiter is pending. For this reason, the semaphore count in pulse mode remains zero.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>icount</em> is non-zero and S_PULSE is set in <em>mode</em>, or <em>mode</em> is otherwise invalid.</li>
<li>-ENOMEM is returned if the system fails to get memory from the main heap in order to create the semaphore.</li>
<li>-EEXIST is returned if the <em>name</em> is conflicting with an already registered semaphore.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Semaphores can be shared by multiple processes which belong to the same Xenomai session. </dd></dl>

<p>References <a class="el" href="group__alchemy__sem.html#gaa156922a223af72f82168d17e844488c">S_PRIO</a>.</p>

</div>
</div>
<a class="anchor" id="gaa14cefc4dae46a7c95859e7fe46df888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_delete </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a semaphore. </p>
<p>This routine deletes a semaphore previously created by a call to <a class="el" href="group__alchemy__sem.html#gaba36e3ac8972ea74feb60640e58d1ceb" title="Create a counting semaphore. ">rt_sem_create()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The semaphore descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a valid semaphore descriptor.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga48235bfa78df58a71d7a38582898cb07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_inquire </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRT__SEM__INFO.html">RT_SEM_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query semaphore status. </p>
<p>This routine returns the status information about the specified semaphore.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The semaphore descriptor.</td></tr>
    <tr><td class="paramname">info</td><td>A pointer to the <a class="el" href="structRT__SEM__INFO.html#RT_SEM_INFO">return</a>buffer" to copy the information to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a valid semaphore descriptor.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted</a> </dd></dl>

<p>References <a class="el" href="structRT__SEM__INFO.html#a0b0e81f66b4e936c603f18bf9641a24b">RT_SEM_INFO::count</a>, <a class="el" href="structRT__SEM__INFO.html#a661011cc10b4fabf562b8ddd92d5dd46">RT_SEM_INFO::name</a>, and <a class="el" href="structRT__SEM__INFO.html#a456c1a4a5b4c2e192e74b23b79993e71">RT_SEM_INFO::nwaiters</a>.</p>

</div>
</div>
<a class="anchor" id="gadd299dfe4a53194870bf4e158ca89d1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_p </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pend on a semaphore (with relative scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__sem.html#gabe37d9f5900d80cdb5f729050b74482d" title="Pend on a semaphore. ">rt_sem_p_timed()</a> accepting a relative timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The semaphore descriptor.</td></tr>
    <tr><td class="paramname">timeout</td><td>A delay expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__sem.html#gabe37d9f5900d80cdb5f729050b74482d">rt_sem_p_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="gabe37d9f5900d80cdb5f729050b74482d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_p_timed </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pend on a semaphore. </p>
<p>Test and decrement the semaphore count. If the semaphore value is greater than zero, it is decremented by one and the service immediately returns to the caller. Otherwise, the caller is blocked until the semaphore is either signaled or destroyed, unless a non-blocking operation was required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The semaphore descriptor.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks, specifying a time limit to wait for the request to be satisfied (see note). Passing NULL causes the caller to block indefinitely until the request is satisfied. Passing { .tv_sec = 0, .tv_nsec = 0 } causes the service to return without blocking in case the request cannot be satisfied immediately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if <em>abs_timeout</em> is reached before the request is satisfied.</li>
<li>-EWOULDBLOCK is returned if <em>abs_timeout</em> is { .tv_sec = 0, .tv_nsec = 0 } and the semaphore count is zero on entry.</li>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before the request is satisfied.</li>
<li>-EINVAL is returned if <em>sem</em> is not a valid semaphore descriptor.</li>
<li>-EIDRM is returned if <em>sem</em> is deleted while the caller was sleeping on it. In such a case, <em>sem</em> is no more valid upon return of this service.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>abs_timeout</em> is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

<p>Referenced by <a class="el" href="group__alchemy__sem.html#gadd299dfe4a53194870bf4e158ca89d1f">rt_sem_p()</a>, and <a class="el" href="group__alchemy__sem.html#gac481c1f1a2184a998deb2110f2c5b04d">rt_sem_p_until()</a>.</p>

</div>
</div>
<a class="anchor" id="gac481c1f1a2184a998deb2110f2c5b04d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_p_until </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pend on a semaphore (with absolute scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__sem.html#gabe37d9f5900d80cdb5f729050b74482d" title="Pend on a semaphore. ">rt_sem_p_timed()</a> accepting an absolute timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The semaphore descriptor.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__sem.html#gabe37d9f5900d80cdb5f729050b74482d">rt_sem_p_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga851cc0b485d43b52f580f75c72afe2a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_unbind </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind from a semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The semaphore descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases a previous binding to a semaphore. After this call has returned, the descriptor is no more valid for referencing this object.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5a7927862a511a27741223e08e48270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_sem_v </td>
          <td>(</td>
          <td class="paramtype">RT_SEM *&#160;</td>
          <td class="paramname"><em>sem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal a semaphore. </p>
<p>If the semaphore is pended, the task heading the wait queue is immediately unblocked. Otherwise, the semaphore count is incremented by one, unless the semaphore is used in "pulse" mode (see <a class="el" href="group__alchemy__sem.html#gaba36e3ac8972ea74feb60640e58d1ceb" title="Create a counting semaphore. ">rt_sem_create()</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sem</td><td>The semaphore descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>sem</em> is not a valid semaphore descriptor.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
