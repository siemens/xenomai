<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Virtual file services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cobalt__core__vfile.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Virtual file services<div class="ingroups"><a class="el" href="group__cobalt.html">Cobalt</a> &raquo; <a class="el" href="group__cobalt__core.html">Cobalt kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Virtual files provide a mean to export Xenomai object states to user-space, based on common kernel interfaces.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Virtual file services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__cobalt__core__vfile.png" border="0" alt="" usemap="#group____cobalt____core____vfile"/>
<map name="group____cobalt____core____vfile" id="group____cobalt____core____vfile">
<area shape="rect" id="node2" href="group__cobalt__core.html" title="The Cobalt core is a co&#45;kernel which supplements the Linux kernel for delivering real&#45;time services w..." alt="" coords="5,5,104,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__lock__ops.html">xnvfile_lock_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vfile locking operations.  <a href="structxnvfile__lock__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__ops.html">xnvfile_regular_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regular vfile operation descriptor.  <a href="structxnvfile__regular__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__regular__iterator.html">xnvfile_regular_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regular vfile iterator.  <a href="structxnvfile__regular__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__ops.html">xnvfile_snapshot_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snapshot vfile operation descriptor.  <a href="structxnvfile__snapshot__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__rev__tag.html">xnvfile_rev_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snapshot revision tag.  <a href="structxnvfile__rev__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot.html">xnvfile_snapshot</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snapshot vfile descriptor.  <a href="structxnvfile__snapshot.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxnvfile__snapshot__iterator.html">xnvfile_snapshot_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snapshot-driven vfile iterator.  <a href="structxnvfile__snapshot__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaad513ffc19d0ab33ff1722899841a442"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__vfile.html#gaad513ffc19d0ab33ff1722899841a442">xnvfile_init_snapshot</a> (const char *name, struct <a class="el" href="structxnvfile__snapshot.html">xnvfile_snapshot</a> *vfile, struct xnvfile_directory *parent)</td></tr>
<tr class="memdesc:gaad513ffc19d0ab33ff1722899841a442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a snapshot-driven vfile.  <a href="#gaad513ffc19d0ab33ff1722899841a442">More...</a><br /></td></tr>
<tr class="separator:gaad513ffc19d0ab33ff1722899841a442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b37f521d867ab9a94b15570210f83f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__vfile.html#ga82b37f521d867ab9a94b15570210f83f">xnvfile_init_regular</a> (const char *name, struct xnvfile_regular *vfile, struct xnvfile_directory *parent)</td></tr>
<tr class="memdesc:ga82b37f521d867ab9a94b15570210f83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a regular vfile.  <a href="#ga82b37f521d867ab9a94b15570210f83f">More...</a><br /></td></tr>
<tr class="separator:ga82b37f521d867ab9a94b15570210f83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadafe22257ce52d6e35698f4f66bb93c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__vfile.html#gadafe22257ce52d6e35698f4f66bb93c7">xnvfile_init_dir</a> (const char *name, struct xnvfile_directory *vdir, struct xnvfile_directory *parent)</td></tr>
<tr class="memdesc:gadafe22257ce52d6e35698f4f66bb93c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a virtual directory entry.  <a href="#gadafe22257ce52d6e35698f4f66bb93c7">More...</a><br /></td></tr>
<tr class="separator:gadafe22257ce52d6e35698f4f66bb93c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f28290884ca3c4458ac67e2b1845502"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__vfile.html#ga3f28290884ca3c4458ac67e2b1845502">xnvfile_init_link</a> (const char *from, const char *to, struct xnvfile_link *vlink, struct xnvfile_directory *parent)</td></tr>
<tr class="memdesc:ga3f28290884ca3c4458ac67e2b1845502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a virtual link entry.  <a href="#ga3f28290884ca3c4458ac67e2b1845502">More...</a><br /></td></tr>
<tr class="separator:ga3f28290884ca3c4458ac67e2b1845502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5429178db74b9dd23378cb8f0942629e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__vfile.html#ga5429178db74b9dd23378cb8f0942629e">xnvfile_destroy</a> (struct xnvfile *vfile)</td></tr>
<tr class="memdesc:ga5429178db74b9dd23378cb8f0942629e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a virtual file entry.  <a href="#ga5429178db74b9dd23378cb8f0942629e">More...</a><br /></td></tr>
<tr class="separator:ga5429178db74b9dd23378cb8f0942629e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a9005ee997d929f7c8940cfcfcab171"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__vfile.html#ga6a9005ee997d929f7c8940cfcfcab171">xnvfile_get_blob</a> (struct xnvfile_input *input, void *data, size_t size)</td></tr>
<tr class="memdesc:ga6a9005ee997d929f7c8940cfcfcab171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a data bulk written to the vfile.  <a href="#ga6a9005ee997d929f7c8940cfcfcab171">More...</a><br /></td></tr>
<tr class="separator:ga6a9005ee997d929f7c8940cfcfcab171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45ea5410707367c9e032dc36fc30916"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__vfile.html#gae45ea5410707367c9e032dc36fc30916">xnvfile_get_string</a> (struct xnvfile_input *input, char *s, size_t maxlen)</td></tr>
<tr class="memdesc:gae45ea5410707367c9e032dc36fc30916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a C-string written to the vfile.  <a href="#gae45ea5410707367c9e032dc36fc30916">More...</a><br /></td></tr>
<tr class="separator:gae45ea5410707367c9e032dc36fc30916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18746b2aae928c0281ae57ef47086600"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__vfile.html#ga18746b2aae928c0281ae57ef47086600">xnvfile_get_integer</a> (struct xnvfile_input *input, long *valp)</td></tr>
<tr class="memdesc:ga18746b2aae928c0281ae57ef47086600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the string written to the vfile as a long integer.  <a href="#ga18746b2aae928c0281ae57ef47086600">More...</a><br /></td></tr>
<tr class="separator:ga18746b2aae928c0281ae57ef47086600"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga19819c8028fd652f090bd4b8cb698778"><td class="memItemLeft" align="right" valign="top">struct xnvfile_directory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__vfile.html#ga19819c8028fd652f090bd4b8cb698778">cobalt_vfroot</a></td></tr>
<tr class="memdesc:ga19819c8028fd652f090bd4b8cb698778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xenomai vfile root directory.  <a href="#ga19819c8028fd652f090bd4b8cb698778">More...</a><br /></td></tr>
<tr class="separator:ga19819c8028fd652f090bd4b8cb698778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19819c8028fd652f090bd4b8cb698778"><td class="memItemLeft" align="right" valign="top">struct xnvfile_directory&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__vfile.html#ga19819c8028fd652f090bd4b8cb698778">cobalt_vfroot</a></td></tr>
<tr class="memdesc:ga19819c8028fd652f090bd4b8cb698778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Xenomai vfile root directory.  <a href="#ga19819c8028fd652f090bd4b8cb698778">More...</a><br /></td></tr>
<tr class="separator:ga19819c8028fd652f090bd4b8cb698778"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Virtual files provide a mean to export Xenomai object states to user-space, based on common kernel interfaces. </p>
<p>This encapsulation is aimed at:</p>
<ul>
<li>supporting consistent collection of very large record-based output, without encurring latency peaks for undergoing real-time activities.</li>
<li>in the future, hiding discrepancies between linux kernel releases, regarding the proper way to export kernel object states to userland, either via the /proc interface or by any other mean.</li>
</ul>
<p>This virtual file implementation offers record-based read support based on seq_files, single-buffer write support, directory and link handling, all visible from the /proc namespace.</p>
<p>The vfile support exposes four filesystem object types:</p>
<ul>
<li>snapshot-driven file (struct <a class="el" href="structxnvfile__snapshot.html" title="Snapshot vfile descriptor. ">xnvfile_snapshot</a>). This is commonly used to export real-time object states via the /proc filesystem. To minimize the latency involved in protecting the vfile routines from changes applied by real-time code on such objects, a snapshot of the data to output is first taken under proper locking, before the collected data is formatted and sent out in a lockless manner.</li>
</ul>
<p>Because a large number of records may have to be output, the data collection phase is not strictly atomic as a whole, but only protected at record level. The vfile implementation can be notified of updates to the underlying data set, and restart the collection from scratch until the snapshot is fully consistent.</p>
<ul>
<li>regular sequential file (struct xnvfile_regular). This is basically an encapsulated sequential file object as available from the host kernel (i.e. seq_file), with a few additional features to make it more handy in a Xenomai environment, like implicit locking support and shortened declaration for simplest, single-record output.</li>
<li>virtual link (struct xnvfile_link). This is a symbolic link feature integrated with the vfile semantics. The link target is computed dynamically at creation time from a user-given helper routine.</li>
<li>virtual directory (struct xnvfile_directory). A directory object, which can be used to create a hierarchy for ordering a set of vfile objects. </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga5429178db74b9dd23378cb8f0942629e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnvfile_destroy </td>
          <td>(</td>
          <td class="paramtype">struct xnvfile *&#160;</td>
          <td class="paramname"><em>vfile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a virtual file entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vfile</td><td>A pointer to the virtual file descriptor to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a9005ee997d929f7c8940cfcfcab171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t xnvfile_get_blob </td>
          <td>(</td>
          <td class="paramtype">struct xnvfile_input *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in a data bulk written to the vfile. </p>
<p>When writing to a vfile, the associated store() handler from the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_store">snapshot-driven vfile</a> or <a class="el" href="structxnvfile__regular__ops.html#regular_store">regular vfile</a> is called, with a single argument describing the input data. <a class="el" href="group__cobalt__core__vfile.html#ga6a9005ee997d929f7c8940cfcfcab171" title="Read in a data bulk written to the vfile. ">xnvfile_get_blob()</a> retrieves this data as an untyped binary blob, and copies it back to the caller's buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A pointer to the input descriptor passed to the store() handler.</td></tr>
    <tr><td class="paramname">data</td><td>The address of the destination buffer to copy the input data to.</td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of bytes to copy to the destination buffer. If <em>size</em> is larger than the actual data size, the input is truncated to <em>size</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read and copied to the destination buffer upon success. Otherwise, a negative error code is returned:</dd></dl>
<ul>
<li>-EFAULT indicates an invalid source buffer address.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p>Referenced by <a class="el" href="group__cobalt__core__vfile.html#ga18746b2aae928c0281ae57ef47086600">xnvfile_get_integer()</a>, and <a class="el" href="group__cobalt__core__vfile.html#gae45ea5410707367c9e032dc36fc30916">xnvfile_get_string()</a>.</p>

</div>
</div>
<a class="anchor" id="ga18746b2aae928c0281ae57ef47086600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t xnvfile_get_integer </td>
          <td>(</td>
          <td class="paramtype">struct xnvfile_input *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>valp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the string written to the vfile as a long integer. </p>
<p>When writing to a vfile, the associated store() handler from the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_store">snapshot-driven vfile</a> or <a class="el" href="structxnvfile__regular__ops.html#regular_store">regular vfile</a> is called, with a single argument describing the input data. <a class="el" href="group__cobalt__core__vfile.html#ga18746b2aae928c0281ae57ef47086600" title="Evaluate the string written to the vfile as a long integer. ">xnvfile_get_integer()</a> retrieves and interprets this data as a long integer, and copies the resulting value back to <em>valp</em>.</p>
<p>The long integer can be expressed in decimal, octal or hexadecimal bases depending on the prefix found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A pointer to the input descriptor passed to the store() handler.</td></tr>
    <tr><td class="paramname">valp</td><td>The address of a long integer variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters read while evaluating the input as a long integer upon success. Otherwise, a negative error code is returned:</dd></dl>
<ul>
<li>-EINVAL indicates a parse error on the input stream; the written text cannot be evaluated as a long integer.</li>
<li>-EFAULT indicates an invalid source buffer address.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__vfile.html#ga6a9005ee997d929f7c8940cfcfcab171">xnvfile_get_blob()</a>.</p>

</div>
</div>
<a class="anchor" id="gae45ea5410707367c9e032dc36fc30916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t xnvfile_get_string </td>
          <td>(</td>
          <td class="paramtype">struct xnvfile_input *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in a C-string written to the vfile. </p>
<p>When writing to a vfile, the associated store() handler from the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_store">snapshot-driven vfile</a> or <a class="el" href="structxnvfile__regular__ops.html#regular_store">regular vfile</a> is called, with a single argument describing the input data. <a class="el" href="group__cobalt__core__vfile.html#gae45ea5410707367c9e032dc36fc30916" title="Read in a C-string written to the vfile. ">xnvfile_get_string()</a> retrieves this data as a null-terminated character string, and copies it back to the caller's buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>A pointer to the input descriptor passed to the store() handler.</td></tr>
    <tr><td class="paramname">s</td><td>The address of the destination string buffer to copy the input data to.</td></tr>
    <tr><td class="paramname">maxlen</td><td>The maximum number of bytes to copy to the destination buffer, including the ending null character. If <em>maxlen</em> is larger than the actual string length, the input is truncated to <em>maxlen</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters read upon success. Otherwise, a negative error code is returned:</dd></dl>
<ul>
<li>-EFAULT indicates an invalid source buffer address.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__vfile.html#ga6a9005ee997d929f7c8940cfcfcab171">xnvfile_get_blob()</a>.</p>

</div>
</div>
<a class="anchor" id="gadafe22257ce52d6e35698f4f66bb93c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnvfile_init_dir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_directory *&#160;</td>
          <td class="paramname"><em>vdir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_directory *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a virtual directory entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name which should appear in the pseudo-filesystem, identifying the vdir entry.</td></tr>
    <tr><td class="paramname">vdir</td><td>A pointer to the virtual directory descriptor to initialize.</td></tr>
    <tr><td class="paramname">parent</td><td>A pointer to a virtual directory descriptor standing for the parent directory of the new vdir. If NULL, the /proc root directory will be used. /proc/xenomai is mapped on the globally available <em>cobalt_vfroot</em> vdir.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the virtual directory entry cannot be created in the /proc hierarchy.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f28290884ca3c4458ac67e2b1845502"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnvfile_init_link </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_link *&#160;</td>
          <td class="paramname"><em>vlink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_directory *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a virtual link entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The name which should appear in the pseudo-filesystem, identifying the vlink entry.</td></tr>
    <tr><td class="paramname">to</td><td>The target file name which should be referred to symbolically by <em>name</em>.</td></tr>
    <tr><td class="paramname">vlink</td><td>A pointer to the virtual link descriptor to initialize.</td></tr>
    <tr><td class="paramname">parent</td><td>A pointer to a virtual directory descriptor standing for the parent directory of the new vlink. If NULL, the /proc root directory will be used. /proc/xenomai is mapped on the globally available <em>cobalt_vfroot</em> vdir.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the virtual link entry cannot be created in the /proc hierarchy.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga82b37f521d867ab9a94b15570210f83f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnvfile_init_regular </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_regular *&#160;</td>
          <td class="paramname"><em>vfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_directory *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a regular vfile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name which should appear in the pseudo-filesystem, identifying the vfile entry.</td></tr>
    <tr><td class="paramname">vfile</td><td>A pointer to a vfile descriptor to initialize from. The following fields in this structure should be filled in prior to call this routine:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>.privsz is the size (in bytes) of the private data area to be reserved in the <a class="el" href="structxnvfile__regular__iterator.html#regular_iterator">vfile iterator</a>. A NULL value indicates that no private area should be reserved.</li>
<li>entry.lockops is a pointer to a <a class="el" href="structxnvfile__lock__ops.html#vfile_lockops">locking</a>descriptor", defining the lock and unlock operations for the vfile. This pointer may be left to NULL, in which case no locking will be applied.</li>
<li>.ops is a pointer to an <a class="el" href="structxnvfile__regular__ops.html#regular_ops">operation descriptor</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>A pointer to a virtual directory descriptor; the vfile entry will be created into this directory. If NULL, the /proc root directory will be used. /proc/xenomai is mapped on the globally available <em>cobalt_vfroot</em> vdir.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the virtual file entry cannot be created in the /proc hierarchy.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaad513ffc19d0ab33ff1722899841a442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnvfile_init_snapshot </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structxnvfile__snapshot.html">xnvfile_snapshot</a> *&#160;</td>
          <td class="paramname"><em>vfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnvfile_directory *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a snapshot-driven vfile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name which should appear in the pseudo-filesystem, identifying the vfile entry.</td></tr>
    <tr><td class="paramname">vfile</td><td>A pointer to a vfile descriptor to initialize from. The following fields in this structure should be filled in prior to call this routine:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>.privsz is the size (in bytes) of the private data area to be reserved in the <a class="el" href="structxnvfile__snapshot__iterator.html#snapshot_iterator">vfile iterator</a>. A NULL value indicates that no private area should be reserved.</li>
<li>.datasz is the size (in bytes) of a single record to be collected by the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_next">next() handler</a> from the <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_ops">operation descriptor</a>.</li>
<li>.tag is a pointer to a mandatory vfile revision tag structure (struct <a class="el" href="structxnvfile__rev__tag.html" title="Snapshot revision tag. ">xnvfile_rev_tag</a>). This tag will be monitored for changes by the vfile core while collecting data to output, so that any update detected will cause the current snapshot data to be dropped, and the collection to restart from the beginning. To this end, any change to the data which may be part of the collected records, should also invoke xnvfile_touch() on the associated tag.</li>
<li>entry.lockops is a pointer to a <a class="el" href="structxnvfile__lock__ops.html#vfile_lockops">lock descriptor</a>, defining the lock and unlock operations for the vfile. This pointer may be left to NULL, in which case the operations on the nucleus lock (i.e. nklock) will be used internally around calls to data collection handlers (see <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_ops">operation descriptor</a>).</li>
<li>.ops is a pointer to an <a class="el" href="structxnvfile__snapshot__ops.html#snapshot_ops">operation descriptor</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>A pointer to a virtual directory descriptor; the vfile entry will be created into this directory. If NULL, the /proc root directory will be used. /proc/xenomai is mapped on the globally available <em>cobalt_vfroot</em> vdir.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the virtual file entry cannot be created in the /proc hierarchy.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p>References <a class="el" href="structxnvfile__snapshot__ops.html#a7227cb341b314ca9976bdc83528cd7d0">xnvfile_snapshot_ops::store</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga19819c8028fd652f090bd4b8cb698778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnvfile_directory cobalt_vfroot</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Xenomai vfile root directory. </p>
<p>This vdir maps the /proc/xenomai directory. It can be used to create a hierarchy of Xenomai-related vfiles under this root. </p>

</div>
</div>
<a class="anchor" id="ga19819c8028fd652f090bd4b8cb698778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnvfile_directory cobalt_vfroot</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Xenomai vfile root directory. </p>
<p>This vdir maps the /proc/xenomai directory. It can be used to create a hierarchy of Xenomai-related vfiles under this root. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
