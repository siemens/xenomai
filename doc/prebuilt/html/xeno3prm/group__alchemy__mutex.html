<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Mutex services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__alchemy__mutex.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mutex services<div class="ingroups"><a class="el" href="group__alchemy.html">Alchemy API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>POSIXish mutual exclusion servicesl.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Mutex services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__alchemy__mutex.png" border="0" alt="" usemap="#group____alchemy____mutex"/>
<map name="group____alchemy____mutex" id="group____alchemy____mutex">
<area shape="rect" id="node1" href="group__alchemy.html" title="A programming interface reminiscent from traditional RTOS APIs. " alt="" coords="5,5,104,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRT__MUTEX__INFO.html">RT_MUTEX_INFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex status descriptor.  <a href="structRT__MUTEX__INFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac89c13a781e4636acf9e66f02d9feb83"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__mutex.html#gac89c13a781e4636acf9e66f02d9feb83">rt_mutex_create</a> (RT_MUTEX *mutex, const char *name)</td></tr>
<tr class="memdesc:gac89c13a781e4636acf9e66f02d9feb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a mutex.  <a href="#gac89c13a781e4636acf9e66f02d9feb83">More...</a><br /></td></tr>
<tr class="separator:gac89c13a781e4636acf9e66f02d9feb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c2342227f821bd09f580b6a9684179"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__mutex.html#gad0c2342227f821bd09f580b6a9684179">rt_mutex_delete</a> (RT_MUTEX *mutex)</td></tr>
<tr class="memdesc:gad0c2342227f821bd09f580b6a9684179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a mutex.  <a href="#gad0c2342227f821bd09f580b6a9684179">More...</a><br /></td></tr>
<tr class="separator:gad0c2342227f821bd09f580b6a9684179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c91e42bdbf7b7b6e9e2235e98efdf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__mutex.html#gad6c91e42bdbf7b7b6e9e2235e98efdf7">rt_mutex_acquire_timed</a> (RT_MUTEX *mutex, const struct timespec *abs_timeout)</td></tr>
<tr class="memdesc:gad6c91e42bdbf7b7b6e9e2235e98efdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire/lock a mutex (with absolute timeout date).  <a href="#gad6c91e42bdbf7b7b6e9e2235e98efdf7">More...</a><br /></td></tr>
<tr class="separator:gad6c91e42bdbf7b7b6e9e2235e98efdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7ee706d0f898f940d5c1139fa38194"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__mutex.html#ga1d7ee706d0f898f940d5c1139fa38194">rt_mutex_acquire_until</a> (RT_MUTEX *mutex, RTIME timeout)</td></tr>
<tr class="memdesc:ga1d7ee706d0f898f940d5c1139fa38194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire/lock a mutex (with absolute scalar timeout).  <a href="#ga1d7ee706d0f898f940d5c1139fa38194">More...</a><br /></td></tr>
<tr class="separator:ga1d7ee706d0f898f940d5c1139fa38194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a087d5bfeaaf10b6f0a924b272d72c9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__mutex.html#ga8a087d5bfeaaf10b6f0a924b272d72c9">rt_mutex_acquire</a> (RT_MUTEX *mutex, RTIME timeout)</td></tr>
<tr class="memdesc:ga8a087d5bfeaaf10b6f0a924b272d72c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire/lock a mutex (with relative scalar timeout).  <a href="#ga8a087d5bfeaaf10b6f0a924b272d72c9">More...</a><br /></td></tr>
<tr class="separator:ga8a087d5bfeaaf10b6f0a924b272d72c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac87911b7279f55ef2f5f9aefe36ff070"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__mutex.html#gac87911b7279f55ef2f5f9aefe36ff070">rt_mutex_release</a> (RT_MUTEX *mutex)</td></tr>
<tr class="memdesc:gac87911b7279f55ef2f5f9aefe36ff070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release/unlock a mutex.  <a href="#gac87911b7279f55ef2f5f9aefe36ff070">More...</a><br /></td></tr>
<tr class="separator:gac87911b7279f55ef2f5f9aefe36ff070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f7db304bb5a839d81614f00c4cde145"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__mutex.html#ga8f7db304bb5a839d81614f00c4cde145">rt_mutex_inquire</a> (RT_MUTEX *mutex, <a class="el" href="structRT__MUTEX__INFO.html">RT_MUTEX_INFO</a> *info)</td></tr>
<tr class="memdesc:ga8f7db304bb5a839d81614f00c4cde145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query mutex status.  <a href="#ga8f7db304bb5a839d81614f00c4cde145">More...</a><br /></td></tr>
<tr class="separator:ga8f7db304bb5a839d81614f00c4cde145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39b3a0e7f6f6ee41b8068ed59e25d1d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__mutex.html#ga39b3a0e7f6f6ee41b8068ed59e25d1d1">rt_mutex_bind</a> (RT_MUTEX *mutex, const char *name, RTIME timeout)</td></tr>
<tr class="memdesc:ga39b3a0e7f6f6ee41b8068ed59e25d1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to a mutex.  <a href="#ga39b3a0e7f6f6ee41b8068ed59e25d1d1">More...</a><br /></td></tr>
<tr class="separator:ga39b3a0e7f6f6ee41b8068ed59e25d1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f308046a8fb83442d5d97e33d0516a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__mutex.html#ga3f308046a8fb83442d5d97e33d0516a4">rt_mutex_unbind</a> (RT_MUTEX *mutex)</td></tr>
<tr class="memdesc:ga3f308046a8fb83442d5d97e33d0516a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind from a mutex.  <a href="#ga3f308046a8fb83442d5d97e33d0516a4">More...</a><br /></td></tr>
<tr class="separator:ga3f308046a8fb83442d5d97e33d0516a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>POSIXish mutual exclusion servicesl. </p>
<p>A mutex is a MUTual EXclusion object, and is useful for protecting shared data structures from concurrent modifications, and implementing critical sections and monitors.</p>
<p>A mutex has two possible states: unlocked (not owned by any task), and locked (owned by one task). A mutex can never be owned by two different tasks simultaneously. A task attempting to lock a mutex that is already locked by another task is blocked until the latter unlocks the mutex first.</p>
<p>Xenomai mutex services enforce a priority inheritance protocol in order to solve priority inversions. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8a087d5bfeaaf10b6f0a924b272d72c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_acquire </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire/lock a mutex (with relative scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__mutex.html#gad6c91e42bdbf7b7b6e9e2235e98efdf7" title="Acquire/lock a mutex (with absolute timeout date). ">rt_mutex_acquire_timed()</a> accepting a relative timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The mutex descriptor.</td></tr>
    <tr><td class="paramname">timeout</td><td>A delay expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__mutex.html#gad6c91e42bdbf7b7b6e9e2235e98efdf7">rt_mutex_acquire_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="gad6c91e42bdbf7b7b6e9e2235e98efdf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_acquire_timed </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire/lock a mutex (with absolute timeout date). </p>
<p>Attempt to lock a mutex. The calling task is blocked until the mutex is available, in which case it is locked again before this service returns. Xenomai mutexes are implicitely recursive and implement the priority inheritance protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The mutex descriptor.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks, specifying a time limit to wait for the mutex to be available (see note). Passing NULL the caller to block indefinitely. Passing { .tv_sec = 0, .tv_nsec = 0 } causes the service to return immediately without blocking in case <em>mutex</em> is already locked by another task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if <em>abs_timeout</em> is reached before the mutex is available.</li>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is { .tv_sec = 0, .tv_nsec = 0 } and the mutex is not immediately available.</li>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task.</li>
<li>-EINVAL is returned if <em>mutex</em> is not a valid mutex descriptor.</li>
<li>-EIDRM is returned if <em>mutex</em> is deleted while the caller was waiting on it. In such event, <em>mutex</em> is no more valid upon return of this service.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a></dd></dl>
<dl class="section user"><dt>Side effects</dt><dd>Over the Cobalt core, an Alchemy task with priority zero keeps running in primary mode until it releases the mutex, at which point it is switched back to secondary mode automatically.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>abs_timeout</em> is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

<p>References <a class="el" href="group__cobalt__api__mutex.html#ga12809c44718c21544ceb280dc1a53573">pthread_mutex_lock()</a>, <a class="el" href="group__cobalt__api__mutex.html#ga072986d91bfdd73c620385e4351830ba">pthread_mutex_timedlock()</a>, and <a class="el" href="group__cobalt__api__mutex.html#ga27da386211db1a7e9a3b2a0db4d22144">pthread_mutex_trylock()</a>.</p>

<p>Referenced by <a class="el" href="group__alchemy__mutex.html#ga8a087d5bfeaaf10b6f0a924b272d72c9">rt_mutex_acquire()</a>, and <a class="el" href="group__alchemy__mutex.html#ga1d7ee706d0f898f940d5c1139fa38194">rt_mutex_acquire_until()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d7ee706d0f898f940d5c1139fa38194"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_acquire_until </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire/lock a mutex (with absolute scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__mutex.html#gad6c91e42bdbf7b7b6e9e2235e98efdf7" title="Acquire/lock a mutex (with absolute timeout date). ">rt_mutex_acquire_timed()</a> accepting an absolute timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The mutex descriptor.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__mutex.html#gad6c91e42bdbf7b7b6e9e2235e98efdf7">rt_mutex_acquire_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga39b3a0e7f6f6ee41b8068ed59e25d1d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_bind </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind to a mutex. </p>
<p>This routine creates a new descriptor to refer to an existing mutex identified by its symbolic name. If the object not exist on entry, the caller may block until a mutex of the given name is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The address of a mutex descriptor filled in by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td class="paramname">name</td><td>A valid NULL-terminated name which identifies the mutex to bind to. This string should match the object name argument passed to <a class="el" href="group__alchemy__mutex.html#gac89c13a781e4636acf9e66f02d9feb83" title="Create a mutex. ">rt_mutex_create()</a>.</td></tr>
    <tr><td class="paramname">timeout</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before the retrieval has completed.</li>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

</div>
</div>
<a class="anchor" id="gac89c13a781e4636acf9e66f02d9feb83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_create </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a mutex. </p>
<p>Create a mutual exclusion object that allows multiple tasks to synchronize access to a shared resource. A mutex is left in an unlocked state after creation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The address of a mutex descriptor which can be later used to identify uniquely the created object, upon success of this call.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the mutex. When non-NULL and non-empty, a copy of this string is used for indexing the created mutex into the object registry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get memory from the main heap in order to create the mutex.</li>
<li>-EEXIST is returned if the <em>name</em> is conflicting with an already registered mutex.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mutexes can be shared by multiple processes which belong to the same Xenomai session. </dd></dl>

<p>References <a class="el" href="group__cobalt__api__mutex.html#ga7454d249ed94ad5d5e57ba1529d7a7f2">pthread_mutex_init()</a>, <a class="el" href="group__cobalt__api__mutex.html#ga2321aabf58224b06021185708d0f9658">pthread_mutexattr_destroy()</a>, <a class="el" href="group__cobalt__api__mutex.html#gaf98f6b6c483077a39d1400b1de1577b8">pthread_mutexattr_init()</a>, <a class="el" href="group__cobalt__api__mutex.html#ga9c67ad95bb6cc0fb38dcc87b441b16b4">pthread_mutexattr_setprotocol()</a>, <a class="el" href="group__cobalt__api__mutex.html#ga73bd8697b91e0ee9a63c30052ac9f72f">pthread_mutexattr_setpshared()</a>, and <a class="el" href="group__cobalt__api__mutex.html#ga8387c80e660e9426f801ac0217ecfae5">pthread_mutexattr_settype()</a>.</p>

</div>
</div>
<a class="anchor" id="gad0c2342227f821bd09f580b6a9684179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_delete </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a mutex. </p>
<p>This routine deletes a mutex object previously created by a call to <a class="el" href="group__alchemy__mutex.html#gac89c13a781e4636acf9e66f02d9feb83" title="Create a mutex. ">rt_mutex_create()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The mutex descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>alarm</em> is not a valid mutex descriptor.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
<li>-EBUSY is returned upon an attempt to destroy the object referenced by <em>mutex</em> while it is referenced (for example, while being used in a rt_mutex_acquite(), <a class="el" href="group__alchemy__mutex.html#gad6c91e42bdbf7b7b6e9e2235e98efdf7" title="Acquire/lock a mutex (with absolute timeout date). ">rt_mutex_acquire_timed()</a> or <a class="el" href="group__alchemy__mutex.html#ga1d7ee706d0f898f940d5c1139fa38194" title="Acquire/lock a mutex (with absolute scalar timeout). ">rt_mutex_acquire_until()</a> by another task).</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__api__mutex.html#ga3cf620ff3a40af11d79cf28901dc55e2">pthread_mutex_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8f7db304bb5a839d81614f00c4cde145"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_inquire </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRT__MUTEX__INFO.html">RT_MUTEX_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query mutex status. </p>
<p>This routine returns the status information about the specified mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The mutex descriptor.</td></tr>
    <tr><td class="paramname">info</td><td>A pointer to the <a class="el" href="structRT__MUTEX__INFO.html#RT_MUTEX_INFO">return</a>buffer" to copy the information to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mutex</em> is not a valid mutex descriptor.</li>
<li>-EPERM is returned if this service is called from an interrupt context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a> </dd></dl>

<p>References <a class="el" href="structRT__MUTEX__INFO.html#a81d7495c2c822fe5b21498ff5bead3d4">RT_MUTEX_INFO::name</a>, <a class="el" href="structRT__MUTEX__INFO.html#afc07033ecd5df60683b72edc1c4d3de4">RT_MUTEX_INFO::owner</a>, <a class="el" href="group__cobalt__api__mutex.html#ga27da386211db1a7e9a3b2a0db4d22144">pthread_mutex_trylock()</a>, and <a class="el" href="group__cobalt__api__mutex.html#ga96184290ffb60e04c53a52869cf960a2">pthread_mutex_unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="gac87911b7279f55ef2f5f9aefe36ff070"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_release </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release/unlock a mutex. </p>
<p>This routine releases a mutex object previously locked by a call to <a class="el" href="group__alchemy__mutex.html#ga8a087d5bfeaaf10b6f0a924b272d72c9" title="Acquire/lock a mutex (with relative scalar timeout). ">rt_mutex_acquire()</a> or <a class="el" href="group__alchemy__mutex.html#ga1d7ee706d0f898f940d5c1139fa38194" title="Acquire/lock a mutex (with absolute scalar timeout). ">rt_mutex_acquire_until()</a>. If the mutex is pended, the first waiting task (by priority order) is immediately unblocked and transfered the ownership of the mutex; otherwise, the mutex is left in an unlocked state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The mutex descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>alarm</em> is not a valid mutex descriptor.</li>
<li>-EPERM is returned if <em>mutex</em> is not owned by the current task, or more generally if this service was called from a context which cannot own any mutex (e.g. interrupt context).</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__api__mutex.html#ga96184290ffb60e04c53a52869cf960a2">pthread_mutex_unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3f308046a8fb83442d5d97e33d0516a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_mutex_unbind </td>
          <td>(</td>
          <td class="paramtype">RT_MUTEX *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind from a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The mutex descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases a previous binding to a mutex. After this call has returned, the descriptor is no more valid for referencing this object. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
