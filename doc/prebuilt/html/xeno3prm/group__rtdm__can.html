<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: CAN Devices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__rtdm__can.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">CAN Devices<div class="ingroups"><a class="el" href="group__rtdm.html">RTDM</a> &raquo; <a class="el" href="group__rtdm__profiles.html">Device Profiles</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the common interface a RTDM-compliant CAN device has to provide.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for CAN Devices:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__rtdm__can.png" border="0" alt="" usemap="#group____rtdm____can"/>
<map name="group____rtdm____can" id="group____rtdm____can">
<area shape="rect" id="node2" href="group__rtdm__profiles.html" title="Pre&#45;defined classes of real&#45;time devices. " alt="" coords="5,5,116,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__bittime__std.html">can_bittime_std</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard bit-time parameters according to Bosch.  <a href="structcan__bittime__std.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__bittime__btr.html">can_bittime_btr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware-specific BTR bit-times.  <a href="structcan__bittime__btr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__bittime.html">can_bittime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom CAN bit-time definition.  <a href="structcan__bittime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__filter.html">can_filter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter for reception of CAN messages.  <a href="structcan__filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsockaddr__can.html">sockaddr_can</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket address structure for the CAN address family.  <a href="structsockaddr__can.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__frame.html">can_frame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw CAN frame.  <a href="structcan__frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcan__ifreq.html">can_ifreq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN interface request descriptor.  <a href="structcan__ifreq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga546620c7e758f003b24b7fdae4f97bd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga546620c7e758f003b24b7fdae4f97bd4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga546620c7e758f003b24b7fdae4f97bd4">AF_CAN</a>&#160;&#160;&#160;29</td></tr>
<tr class="memdesc:ga546620c7e758f003b24b7fdae4f97bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN address family. <br /></td></tr>
<tr class="separator:ga546620c7e758f003b24b7fdae4f97bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac0c3db7a1e021f17987bcc76893849"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeac0c3db7a1e021f17987bcc76893849"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaeac0c3db7a1e021f17987bcc76893849">PF_CAN</a>&#160;&#160;&#160;<a class="el" href="group__rtdm__can.html#ga546620c7e758f003b24b7fdae4f97bd4">AF_CAN</a></td></tr>
<tr class="memdesc:gaeac0c3db7a1e021f17987bcc76893849"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN protocol family. <br /></td></tr>
<tr class="separator:gaeac0c3db7a1e021f17987bcc76893849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad981aa82a29d828882a2fb4c35c1cdd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gad981aa82a29d828882a2fb4c35c1cdd7">SOL_CAN_RAW</a>&#160;&#160;&#160;103</td></tr>
<tr class="memdesc:gad981aa82a29d828882a2fb4c35c1cdd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN socket levels.  <a href="#gad981aa82a29d828882a2fb4c35c1cdd7">More...</a><br /></td></tr>
<tr class="separator:gad981aa82a29d828882a2fb4c35c1cdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad4cb716102402e9be0b5919cd2dd6ead"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4cb716102402e9be0b5919cd2dd6ead"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gad4cb716102402e9be0b5919cd2dd6ead">can_id_t</a></td></tr>
<tr class="memdesc:gad4cb716102402e9be0b5919cd2dd6ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of CAN id (see <a class="el" href="group__rtdm__can.html#CAN_xxx_MASK">CAN_xxx_MASK</a> and <a class="el" href="group__rtdm__can.html#CAN_xxx_FLAG">CAN_xxx_FLAG</a>) <br /></td></tr>
<tr class="separator:gad4cb716102402e9be0b5919cd2dd6ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3b8d6d39f9bbd387bf74031aba8f4f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae3b8d6d39f9bbd387bf74031aba8f4f5"></a>
typedef <a class="el" href="group__rtdm__can.html#gad4cb716102402e9be0b5919cd2dd6ead">can_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gae3b8d6d39f9bbd387bf74031aba8f4f5">can_err_mask_t</a></td></tr>
<tr class="memdesc:gae3b8d6d39f9bbd387bf74031aba8f4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of CAN error mask. <br /></td></tr>
<tr class="separator:gae3b8d6d39f9bbd387bf74031aba8f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c314e1f81a7211a9778da835202a741"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c314e1f81a7211a9778da835202a741"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a></td></tr>
<tr class="memdesc:ga1c314e1f81a7211a9778da835202a741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baudrate definition in bits per second. <br /></td></tr>
<tr class="separator:ga1c314e1f81a7211a9778da835202a741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a6fb4128854d6fec6e0882df4374f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga94a6fb4128854d6fec6e0882df4374f2"></a>
typedef enum <a class="el" href="group__rtdm__can.html#ga42c4f551b57f47d4e004c02505a01f71">CAN_BITTIME_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga94a6fb4128854d6fec6e0882df4374f2">can_bittime_type_t</a></td></tr>
<tr class="memdesc:ga94a6fb4128854d6fec6e0882df4374f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group__rtdm__can.html#ga42c4f551b57f47d4e004c02505a01f71">CAN_BITTIME_TYPE</a>. <br /></td></tr>
<tr class="separator:ga94a6fb4128854d6fec6e0882df4374f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a129d7188a7cd7b68fbf60ebbfd9e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga47a129d7188a7cd7b68fbf60ebbfd9e8"></a>
typedef enum <a class="el" href="group__rtdm__can.html#gac0d6cdda2cf4abb51116b86bc99acf99">CAN_MODE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga47a129d7188a7cd7b68fbf60ebbfd9e8">can_mode_t</a></td></tr>
<tr class="memdesc:ga47a129d7188a7cd7b68fbf60ebbfd9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group__rtdm__can.html#CAN_MODE">CAN_MODE</a>. <br /></td></tr>
<tr class="separator:ga47a129d7188a7cd7b68fbf60ebbfd9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1db20ee5ae4803157e38db4b6c6150b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa1db20ee5ae4803157e38db4b6c6150b"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaa1db20ee5ae4803157e38db4b6c6150b">can_ctrlmode_t</a></td></tr>
<tr class="memdesc:gaa1db20ee5ae4803157e38db4b6c6150b"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group__rtdm__can.html#CAN_CTRLMODE">CAN_CTRLMODE</a>. <br /></td></tr>
<tr class="separator:gaa1db20ee5ae4803157e38db4b6c6150b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga046ddfab86ca47210233f254bc874c6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga046ddfab86ca47210233f254bc874c6d"></a>
typedef enum <a class="el" href="group__rtdm__can.html#ga8680f5710e1a13d553067cc32c86226b">CAN_STATE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga046ddfab86ca47210233f254bc874c6d">can_state_t</a></td></tr>
<tr class="memdesc:ga046ddfab86ca47210233f254bc874c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See <a class="el" href="group__rtdm__can.html#CAN_STATE">CAN_STATE</a>. <br /></td></tr>
<tr class="separator:ga046ddfab86ca47210233f254bc874c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95d9c00c42529e030dcc8d43a98127a2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcan__filter.html">can_filter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga95d9c00c42529e030dcc8d43a98127a2">can_filter_t</a></td></tr>
<tr class="memdesc:ga95d9c00c42529e030dcc8d43a98127a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter for reception of CAN messages.  <a href="#ga95d9c00c42529e030dcc8d43a98127a2">More...</a><br /></td></tr>
<tr class="separator:ga95d9c00c42529e030dcc8d43a98127a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace340cdd98cbfd2525c9d6b23cdd2188"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcan__frame.html">can_frame</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gace340cdd98cbfd2525c9d6b23cdd2188">can_frame_t</a></td></tr>
<tr class="memdesc:gace340cdd98cbfd2525c9d6b23cdd2188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw CAN frame.  <a href="#gace340cdd98cbfd2525c9d6b23cdd2188">More...</a><br /></td></tr>
<tr class="separator:gace340cdd98cbfd2525c9d6b23cdd2188"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga42c4f551b57f47d4e004c02505a01f71"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga42c4f551b57f47d4e004c02505a01f71">CAN_BITTIME_TYPE</a> { <a class="el" href="group__rtdm__can.html#gga42c4f551b57f47d4e004c02505a01f71a160d7c514df2477f8016ed1bf5a6709f">CAN_BITTIME_STD</a>, 
<a class="el" href="group__rtdm__can.html#gga42c4f551b57f47d4e004c02505a01f71ae164a942c698440f2548bd82fea33e55">CAN_BITTIME_BTR</a>
 }<tr class="memdesc:ga42c4f551b57f47d4e004c02505a01f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported CAN bit-time types.  <a href="group__rtdm__can.html#ga42c4f551b57f47d4e004c02505a01f71">More...</a><br /></td></tr>
<tr class="separator:ga42c4f551b57f47d4e004c02505a01f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CAN ID masks</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpdc1d13648799eb345ac952d96077d2be"></a><a class="anchor" id="CAN_xxx_MASK"></a>Bit masks for masking CAN IDs </p>
</td></tr>
<tr class="memitem:ga83b943dca61d0aad5b07ec01c3317572"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83b943dca61d0aad5b07ec01c3317572"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga83b943dca61d0aad5b07ec01c3317572">CAN_EFF_MASK</a>&#160;&#160;&#160;0x1FFFFFFF</td></tr>
<tr class="memdesc:ga83b943dca61d0aad5b07ec01c3317572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit mask for extended CAN IDs. <br /></td></tr>
<tr class="separator:ga83b943dca61d0aad5b07ec01c3317572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe4fc3f9cab58aeeb463861289e8ce93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe4fc3f9cab58aeeb463861289e8ce93"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gafe4fc3f9cab58aeeb463861289e8ce93">CAN_SFF_MASK</a>&#160;&#160;&#160;0x000007FF</td></tr>
<tr class="memdesc:gafe4fc3f9cab58aeeb463861289e8ce93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit mask for standard CAN IDs. <br /></td></tr>
<tr class="separator:gafe4fc3f9cab58aeeb463861289e8ce93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CAN ID flags</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp14cd9990cc0bd89a94d5749eb40704d4"></a><a class="anchor" id="CAN_xxx_FLAG"></a>Flags within a CAN ID indicating special CAN frame attributes </p>
</td></tr>
<tr class="memitem:ga5ae55ab3741140024858bd7b8762ea42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ae55ab3741140024858bd7b8762ea42"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga5ae55ab3741140024858bd7b8762ea42">CAN_EFF_FLAG</a>&#160;&#160;&#160;0x80000000</td></tr>
<tr class="memdesc:ga5ae55ab3741140024858bd7b8762ea42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extended frame. <br /></td></tr>
<tr class="separator:ga5ae55ab3741140024858bd7b8762ea42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf324d65226057755175038a15d9bbd75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf324d65226057755175038a15d9bbd75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaf324d65226057755175038a15d9bbd75">CAN_RTR_FLAG</a>&#160;&#160;&#160;0x40000000</td></tr>
<tr class="memdesc:gaf324d65226057755175038a15d9bbd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote transmission frame. <br /></td></tr>
<tr class="separator:gaf324d65226057755175038a15d9bbd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24df2eae50a2cef0f7f08c73a246a012"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24df2eae50a2cef0f7f08c73a246a012"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga24df2eae50a2cef0f7f08c73a246a012">CAN_ERR_FLAG</a>&#160;&#160;&#160;0x20000000</td></tr>
<tr class="memdesc:ga24df2eae50a2cef0f7f08c73a246a012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error frame (see <a class="el" href="group__rtdm__can.html#Errors">Errors</a>), not valid in struct <a class="el" href="structcan__filter.html" title="Filter for reception of CAN messages. ">can_filter</a>. <br /></td></tr>
<tr class="separator:ga24df2eae50a2cef0f7f08c73a246a012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cb484fa2d90489f6b4e7a77c254c59f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5cb484fa2d90489f6b4e7a77c254c59f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga5cb484fa2d90489f6b4e7a77c254c59f">CAN_INV_FILTER</a>&#160;&#160;&#160;<a class="el" href="group__rtdm__can.html#ga24df2eae50a2cef0f7f08c73a246a012">CAN_ERR_FLAG</a></td></tr>
<tr class="memdesc:ga5cb484fa2d90489f6b4e7a77c254c59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert CAN filter definition, only valid in struct <a class="el" href="structcan__filter.html" title="Filter for reception of CAN messages. ">can_filter</a>. <br /></td></tr>
<tr class="separator:ga5cb484fa2d90489f6b4e7a77c254c59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Particular CAN protocols</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp7b577d0a81d3d775a98d0963ccf3b373"></a><a class="anchor" id="CAN_PROTO"></a>Possible protocols for the PF_CAN protocol family</p>
<p>Currently only the RAW protocol is supported. </p>
</td></tr>
<tr class="memitem:ga57682d9a1e4f4d90943dbaa683582bf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga57682d9a1e4f4d90943dbaa683582bf5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga57682d9a1e4f4d90943dbaa683582bf5">CAN_RAW</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga57682d9a1e4f4d90943dbaa683582bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw protocol of <code>PF_CAN</code>, applicable to socket type <code>SOCK_RAW</code>. <br /></td></tr>
<tr class="separator:ga57682d9a1e4f4d90943dbaa683582bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CAN operation modes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp760e965317160106d81dfdf2ffff90ef"></a><a class="anchor" id="CAN_MODE"></a>Modes into which CAN controllers can be set </p>
</td></tr>
<tr class="memitem:gac0d6cdda2cf4abb51116b86bc99acf99"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gac0d6cdda2cf4abb51116b86bc99acf99">CAN_MODE</a> { <a class="el" href="group__rtdm__can.html#ggac0d6cdda2cf4abb51116b86bc99acf99a04f549e87bf7ddf764c563062dd76790">CAN_MODE_STOP</a> = 0, 
<a class="el" href="group__rtdm__can.html#ggac0d6cdda2cf4abb51116b86bc99acf99af9c617b6b198770017f6e7198bfb50b6">CAN_MODE_START</a>, 
<a class="el" href="group__rtdm__can.html#ggac0d6cdda2cf4abb51116b86bc99acf99a57866c198e12c54747aca0786dc33e3e">CAN_MODE_SLEEP</a>
 }<tr class="separator:gac0d6cdda2cf4abb51116b86bc99acf99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CAN controller modes</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp6c55ad9e7f45d10972f34fd033dc8680"></a><a class="anchor" id="CAN_CTRLMODE"></a>Special CAN controllers modes, which can be or'ed together.</p>
<dl class="section note"><dt>Note</dt><dd>These modes are hardware-dependent. Please consult the hardware manual of the CAN controller for more detailed information. </dd></dl>
</td></tr>
<tr class="memitem:gae4ba49824d17e7d06300cb8b4a4bff45"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gae4ba49824d17e7d06300cb8b4a4bff45">CAN_CTRLMODE_LISTENONLY</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:gae4ba49824d17e7d06300cb8b4a4bff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19ec0cc4379e80c32cbd333cf7c145e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga19ec0cc4379e80c32cbd333cf7c145e9">CAN_CTRLMODE_LOOPBACK</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:ga19ec0cc4379e80c32cbd333cf7c145e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ac4d541a8af54f03f51e1574676dd19"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga9ac4d541a8af54f03f51e1574676dd19">CAN_CTRLMODE_3_SAMPLES</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:ga9ac4d541a8af54f03f51e1574676dd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
CAN controller states</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbeee666541059166baa8758375561c32"></a><a class="anchor" id="CAN_STATE"></a>States a CAN controller can be in. </p>
</td></tr>
<tr class="memitem:ga8680f5710e1a13d553067cc32c86226b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga8680f5710e1a13d553067cc32c86226b">CAN_STATE</a> { <br />
&#160;&#160;<a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226ba026154ef3a7f9cb633e43ab7e63d769c">CAN_STATE_ERROR_ACTIVE</a> = 0, 
<a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226ba7db2add3bd2ed5a01893a3d2a012ac67">CAN_STATE_ACTIVE</a> = 0, 
<a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226ba15263a89961afbc4e813c7ccfc59e5ff">CAN_STATE_ERROR_WARNING</a> = 1, 
<a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226ba8e8ffc38c3886c8ab4b7a6ebd24db2e1">CAN_STATE_BUS_WARNING</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226bac2cd08cde738273c5e5df8306c48d8ae">CAN_STATE_ERROR_PASSIVE</a> = 2, 
<a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226ba16806979589ee8f20ee84c767903b667">CAN_STATE_BUS_PASSIVE</a> = 2, 
<a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226ba679935a8710667fcb99423d217cd9959">CAN_STATE_BUS_OFF</a>, 
<a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226bacc4b4039f38316b01662d775eeb981ff">CAN_STATE_SCANNING_BAUDRATE</a>, 
<br />
&#160;&#160;<a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226ba644e7a441f2e607b93528d3128508cc8">CAN_STATE_STOPPED</a>, 
<a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226ba2bb74d448dac491e9cfcc7f7bcc14857">CAN_STATE_SLEEPING</a>
<br />
 }<tr class="separator:ga8680f5710e1a13d553067cc32c86226b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Timestamp switches</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp34b6790f0f944121855121121dbb08f7"></a><a class="anchor" id="RTCAN_TIMESTAMPS"></a>Arguments to pass to <a class="el" href="group__rtdm__can.html#gaedd7bd75a1983735052fed62e101e5ce">RTCAN_RTIOC_TAKE_TIMESTAMP</a> </p>
</td></tr>
<tr class="memitem:gae06ad16f505d1ec6c1e55d82ac82ef89"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae06ad16f505d1ec6c1e55d82ac82ef89"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gae06ad16f505d1ec6c1e55d82ac82ef89">RTCAN_TAKE_NO_TIMESTAMPS</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gae06ad16f505d1ec6c1e55d82ac82ef89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch off taking timestamps. <br /></td></tr>
<tr class="separator:gae06ad16f505d1ec6c1e55d82ac82ef89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae39894e7e6d107d4bab150cc0ef993c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae39894e7e6d107d4bab150cc0ef993c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gae39894e7e6d107d4bab150cc0ef993c8">RTCAN_TAKE_TIMESTAMPS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gae39894e7e6d107d4bab150cc0ef993c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do take timestamps. <br /></td></tr>
<tr class="separator:gae39894e7e6d107d4bab150cc0ef993c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
RAW socket options</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf64fde2e62c949159157cfdee8ea762c"></a><a class="anchor" id="Rawsockopts"></a>Setting and getting CAN RAW socket options. </p>
</td></tr>
<tr class="memitem:ga87313c6e632294aa4582899a3bbc89e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga87313c6e632294aa4582899a3bbc89e4">CAN_RAW_FILTER</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:ga87313c6e632294aa4582899a3bbc89e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN filter definition.  <a href="#ga87313c6e632294aa4582899a3bbc89e4">More...</a><br /></td></tr>
<tr class="separator:ga87313c6e632294aa4582899a3bbc89e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga451ba35aa4d0bef48cb7b0416f5b4367"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga451ba35aa4d0bef48cb7b0416f5b4367">CAN_RAW_ERR_FILTER</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="memdesc:ga451ba35aa4d0bef48cb7b0416f5b4367"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN error mask.  <a href="#ga451ba35aa4d0bef48cb7b0416f5b4367">More...</a><br /></td></tr>
<tr class="separator:ga451ba35aa4d0bef48cb7b0416f5b4367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7eb7dc3aa940a0aca20d3a564a147d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaa7eb7dc3aa940a0aca20d3a564a147d9">CAN_RAW_LOOPBACK</a>&#160;&#160;&#160;0x3</td></tr>
<tr class="memdesc:gaa7eb7dc3aa940a0aca20d3a564a147d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN TX loopback.  <a href="#gaa7eb7dc3aa940a0aca20d3a564a147d9">More...</a><br /></td></tr>
<tr class="separator:gaa7eb7dc3aa940a0aca20d3a564a147d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga712942ca3d0d621184fb2019a24677c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga712942ca3d0d621184fb2019a24677c3">CAN_RAW_RECV_OWN_MSGS</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="memdesc:ga712942ca3d0d621184fb2019a24677c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN receive own messages.  <a href="#ga712942ca3d0d621184fb2019a24677c3">More...</a><br /></td></tr>
<tr class="separator:ga712942ca3d0d621184fb2019a24677c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
IOCTLs</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpa18f8b001f56d5e10d81e12685125407"></a><a class="anchor" id="CANIOCTLs"></a>CAN device IOCTLs</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Passing <code>struct ifreq<code> as a request descriptor for CAN IOCTLs is still accepted for backward compatibility, however it is recommended to switch to <code>struct <a class="el" href="structcan__ifreq.html" title="CAN interface request descriptor. ">can_ifreq</a><code> at the first opportunity.</code></code></code></code></dd></dl>
</td></tr>
<tr class="memitem:gaee74ae50c8ea0a6aee277c6f124a3866"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaee74ae50c8ea0a6aee277c6f124a3866">SIOCGIFINDEX</a>&#160;&#160;&#160;defined_by_kernel_header_file</td></tr>
<tr class="memdesc:gaee74ae50c8ea0a6aee277c6f124a3866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get CAN interface index by name.  <a href="#gaee74ae50c8ea0a6aee277c6f124a3866">More...</a><br /></td></tr>
<tr class="separator:gaee74ae50c8ea0a6aee277c6f124a3866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c070037c218b40de849ebf4d299f977"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga7c070037c218b40de849ebf4d299f977">SIOCSCANBAUDRATE</a>&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x01, struct can_ifreq)</td></tr>
<tr class="memdesc:ga7c070037c218b40de849ebf4d299f977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set baud rate.  <a href="#ga7c070037c218b40de849ebf4d299f977">More...</a><br /></td></tr>
<tr class="separator:ga7c070037c218b40de849ebf4d299f977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a3032f07b3a6a2f92eb2ba25a4ff8bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga9a3032f07b3a6a2f92eb2ba25a4ff8bf">SIOCGCANBAUDRATE</a>&#160;&#160;&#160;_IOWR(RTIOC_TYPE_CAN, 0x02, struct can_ifreq)</td></tr>
<tr class="memdesc:ga9a3032f07b3a6a2f92eb2ba25a4ff8bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get baud rate.  <a href="#ga9a3032f07b3a6a2f92eb2ba25a4ff8bf">More...</a><br /></td></tr>
<tr class="separator:ga9a3032f07b3a6a2f92eb2ba25a4ff8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e9547dcb608fd0b8d5cf57f926e5176"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga4e9547dcb608fd0b8d5cf57f926e5176">SIOCSCANCUSTOMBITTIME</a>&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x03, struct can_ifreq)</td></tr>
<tr class="memdesc:ga4e9547dcb608fd0b8d5cf57f926e5176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set custom bit time parameter.  <a href="#ga4e9547dcb608fd0b8d5cf57f926e5176">More...</a><br /></td></tr>
<tr class="separator:ga4e9547dcb608fd0b8d5cf57f926e5176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab92b51127ca47c491069b9f3e5013a7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gab92b51127ca47c491069b9f3e5013a7f">SIOCGCANCUSTOMBITTIME</a>&#160;&#160;&#160;_IOWR(RTIOC_TYPE_CAN, 0x04, struct can_ifreq)</td></tr>
<tr class="memdesc:gab92b51127ca47c491069b9f3e5013a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get custom bit-time parameters.  <a href="#gab92b51127ca47c491069b9f3e5013a7f">More...</a><br /></td></tr>
<tr class="separator:gab92b51127ca47c491069b9f3e5013a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72b56a34fe466bca858b1f5f401e1076"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga72b56a34fe466bca858b1f5f401e1076">SIOCSCANMODE</a>&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x05, struct can_ifreq)</td></tr>
<tr class="memdesc:ga72b56a34fe466bca858b1f5f401e1076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set operation mode of CAN controller.  <a href="#ga72b56a34fe466bca858b1f5f401e1076">More...</a><br /></td></tr>
<tr class="separator:ga72b56a34fe466bca858b1f5f401e1076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5f750db08d56f40489679f22236ef4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga5b5f750db08d56f40489679f22236ef4">SIOCGCANSTATE</a>&#160;&#160;&#160;_IOWR(RTIOC_TYPE_CAN, 0x06, struct can_ifreq)</td></tr>
<tr class="memdesc:ga5b5f750db08d56f40489679f22236ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current state of CAN controller.  <a href="#ga5b5f750db08d56f40489679f22236ef4">More...</a><br /></td></tr>
<tr class="separator:ga5b5f750db08d56f40489679f22236ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26fa69d2cded6e172b96b4a6dc3798df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga26fa69d2cded6e172b96b4a6dc3798df">SIOCSCANCTRLMODE</a>&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x07, struct can_ifreq)</td></tr>
<tr class="memdesc:ga26fa69d2cded6e172b96b4a6dc3798df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set special controller modes.  <a href="#ga26fa69d2cded6e172b96b4a6dc3798df">More...</a><br /></td></tr>
<tr class="separator:ga26fa69d2cded6e172b96b4a6dc3798df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa78d64e69ffd68a20f93a6aa64393d6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaa78d64e69ffd68a20f93a6aa64393d6a">SIOCGCANCTRLMODE</a>&#160;&#160;&#160;_IOWR(RTIOC_TYPE_CAN, 0x08, struct can_ifreq)</td></tr>
<tr class="memdesc:gaa78d64e69ffd68a20f93a6aa64393d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get special controller modes.  <a href="#gaa78d64e69ffd68a20f93a6aa64393d6a">More...</a><br /></td></tr>
<tr class="separator:gaa78d64e69ffd68a20f93a6aa64393d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd7bd75a1983735052fed62e101e5ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaedd7bd75a1983735052fed62e101e5ce">RTCAN_RTIOC_TAKE_TIMESTAMP</a>&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x09, int)</td></tr>
<tr class="memdesc:gaedd7bd75a1983735052fed62e101e5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable storing a high precision timestamp upon reception of a CAN frame.  <a href="#gaedd7bd75a1983735052fed62e101e5ce">More...</a><br /></td></tr>
<tr class="separator:gaedd7bd75a1983735052fed62e101e5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8af08ea3624e8e9c464ff143fcb66c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gad8af08ea3624e8e9c464ff143fcb66c0">RTCAN_RTIOC_RCV_TIMEOUT</a>&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x0A, nanosecs_rel_t)</td></tr>
<tr class="memdesc:gad8af08ea3624e8e9c464ff143fcb66c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a reception timeout for a socket.  <a href="#gad8af08ea3624e8e9c464ff143fcb66c0">More...</a><br /></td></tr>
<tr class="separator:gad8af08ea3624e8e9c464ff143fcb66c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3758528585b2779e8949df671f1cf6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gad3758528585b2779e8949df671f1cf6c">RTCAN_RTIOC_SND_TIMEOUT</a>&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x0B, nanosecs_rel_t)</td></tr>
<tr class="memdesc:gad3758528585b2779e8949df671f1cf6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a transmission timeout for a socket.  <a href="#gad3758528585b2779e8949df671f1cf6c">More...</a><br /></td></tr>
<tr class="separator:gad3758528585b2779e8949df671f1cf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Error mask</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf0be135a9595bb41685bc587f6b1e7a8"></a><a class="anchor" id="Errors"></a>Error class (mask) in <code>can_id</code> field of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame. ">can_frame</a> to be used with <a class="el" href="group__rtdm__can.html#ga451ba35aa4d0bef48cb7b0416f5b4367">CAN_RAW_ERR_FILTER</a>.</p>
<p><b>Note:</b> Error reporting is hardware dependent and most CAN controllers report less detailed error conditions than the SJA1000.</p>
<p><b>Note:</b> In case of a bus-off error condition (<a class="el" href="group__rtdm__can.html#ga8b0903e35c75de100b97a7b3e368b269">CAN_ERR_BUSOFF</a>), the CAN controller is <b>not</b> restarted automatically. It is the application's responsibility to react appropriately, e.g. calling <a class="el" href="group__rtdm__can.html#ggac0d6cdda2cf4abb51116b86bc99acf99af9c617b6b198770017f6e7198bfb50b6">CAN_MODE_START</a>.</p>
<p><b>Note:</b> Bus error interrupts (<a class="el" href="group__rtdm__can.html#ga0b068b1221129441b89967ee2ddb9f44">CAN_ERR_BUSERROR</a>) are enabled when an application is calling a <a class="el" href="group__rtdm__can.html#Recv">Recv</a> function on a socket listening on bus errors (using <a class="el" href="group__rtdm__can.html#ga451ba35aa4d0bef48cb7b0416f5b4367">CAN_RAW_ERR_FILTER</a>). After one bus error has occured, the interrupt will be disabled to allow the application time for error processing and to efficiently avoid bus error interrupt flooding. </p>
</td></tr>
<tr class="memitem:ga168d1c5d468bad5e52ccbd70c5f37986"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga168d1c5d468bad5e52ccbd70c5f37986"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga168d1c5d468bad5e52ccbd70c5f37986">CAN_ERR_TX_TIMEOUT</a>&#160;&#160;&#160;0x00000001U</td></tr>
<tr class="memdesc:ga168d1c5d468bad5e52ccbd70c5f37986"><td class="mdescLeft">&#160;</td><td class="mdescRight">TX timeout (netdevice driver) <br /></td></tr>
<tr class="separator:ga168d1c5d468bad5e52ccbd70c5f37986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa79a977211fe6534a627541f71373df0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa79a977211fe6534a627541f71373df0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaa79a977211fe6534a627541f71373df0">CAN_ERR_LOSTARB</a>&#160;&#160;&#160;0x00000002U</td></tr>
<tr class="memdesc:gaa79a977211fe6534a627541f71373df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lost arbitration (see <a class="el" href="group__rtdm__can.html#Error0">data[0]</a>) <br /></td></tr>
<tr class="separator:gaa79a977211fe6534a627541f71373df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8086092a2e40c1b0429caaad3b2c8675"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8086092a2e40c1b0429caaad3b2c8675"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga8086092a2e40c1b0429caaad3b2c8675">CAN_ERR_CRTL</a>&#160;&#160;&#160;0x00000004U</td></tr>
<tr class="memdesc:ga8086092a2e40c1b0429caaad3b2c8675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controller problems (see <a class="el" href="group__rtdm__can.html#Error1">data[1]</a>) <br /></td></tr>
<tr class="separator:ga8086092a2e40c1b0429caaad3b2c8675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fdfaa2091c61c2db8caa7a51e8c0037"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0fdfaa2091c61c2db8caa7a51e8c0037"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga0fdfaa2091c61c2db8caa7a51e8c0037">CAN_ERR_PROT</a>&#160;&#160;&#160;0x00000008U</td></tr>
<tr class="memdesc:ga0fdfaa2091c61c2db8caa7a51e8c0037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol violations (see <a class="el" href="group__rtdm__can.html#Error2">data[2]</a>, <a class="el" href="/home/rpm/git/xenomai-3/include/rtdm/uapi/can.h.html#Error3">data[3]</a>) <br /></td></tr>
<tr class="separator:ga0fdfaa2091c61c2db8caa7a51e8c0037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0026f916a985610cc449ffa6a31445f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf0026f916a985610cc449ffa6a31445f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaf0026f916a985610cc449ffa6a31445f">CAN_ERR_TRX</a>&#160;&#160;&#160;0x00000010U</td></tr>
<tr class="memdesc:gaf0026f916a985610cc449ffa6a31445f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transceiver status (see <a class="el" href="group__rtdm__can.html#Error4">data[4]</a>) <br /></td></tr>
<tr class="separator:gaf0026f916a985610cc449ffa6a31445f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbe83f5e81c1c8c767daaf97c5849017"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadbe83f5e81c1c8c767daaf97c5849017"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gadbe83f5e81c1c8c767daaf97c5849017">CAN_ERR_ACK</a>&#160;&#160;&#160;0x00000020U</td></tr>
<tr class="memdesc:gadbe83f5e81c1c8c767daaf97c5849017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Received no ACK on transmission. <br /></td></tr>
<tr class="separator:gadbe83f5e81c1c8c767daaf97c5849017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0903e35c75de100b97a7b3e368b269"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8b0903e35c75de100b97a7b3e368b269"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga8b0903e35c75de100b97a7b3e368b269">CAN_ERR_BUSOFF</a>&#160;&#160;&#160;0x00000040U</td></tr>
<tr class="memdesc:ga8b0903e35c75de100b97a7b3e368b269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bus off. <br /></td></tr>
<tr class="separator:ga8b0903e35c75de100b97a7b3e368b269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b068b1221129441b89967ee2ddb9f44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b068b1221129441b89967ee2ddb9f44"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga0b068b1221129441b89967ee2ddb9f44">CAN_ERR_BUSERROR</a>&#160;&#160;&#160;0x00000080U</td></tr>
<tr class="memdesc:ga0b068b1221129441b89967ee2ddb9f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bus error (may flood!) <br /></td></tr>
<tr class="separator:ga0b068b1221129441b89967ee2ddb9f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54583090d19940d761a224bc0801ec6a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54583090d19940d761a224bc0801ec6a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga54583090d19940d761a224bc0801ec6a">CAN_ERR_RESTARTED</a>&#160;&#160;&#160;0x00000100U</td></tr>
<tr class="memdesc:ga54583090d19940d761a224bc0801ec6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controller restarted. <br /></td></tr>
<tr class="separator:ga54583090d19940d761a224bc0801ec6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4061a08b8c5aa6de3bb390efd3b6bd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4061a08b8c5aa6de3bb390efd3b6bd6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gad4061a08b8c5aa6de3bb390efd3b6bd6">CAN_ERR_MASK</a>&#160;&#160;&#160;0x1FFFFFFFU</td></tr>
<tr class="memdesc:gad4061a08b8c5aa6de3bb390efd3b6bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Omit EFF, RTR, ERR flags. <br /></td></tr>
<tr class="separator:gad4061a08b8c5aa6de3bb390efd3b6bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Arbitration lost error</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpee72c88cd2af8e954beb61937781c7a8"></a><a class="anchor" id="Error0"></a>Error in the data[0] field of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame. ">can_frame</a>. </p>
</td></tr>
<tr class="memitem:ga7fa1bc55bccfadf780c0556c7d4d7fef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga7fa1bc55bccfadf780c0556c7d4d7fef">CAN_ERR_LOSTARB_UNSPEC</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:ga7fa1bc55bccfadf780c0556c7d4d7fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">unspecified  <a href="#ga7fa1bc55bccfadf780c0556c7d4d7fef">More...</a><br /></td></tr>
<tr class="separator:ga7fa1bc55bccfadf780c0556c7d4d7fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Controller problems</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpac5727a5d110ebda71b15fd5e9af5ddb"></a><a class="anchor" id="Error1"></a>Error in the data[1] field of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame. ">can_frame</a>. </p>
</td></tr>
<tr class="memitem:gafcdc17774047f27e70f3c39f6fb66076"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafcdc17774047f27e70f3c39f6fb66076"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gafcdc17774047f27e70f3c39f6fb66076">CAN_ERR_CRTL_UNSPEC</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:gafcdc17774047f27e70f3c39f6fb66076"><td class="mdescLeft">&#160;</td><td class="mdescRight">unspecified <br /></td></tr>
<tr class="separator:gafcdc17774047f27e70f3c39f6fb66076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23d6f05d55b62fffdbd0a50969bc2d04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga23d6f05d55b62fffdbd0a50969bc2d04"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga23d6f05d55b62fffdbd0a50969bc2d04">CAN_ERR_CRTL_RX_OVERFLOW</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ga23d6f05d55b62fffdbd0a50969bc2d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">RX buffer overflow. <br /></td></tr>
<tr class="separator:ga23d6f05d55b62fffdbd0a50969bc2d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1412f1e2cc4f23334ed5ea766d12006"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab1412f1e2cc4f23334ed5ea766d12006"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gab1412f1e2cc4f23334ed5ea766d12006">CAN_ERR_CRTL_TX_OVERFLOW</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:gab1412f1e2cc4f23334ed5ea766d12006"><td class="mdescLeft">&#160;</td><td class="mdescRight">TX buffer overflow. <br /></td></tr>
<tr class="separator:gab1412f1e2cc4f23334ed5ea766d12006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93958bbabe5e2e6d328d8fa5d491a96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae93958bbabe5e2e6d328d8fa5d491a96"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gae93958bbabe5e2e6d328d8fa5d491a96">CAN_ERR_CRTL_RX_WARNING</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:gae93958bbabe5e2e6d328d8fa5d491a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">reached warning level for RX errors <br /></td></tr>
<tr class="separator:gae93958bbabe5e2e6d328d8fa5d491a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab46d1dddb458203ca07e0c351275c549"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab46d1dddb458203ca07e0c351275c549"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gab46d1dddb458203ca07e0c351275c549">CAN_ERR_CRTL_TX_WARNING</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:gab46d1dddb458203ca07e0c351275c549"><td class="mdescLeft">&#160;</td><td class="mdescRight">reached warning level for TX errors <br /></td></tr>
<tr class="separator:gab46d1dddb458203ca07e0c351275c549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga853db0a1bf833caea89e3597a0123c11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga853db0a1bf833caea89e3597a0123c11"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga853db0a1bf833caea89e3597a0123c11">CAN_ERR_CRTL_RX_PASSIVE</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:ga853db0a1bf833caea89e3597a0123c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">reached passive level for RX errors <br /></td></tr>
<tr class="separator:ga853db0a1bf833caea89e3597a0123c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29185de9d3b35414a729af6e0fad6574"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29185de9d3b35414a729af6e0fad6574"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga29185de9d3b35414a729af6e0fad6574">CAN_ERR_CRTL_TX_PASSIVE</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="memdesc:ga29185de9d3b35414a729af6e0fad6574"><td class="mdescLeft">&#160;</td><td class="mdescRight">reached passive level for TX errors <br /></td></tr>
<tr class="separator:ga29185de9d3b35414a729af6e0fad6574"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Protocol error type</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpbfa8d907f596cb6d5845484db7387ded"></a><a class="anchor" id="Error2"></a>Error in the data[2] field of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame. ">can_frame</a>. </p>
</td></tr>
<tr class="memitem:ga6cf7ee3a3d83315ed2589bb3bdb816b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6cf7ee3a3d83315ed2589bb3bdb816b3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga6cf7ee3a3d83315ed2589bb3bdb816b3">CAN_ERR_PROT_UNSPEC</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:ga6cf7ee3a3d83315ed2589bb3bdb816b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">unspecified <br /></td></tr>
<tr class="separator:ga6cf7ee3a3d83315ed2589bb3bdb816b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0443c62a7e861f429f51c7bb6dc4ee23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0443c62a7e861f429f51c7bb6dc4ee23"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga0443c62a7e861f429f51c7bb6dc4ee23">CAN_ERR_PROT_BIT</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ga0443c62a7e861f429f51c7bb6dc4ee23"><td class="mdescLeft">&#160;</td><td class="mdescRight">single bit error <br /></td></tr>
<tr class="separator:ga0443c62a7e861f429f51c7bb6dc4ee23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8f76071caf3ac10abb88be4347b9625"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae8f76071caf3ac10abb88be4347b9625"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gae8f76071caf3ac10abb88be4347b9625">CAN_ERR_PROT_FORM</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:gae8f76071caf3ac10abb88be4347b9625"><td class="mdescLeft">&#160;</td><td class="mdescRight">frame format error <br /></td></tr>
<tr class="separator:gae8f76071caf3ac10abb88be4347b9625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31af2ea01de879fb1d153cb6c0d642f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga31af2ea01de879fb1d153cb6c0d642f8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga31af2ea01de879fb1d153cb6c0d642f8">CAN_ERR_PROT_STUFF</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:ga31af2ea01de879fb1d153cb6c0d642f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit stuffing error <br /></td></tr>
<tr class="separator:ga31af2ea01de879fb1d153cb6c0d642f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b469132ce858c4a0222e367b986343a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b469132ce858c4a0222e367b986343a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga1b469132ce858c4a0222e367b986343a">CAN_ERR_PROT_BIT0</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:ga1b469132ce858c4a0222e367b986343a"><td class="mdescLeft">&#160;</td><td class="mdescRight">unable to send dominant bit <br /></td></tr>
<tr class="separator:ga1b469132ce858c4a0222e367b986343a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13e44854f6873a4a08ba2c9de0544471"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga13e44854f6873a4a08ba2c9de0544471"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga13e44854f6873a4a08ba2c9de0544471">CAN_ERR_PROT_BIT1</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:ga13e44854f6873a4a08ba2c9de0544471"><td class="mdescLeft">&#160;</td><td class="mdescRight">unable to send recessive bit <br /></td></tr>
<tr class="separator:ga13e44854f6873a4a08ba2c9de0544471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c02b06cad0d95b340c1b6294a5f9f9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0c02b06cad0d95b340c1b6294a5f9f9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga0c02b06cad0d95b340c1b6294a5f9f9f">CAN_ERR_PROT_OVERLOAD</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="memdesc:ga0c02b06cad0d95b340c1b6294a5f9f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">bus overload <br /></td></tr>
<tr class="separator:ga0c02b06cad0d95b340c1b6294a5f9f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga460ee0be98290e6916f85c8651d6de05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga460ee0be98290e6916f85c8651d6de05"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga460ee0be98290e6916f85c8651d6de05">CAN_ERR_PROT_ACTIVE</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="memdesc:ga460ee0be98290e6916f85c8651d6de05"><td class="mdescLeft">&#160;</td><td class="mdescRight">active error announcement <br /></td></tr>
<tr class="separator:ga460ee0be98290e6916f85c8651d6de05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabee807ce2e8ccf6eafc9b6f73a9315fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabee807ce2e8ccf6eafc9b6f73a9315fb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gabee807ce2e8ccf6eafc9b6f73a9315fb">CAN_ERR_PROT_TX</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="memdesc:gabee807ce2e8ccf6eafc9b6f73a9315fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">error occured on transmission <br /></td></tr>
<tr class="separator:gabee807ce2e8ccf6eafc9b6f73a9315fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Protocol error location</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8588d528005f5bada92aa41bf11cef30"></a><a class="anchor" id="Error4"></a>Error in the data[4] field of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame. ">can_frame</a>. </p>
</td></tr>
<tr class="memitem:ga4ac83a947ca929b857af6352300ad6d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ac83a947ca929b857af6352300ad6d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga4ac83a947ca929b857af6352300ad6d8">CAN_ERR_PROT_LOC_UNSPEC</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:ga4ac83a947ca929b857af6352300ad6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">unspecified <br /></td></tr>
<tr class="separator:ga4ac83a947ca929b857af6352300ad6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a2392801977b667a4d39083d0c92c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7a2392801977b667a4d39083d0c92c3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaa7a2392801977b667a4d39083d0c92c3">CAN_ERR_PROT_LOC_SOF</a>&#160;&#160;&#160;0x03</td></tr>
<tr class="memdesc:gaa7a2392801977b667a4d39083d0c92c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">start of frame <br /></td></tr>
<tr class="separator:gaa7a2392801977b667a4d39083d0c92c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0592a90c8dba2c8102479e184dcd6c62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0592a90c8dba2c8102479e184dcd6c62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga0592a90c8dba2c8102479e184dcd6c62">CAN_ERR_PROT_LOC_ID28_21</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ga0592a90c8dba2c8102479e184dcd6c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID bits 28 - 21 (SFF: 10 - 3) <br /></td></tr>
<tr class="separator:ga0592a90c8dba2c8102479e184dcd6c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga240923d7f939dd08d2e4f434468e3006"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga240923d7f939dd08d2e4f434468e3006"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga240923d7f939dd08d2e4f434468e3006">CAN_ERR_PROT_LOC_ID20_18</a>&#160;&#160;&#160;0x06</td></tr>
<tr class="memdesc:ga240923d7f939dd08d2e4f434468e3006"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID bits 20 - 18 (SFF: 2 - 0 ) <br /></td></tr>
<tr class="separator:ga240923d7f939dd08d2e4f434468e3006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad70fa4d644d5b71f8891de051643226a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad70fa4d644d5b71f8891de051643226a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gad70fa4d644d5b71f8891de051643226a">CAN_ERR_PROT_LOC_SRTR</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:gad70fa4d644d5b71f8891de051643226a"><td class="mdescLeft">&#160;</td><td class="mdescRight">substitute RTR (SFF: RTR) <br /></td></tr>
<tr class="separator:gad70fa4d644d5b71f8891de051643226a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe7a2839d2ca31e8dd383564b1865c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4fe7a2839d2ca31e8dd383564b1865c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga4fe7a2839d2ca31e8dd383564b1865c1">CAN_ERR_PROT_LOC_IDE</a>&#160;&#160;&#160;0x05</td></tr>
<tr class="memdesc:ga4fe7a2839d2ca31e8dd383564b1865c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">identifier extension <br /></td></tr>
<tr class="separator:ga4fe7a2839d2ca31e8dd383564b1865c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb436ab756394e8844a3925edd92b95c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb436ab756394e8844a3925edd92b95c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gabb436ab756394e8844a3925edd92b95c">CAN_ERR_PROT_LOC_ID17_13</a>&#160;&#160;&#160;0x07</td></tr>
<tr class="memdesc:gabb436ab756394e8844a3925edd92b95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID bits 17-13. <br /></td></tr>
<tr class="separator:gabb436ab756394e8844a3925edd92b95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd6cd3681ebf245896d282daabdac0b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafd6cd3681ebf245896d282daabdac0b7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gafd6cd3681ebf245896d282daabdac0b7">CAN_ERR_PROT_LOC_ID12_05</a>&#160;&#160;&#160;0x0F</td></tr>
<tr class="memdesc:gafd6cd3681ebf245896d282daabdac0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID bits 12-5. <br /></td></tr>
<tr class="separator:gafd6cd3681ebf245896d282daabdac0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bc04bfcae8d6486aa149cd19dd6102"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga00bc04bfcae8d6486aa149cd19dd6102"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga00bc04bfcae8d6486aa149cd19dd6102">CAN_ERR_PROT_LOC_ID04_00</a>&#160;&#160;&#160;0x0E</td></tr>
<tr class="memdesc:ga00bc04bfcae8d6486aa149cd19dd6102"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID bits 4-0. <br /></td></tr>
<tr class="separator:ga00bc04bfcae8d6486aa149cd19dd6102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79567d5df1287ccdd1966d092b5e047c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga79567d5df1287ccdd1966d092b5e047c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga79567d5df1287ccdd1966d092b5e047c">CAN_ERR_PROT_LOC_RTR</a>&#160;&#160;&#160;0x0C</td></tr>
<tr class="memdesc:ga79567d5df1287ccdd1966d092b5e047c"><td class="mdescLeft">&#160;</td><td class="mdescRight">RTR. <br /></td></tr>
<tr class="separator:ga79567d5df1287ccdd1966d092b5e047c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13aa190099e1600314bb8e46e0a693ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga13aa190099e1600314bb8e46e0a693ce"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga13aa190099e1600314bb8e46e0a693ce">CAN_ERR_PROT_LOC_RES1</a>&#160;&#160;&#160;0x0D</td></tr>
<tr class="memdesc:ga13aa190099e1600314bb8e46e0a693ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved bit 1 <br /></td></tr>
<tr class="separator:ga13aa190099e1600314bb8e46e0a693ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe744ebfd9a71b557d3059bc3f8aee56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafe744ebfd9a71b557d3059bc3f8aee56"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gafe744ebfd9a71b557d3059bc3f8aee56">CAN_ERR_PROT_LOC_RES0</a>&#160;&#160;&#160;0x09</td></tr>
<tr class="memdesc:gafe744ebfd9a71b557d3059bc3f8aee56"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved bit 0 <br /></td></tr>
<tr class="separator:gafe744ebfd9a71b557d3059bc3f8aee56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa0ab15f3f4fc974653ff556688046a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2aa0ab15f3f4fc974653ff556688046a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga2aa0ab15f3f4fc974653ff556688046a">CAN_ERR_PROT_LOC_DLC</a>&#160;&#160;&#160;0x0B</td></tr>
<tr class="memdesc:ga2aa0ab15f3f4fc974653ff556688046a"><td class="mdescLeft">&#160;</td><td class="mdescRight">data length code <br /></td></tr>
<tr class="separator:ga2aa0ab15f3f4fc974653ff556688046a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1877b10333d3805f2ea1ef9195a8dee1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1877b10333d3805f2ea1ef9195a8dee1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga1877b10333d3805f2ea1ef9195a8dee1">CAN_ERR_PROT_LOC_DATA</a>&#160;&#160;&#160;0x0A</td></tr>
<tr class="memdesc:ga1877b10333d3805f2ea1ef9195a8dee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">data section <br /></td></tr>
<tr class="separator:ga1877b10333d3805f2ea1ef9195a8dee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e56b5931c70b6ecf21a3b7d9ceebe16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e56b5931c70b6ecf21a3b7d9ceebe16"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga1e56b5931c70b6ecf21a3b7d9ceebe16">CAN_ERR_PROT_LOC_CRC_SEQ</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:ga1e56b5931c70b6ecf21a3b7d9ceebe16"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC sequence. <br /></td></tr>
<tr class="separator:ga1e56b5931c70b6ecf21a3b7d9ceebe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893a0c29cb622265c5d22ba7f26575a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga893a0c29cb622265c5d22ba7f26575a2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga893a0c29cb622265c5d22ba7f26575a2">CAN_ERR_PROT_LOC_CRC_DEL</a>&#160;&#160;&#160;0x18</td></tr>
<tr class="memdesc:ga893a0c29cb622265c5d22ba7f26575a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC delimiter. <br /></td></tr>
<tr class="separator:ga893a0c29cb622265c5d22ba7f26575a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14988a58a4514b44061ab5b942c6bbdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga14988a58a4514b44061ab5b942c6bbdf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga14988a58a4514b44061ab5b942c6bbdf">CAN_ERR_PROT_LOC_ACK</a>&#160;&#160;&#160;0x19</td></tr>
<tr class="memdesc:ga14988a58a4514b44061ab5b942c6bbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">ACK slot. <br /></td></tr>
<tr class="separator:ga14988a58a4514b44061ab5b942c6bbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e928e081ef83a83c2885259fc0a6002"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e928e081ef83a83c2885259fc0a6002"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga8e928e081ef83a83c2885259fc0a6002">CAN_ERR_PROT_LOC_ACK_DEL</a>&#160;&#160;&#160;0x1B</td></tr>
<tr class="memdesc:ga8e928e081ef83a83c2885259fc0a6002"><td class="mdescLeft">&#160;</td><td class="mdescRight">ACK delimiter. <br /></td></tr>
<tr class="separator:ga8e928e081ef83a83c2885259fc0a6002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga811713c9831116e6e6c42631fb7d287a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga811713c9831116e6e6c42631fb7d287a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga811713c9831116e6e6c42631fb7d287a">CAN_ERR_PROT_LOC_EOF</a>&#160;&#160;&#160;0x1A</td></tr>
<tr class="memdesc:ga811713c9831116e6e6c42631fb7d287a"><td class="mdescLeft">&#160;</td><td class="mdescRight">end of frame <br /></td></tr>
<tr class="separator:ga811713c9831116e6e6c42631fb7d287a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac52eb448c0ec04421f0e21ccf9a496a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac52eb448c0ec04421f0e21ccf9a496a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gac52eb448c0ec04421f0e21ccf9a496a0">CAN_ERR_PROT_LOC_INTERM</a>&#160;&#160;&#160;0x12</td></tr>
<tr class="memdesc:gac52eb448c0ec04421f0e21ccf9a496a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">intermission <br /></td></tr>
<tr class="separator:gac52eb448c0ec04421f0e21ccf9a496a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2169eab29b3c954598fe6780d98b479a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2169eab29b3c954598fe6780d98b479a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga2169eab29b3c954598fe6780d98b479a">CAN_ERR_TRX_UNSPEC</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="memdesc:ga2169eab29b3c954598fe6780d98b479a"><td class="mdescLeft">&#160;</td><td class="mdescRight">0000 0000 <br /></td></tr>
<tr class="separator:ga2169eab29b3c954598fe6780d98b479a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac39d4c89032cba5c08981182e297c7d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac39d4c89032cba5c08981182e297c7d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gac39d4c89032cba5c08981182e297c7d7">CAN_ERR_TRX_CANH_NO_WIRE</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:gac39d4c89032cba5c08981182e297c7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">0000 0100 <br /></td></tr>
<tr class="separator:gac39d4c89032cba5c08981182e297c7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga294393d4f39d4476d0c57876c3504a98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga294393d4f39d4476d0c57876c3504a98"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga294393d4f39d4476d0c57876c3504a98">CAN_ERR_TRX_CANH_SHORT_TO_BAT</a>&#160;&#160;&#160;0x05</td></tr>
<tr class="memdesc:ga294393d4f39d4476d0c57876c3504a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">0000 0101 <br /></td></tr>
<tr class="separator:ga294393d4f39d4476d0c57876c3504a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ab738e9c73d380f96371f195aa41ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga85ab738e9c73d380f96371f195aa41ab"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga85ab738e9c73d380f96371f195aa41ab">CAN_ERR_TRX_CANH_SHORT_TO_VCC</a>&#160;&#160;&#160;0x06</td></tr>
<tr class="memdesc:ga85ab738e9c73d380f96371f195aa41ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">0000 0110 <br /></td></tr>
<tr class="separator:ga85ab738e9c73d380f96371f195aa41ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga325c4d192a7de24a61b8fcca1d434669"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga325c4d192a7de24a61b8fcca1d434669"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga325c4d192a7de24a61b8fcca1d434669">CAN_ERR_TRX_CANH_SHORT_TO_GND</a>&#160;&#160;&#160;0x07</td></tr>
<tr class="memdesc:ga325c4d192a7de24a61b8fcca1d434669"><td class="mdescLeft">&#160;</td><td class="mdescRight">0000 0111 <br /></td></tr>
<tr class="separator:ga325c4d192a7de24a61b8fcca1d434669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ecc59939f560d7e018af307df03a370"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1ecc59939f560d7e018af307df03a370"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga1ecc59939f560d7e018af307df03a370">CAN_ERR_TRX_CANL_NO_WIRE</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="memdesc:ga1ecc59939f560d7e018af307df03a370"><td class="mdescLeft">&#160;</td><td class="mdescRight">0100 0000 <br /></td></tr>
<tr class="separator:ga1ecc59939f560d7e018af307df03a370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ec9ec512befde085f5a7701d0813fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4ec9ec512befde085f5a7701d0813fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaf4ec9ec512befde085f5a7701d0813fe">CAN_ERR_TRX_CANL_SHORT_TO_BAT</a>&#160;&#160;&#160;0x50</td></tr>
<tr class="memdesc:gaf4ec9ec512befde085f5a7701d0813fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">0101 0000 <br /></td></tr>
<tr class="separator:gaf4ec9ec512befde085f5a7701d0813fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace999081029fcd690f89c76aa8738122"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace999081029fcd690f89c76aa8738122"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gace999081029fcd690f89c76aa8738122">CAN_ERR_TRX_CANL_SHORT_TO_VCC</a>&#160;&#160;&#160;0x60</td></tr>
<tr class="memdesc:gace999081029fcd690f89c76aa8738122"><td class="mdescLeft">&#160;</td><td class="mdescRight">0110 0000 <br /></td></tr>
<tr class="separator:gace999081029fcd690f89c76aa8738122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga428b96738439b9df662a999f1a5f9ffd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga428b96738439b9df662a999f1a5f9ffd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#ga428b96738439b9df662a999f1a5f9ffd">CAN_ERR_TRX_CANL_SHORT_TO_GND</a>&#160;&#160;&#160;0x70</td></tr>
<tr class="memdesc:ga428b96738439b9df662a999f1a5f9ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">0111 0000 <br /></td></tr>
<tr class="separator:ga428b96738439b9df662a999f1a5f9ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaed57dcbd07a56050c8915fcd8bd5ba8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaed57dcbd07a56050c8915fcd8bd5ba8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__rtdm__can.html#gaaed57dcbd07a56050c8915fcd8bd5ba8">CAN_ERR_TRX_CANL_SHORT_TO_CANH</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="memdesc:gaaed57dcbd07a56050c8915fcd8bd5ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">1000 0000 <br /></td></tr>
<tr class="separator:gaaed57dcbd07a56050c8915fcd8bd5ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is the common interface a RTDM-compliant CAN device has to provide. </p>
<p>Feel free to report bugs and comments on this profile to the "Socketcan" mailing list (<a href="#" onclick="location.href='mai'+'lto:'+'Soc'+'ke'+'tca'+'n-'+'cor'+'e@'+'lis'+'ts'+'.be'+'rl'+'ios'+'.d'+'e'; return false;">Socke<span style="display: none;">.nosp@m.</span>tcan<span style="display: none;">.nosp@m.</span>-core<span style="display: none;">.nosp@m.</span>@lis<span style="display: none;">.nosp@m.</span>ts.be<span style="display: none;">.nosp@m.</span>rlio<span style="display: none;">.nosp@m.</span>s.de</a>) or directly to the authors (<a href="#" onclick="location.href='mai'+'lto:'+'wg@'+'gr'+'and'+'eg'+'ger'+'.c'+'om'; return false;">wg@gr<span style="display: none;">.nosp@m.</span>ande<span style="display: none;">.nosp@m.</span>gger.<span style="display: none;">.nosp@m.</span>com</a> or <a href="#" onclick="location.href='mai'+'lto:'+'Seb'+'as'+'tia'+'n.'+'Smo'+'lo'+'rz@'+'st'+'ud.'+'un'+'i-h'+'an'+'nov'+'er'+'.de'; return false;">Sebas<span style="display: none;">.nosp@m.</span>tian<span style="display: none;">.nosp@m.</span>.Smol<span style="display: none;">.nosp@m.</span>orz@<span style="display: none;">.nosp@m.</span>stud.<span style="display: none;">.nosp@m.</span>uni-<span style="display: none;">.nosp@m.</span>hanno<span style="display: none;">.nosp@m.</span>ver.<span style="display: none;">.nosp@m.</span>de</a>).</p>
<p><b>Profile</b> <b>Revision:</b> 2 <br />
<br />
</p><dl class="section user"><dt>Device Characteristics</dt><dd><br />
<a class="el" href="structrtdm__driver.html#rtdm_driver_flags">Device Flags</a>: <code>RTDM_PROTOCOL_DEVICE</code> <br />
<br />
<a class="el" href="structrtdm__driver.html#ae850e1c068bd25f3eedccd58ee59a708">Protocol Family</a>: <code>PF_CAN</code> <br />
<br />
<a class="el" href="structrtdm__driver.html#a65bd52e34ba90bb7961c12962d62aea1">Socket Type</a>: <code>SOCK_RAW</code> <br />
<br />
<a class="el" href="structrtdm__driver.html#rtdm_driver_profile">Device Class</a>: <code>RTDM_CLASS_CAN</code> <br />
<br />
 </dd></dl>
<dl class="section user"><dt>Supported Operations</dt><dd><br />
<b>Socket</b> <br />
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> <br />
Specific return values:<ul>
<li>-EPROTONOSUPPORT (Protocol is not supported by the driver. See <a class="el" href="group__rtdm__can.html#CAN_PROTO">CAN protocols</a> for possible protocols.)</li>
</ul>
<br />
<br />
<b>Close</b> <br />
Blocking calls to any of the <a class="el" href="group__rtdm__can.html#Send">Send</a> or <a class="el" href="group__rtdm__can.html#Recv">Receive</a> functions will be unblocked when the socket is closed and return with an error. <br />
<br />
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> <br />
Specific return values: none <br />
<br />
<br />
<b>IOCTL</b> <br />
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a>. see <a class="el" href="group__rtdm__can.html#CANIOCTLs">below</a> Specific return values: see <a class="el" href="group__rtdm__can.html#CANIOCTLs">below</a> <br />
<br />
<br />
<a class="anchor" id="Bind"></a><b>Bind</b> <br />
Binds a socket to one or all CAN devices (see struct <a class="el" href="structsockaddr__can.html" title="Socket address structure for the CAN address family. ">sockaddr_can</a>). If a filter list has been defined with setsockopt (see <a class="el" href="group__rtdm__can.html#Sockopts">Sockopts</a>), it will be used upon reception of CAN frames to decide whether the bound socket will receive a frame. If no filter has been defined, the socket will receive <b>all</b> CAN frames on the specified interface(s). <br />
<br />
Binding to special interface index <code>0</code> will make the socket receive CAN frames from all CAN interfaces. <br />
<br />
Binding to an interface index is also relevant for the <a class="el" href="group__rtdm__can.html#Send">Send</a> functions because they will transmit a message over the interface the socket is bound to when no socket address is given to them. <br />
<br />
<br />
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> <br />
Specific return values:<ul>
<li>-EFAULT (It was not possible to access user space memory area at the specified address.)</li>
<li>-ENOMEM (Not enough memory to fulfill the operation)</li>
<li>-EINVAL (Invalid address family, or invalid length of address structure)</li>
<li>-ENODEV (Invalid CAN interface index)</li>
<li>-ENOSPC (No enough space for filter list)</li>
<li>-EBADF (Socket is about to be closed)</li>
<li>-EAGAIN (Too many receivers. Old binding (if any) is still active. Close some sockets and try again.)</li>
</ul>
<br />
<br />
<a class="anchor" id="Sockopts"></a><b>Setsockopt, Getsockopt</b><br />
These functions allow to set and get various socket options. Currently, only CAN raw sockets are supported. <br />
<br />
Supported Levels and Options: <br />
<ul>
<li>Level <b>SOL_CAN_RAW</b> : CAN RAW protocol (see <a class="el" href="group__rtdm__can.html#ga57682d9a1e4f4d90943dbaa683582bf5">CAN_RAW</a>)<ul>
<li>Option <a class="el" href="group__rtdm__can.html#ga87313c6e632294aa4582899a3bbc89e4">CAN_RAW_FILTER</a> : CAN filter list</li>
<li>Option <a class="el" href="group__rtdm__can.html#ga451ba35aa4d0bef48cb7b0416f5b4367">CAN_RAW_ERR_FILTER</a> : CAN error mask</li>
<li>Option <a class="el" href="group__rtdm__can.html#gaa7eb7dc3aa940a0aca20d3a564a147d9">CAN_RAW_LOOPBACK</a> : CAN TX loopback to local sockets</li>
</ul>
</li>
</ul>
<br />
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> Specific return values: see links to options above. <br />
<br />
<br />
<a class="anchor" id="Recv"></a><b>Recv, Recvfrom, Recvmsg</b> <br />
These functions receive CAN messages from a socket. Only one message per call can be received, so only one buffer with the correct length must be passed. For <code>SOCK_RAW</code>, this is the size of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame. ">can_frame</a>. <br />
<br />
Unlike a call to one of the <a class="el" href="group__rtdm__can.html#Send">Send</a> functions, a Recv function will not return with an error if an interface is down (due to bus-off or setting of stop mode) or in sleep mode. Moreover, in such a case there may still be some CAN messages in the socket buffer which could be read out successfully. <br />
<br />
It is possible to receive a high precision timestamp with every CAN message. The condition is a former instruction to the socket via <a class="el" href="group__rtdm__can.html#gaedd7bd75a1983735052fed62e101e5ce">RTCAN_RTIOC_TAKE_TIMESTAMP</a>. The timestamp will be copied to the <code>msg_control</code> buffer of <code>struct msghdr</code> if it points to a valid memory location with size of <a class="el" href="group__rtdm.html#gad3b24c25feabadba465f8797d8c7fe27">nanosecs_abs_t</a>. If this is a NULL pointer the timestamp will be discarded silently. <br />
<br />
<b>Note:</b> A <code>msg_controllen</code> of <code>0</code> upon completion of the function call indicates that no timestamp is available for that message. <br />
<br />
Supported Flags [in]:<ul>
<li>MSG_DONTWAIT (By setting this flag the operation will only succeed if it would not block, i.e. if there is a message in the socket buffer. This flag takes precedence over a timeout specified by <a class="el" href="group__rtdm__can.html#gad8af08ea3624e8e9c464ff143fcb66c0">RTCAN_RTIOC_RCV_TIMEOUT</a>.)</li>
<li>MSG_PEEK (Receive a message but leave it in the socket buffer. The next receive operation will get that message again.)</li>
</ul>
<br />
Supported Flags [out]: none <br />
<br />
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">mode-unrestricted</a> <br />
Specific return values:<ul>
<li>Non-negative value (Indicating the successful reception of a CAN message. For <code>SOCK_RAW</code>, this is the size of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame. ">can_frame</a> regardless of the actual size of the payload.)</li>
<li>-EFAULT (It was not possible to access user space memory area at one of the specified addresses.)</li>
<li>-EINVAL (Unsupported flag detected, or invalid length of socket address buffer, or invalid length of message control buffer)</li>
<li>-EMSGSIZE (Zero or more than one iovec buffer passed, or buffer too small)</li>
<li>-EAGAIN (No data available in non-blocking mode)</li>
<li>-EBADF (Socket was closed.)</li>
<li>-EINTR (Operation was interrupted explicitly or by signal.)</li>
<li>-ETIMEDOUT (Timeout)</li>
</ul>
<br />
<br />
<a class="anchor" id="Send"></a><b>Send, Sendto, Sendmsg</b> <br />
These functions send out CAN messages. Only one message per call can be transmitted, so only one buffer with the correct length must be passed. For <code>SOCK_RAW</code>, this is the size of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame. ">can_frame</a>. <br />
<br />
The following only applies to <code>SOCK_RAW:</code> If a socket address of struct <a class="el" href="structsockaddr__can.html" title="Socket address structure for the CAN address family. ">sockaddr_can</a> is given, only <code>can_ifindex</code> is used. It is also possible to omit the socket address. Then the interface the socket is bound to will be used for sending messages. <br />
<br />
If an interface goes down (due to bus-off or setting of stop mode) all senders that were blocked on this interface will be woken up. <br />
<br />
<br />
Supported Flags:<ul>
<li>MSG_DONTWAIT (By setting this flag the transmit operation will only succeed if it would not block. This flag takes precedence over a timeout specified by <a class="el" href="group__rtdm__can.html#gad3758528585b2779e8949df671f1cf6c">RTCAN_RTIOC_SND_TIMEOUT</a>.)</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">mode-unrestricted</a> <br />
Specific return values:<ul>
<li>Non-negative value equal to given buffer size (Indicating the successful completion of the function call. See also note.)</li>
<li>-EOPNOTSUPP (MSG_OOB flag is not supported.)</li>
<li>-EINVAL (Unsupported flag detected <em>or:</em> Invalid length of socket address <em>or:</em> Invalid address family <em>or:</em> Data length code of CAN frame not between 0 and 15 <em>or:</em> CAN standard frame has got an ID not between 0 and 2031)</li>
<li>-EMSGSIZE (Zero or more than one buffer passed or invalid size of buffer)</li>
<li>-EFAULT (It was not possible to access user space memory area at one of the specified addresses.)</li>
<li>-ENXIO (Invalid CAN interface index - <code>0</code> is not allowed here - or socket not bound or rather bound to all interfaces.)</li>
<li>-ENETDOWN (Controller is bus-off or in stopped state.)</li>
<li>-ECOMM (Controller is sleeping)</li>
<li>-EAGAIN (Cannot transmit without blocking but a non-blocking call was requested.)</li>
<li>-EINTR (Operation was interrupted explicitly or by signal)</li>
<li>-EBADF (Socket was closed.)</li>
<li>-ETIMEDOUT (Timeout)</li>
</ul>
<b>Note:</b> A successful completion of the function call does not implicate a successful transmission of the message.</dd></dl>
<p><a class="anchor" id="CANutils"></a></p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga9ac4d541a8af54f03f51e1574676dd19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_CTRLMODE_3_SAMPLES&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triple sampling mode</p>
<p>In this mode the CAN controller uses Triple sampling. </p>

</div>
</div>
<a class="anchor" id="gae4ba49824d17e7d06300cb8b4a4bff45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_CTRLMODE_LISTENONLY&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Listen-Only mode</p>
<p>In this mode the CAN controller would give no acknowledge to the CAN-bus, even if a message is received successfully and messages would not be transmitted. This mode might be useful for bus-monitoring, hot-plugging or throughput analysis. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanconfig_8c-example.html#a3">rtcanconfig.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga19ec0cc4379e80c32cbd333cf7c145e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_CTRLMODE_LOOPBACK&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loopback mode</p>
<p>In this mode the CAN controller does an internal loop-back, a message is transmitted and simultaneously received. That mode can be used for self test operation. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanconfig_8c-example.html#a4">rtcanconfig.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga7fa1bc55bccfadf780c0556c7d4d7fef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_ERR_LOSTARB_UNSPEC&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unspecified </p>
<p>else bit number in bitstream </p>

</div>
</div>
<a class="anchor" id="ga451ba35aa4d0bef48cb7b0416f5b4367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_RAW_ERR_FILTER&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN error mask. </p>
<p>A CAN error mask (see <a class="el" href="group__rtdm__can.html#Errors">Errors</a>) can be set with <code>setsockopt</code>. This mask is then used to decide if error frames are delivered to this socket in case of error condidtions. The error frames are marked with the <a class="el" href="group__rtdm__can.html#ga24df2eae50a2cef0f7f08c73a246a012">CAN_ERR_FLAG</a> of <a class="el" href="group__rtdm__can.html#CAN_xxx_FLAG">CAN_xxx_FLAG</a> and must be handled by the application properly. A detailed description of the errors can be found in the <code>can_id</code> and the <code>data</code> fields of struct <a class="el" href="structcan__frame.html" title="Raw CAN frame. ">can_frame</a> (see <a class="el" href="group__rtdm__can.html#Errors">Errors</a> for futher details).</p>
<p><br />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td><b>SOL_CAN_RAW</b> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td><b>CAN_RAW_ERR_FILTER</b> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optval</td><td>Pointer to error mask of type can_err_mask_t.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optlen</td><td>Size of error mask: sizeof(can_err_mask_t).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> <br />
Specific return values:<ul>
<li>-EFAULT (It was not possible to access user space memory area at the specified address.)</li>
<li>-EINVAL (Invalid length "optlen")</li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanrecv_8c-example.html#a20">rtcanrecv.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga87313c6e632294aa4582899a3bbc89e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_RAW_FILTER&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN filter definition. </p>
<p>A CAN raw filter list with elements of struct <a class="el" href="structcan__filter.html" title="Filter for reception of CAN messages. ">can_filter</a> can be installed with <code>setsockopt</code>. This list is used upon reception of CAN frames to decide whether the bound socket will receive a frame. An empty filter list can also be defined using optlen = 0, which is recommanded for write-only sockets. <br />
If the socket was already bound with <a class="el" href="group__rtdm__can.html#Bind">Bind</a>, the old filter list gets replaced with the new one. Be aware that already received, but not read out CAN frames may stay in the socket buffer. <br />
<br />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td><b>SOL_CAN_RAW</b> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td><b>CAN_RAW_FILTER</b> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optval</td><td>Pointer to array of struct <a class="el" href="structcan__filter.html" title="Filter for reception of CAN messages. ">can_filter</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optlen</td><td>Size of filter list: count * sizeof( struct can_filter). <br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> <br />
Specific return values:<ul>
<li>-EFAULT (It was not possible to access user space memory area at the specified address.)</li>
<li>-ENOMEM (Not enough memory to fulfill the operation)</li>
<li>-EINVAL (Invalid length "optlen")</li>
<li>-ENOSPC (No space to store filter list, check RT-Socket-CAN kernel parameters)</li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="can-rtt_8c-example.html#a15">can-rtt.c</a>, <a class="el" href="rtcanrecv_8c-example.html#a21">rtcanrecv.c</a>, and <a class="el" href="rtcansend_8c-example.html#a14">rtcansend.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaa7eb7dc3aa940a0aca20d3a564a147d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_RAW_LOOPBACK&#160;&#160;&#160;0x3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN TX loopback. </p>
<p>The TX loopback to other local sockets can be selected with this <code>setsockopt</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The TX loopback feature must be enabled in the kernel and then the loopback to other local TX sockets is enabled by default.</dd></dl>
<p><br />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td><b>SOL_CAN_RAW</b> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optname</td><td><b>CAN_RAW_LOOPBACK</b> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optval</td><td>Pointer to integer value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">optlen</td><td>Size of int: sizeof(int).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> <br />
Specific return values:<ul>
<li>-EFAULT (It was not possible to access user space memory area at the specified address.)</li>
<li>-EINVAL (Invalid length "optlen")</li>
<li>-EOPNOTSUPP (not supported, check RT-Socket-CAN kernel parameters). </li>
</ul>
</dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcansend_8c-example.html#a11">rtcansend.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga712942ca3d0d621184fb2019a24677c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CAN_RAW_RECV_OWN_MSGS&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN receive own messages. </p>
<p>Not supported by RT-Socket-CAN, but defined for compatibility with Socket-CAN. </p>

</div>
</div>
<a class="anchor" id="gad8af08ea3624e8e9c464ff143fcb66c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTCAN_RTIOC_RCV_TIMEOUT&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x0A, nanosecs_rel_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a reception timeout for a socket. </p>
<p>Defines a timeout for all receive operations via a socket which will take effect when one of the <a class="el" href="group__rtdm__can.html#Recv">receive functions</a> is called without the <code>MSG_DONTWAIT</code> flag set.</p>
<p>The default value for a newly created socket is an infinite timeout.</p>
<dl class="section note"><dt>Note</dt><dd>The setting of the timeout value is not done atomically to avoid locks. Please set the value before receiving messages from the socket.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Pointer to <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> variable. The value is interpreted as relative timeout in nanoseconds in case of a positive value. See <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">Timeouts</a> for special timeouts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanrecv_8c-example.html#a23">rtcanrecv.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad3758528585b2779e8949df671f1cf6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTCAN_RTIOC_SND_TIMEOUT&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x0B, nanosecs_rel_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a transmission timeout for a socket. </p>
<p>Defines a timeout for all send operations via a socket which will take effect when one of the <a class="el" href="group__rtdm__can.html#Send">send functions</a> is called without the <code>MSG_DONTWAIT</code> flag set.</p>
<p>The default value for a newly created socket is an infinite timeout.</p>
<dl class="section note"><dt>Note</dt><dd>The setting of the timeout value is not done atomically to avoid locks. Please set the value before sending messages to the socket.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Pointer to <a class="el" href="group__rtdm.html#gaededf91e760e3268235351dcc9d9dcda">nanosecs_rel_t</a> variable. The value is interpreted as relative timeout in nanoseconds in case of a positive value. See <a class="el" href="group__rtdm.html#RTDM_TIMEOUT_xxx">Timeouts</a> for special timeouts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcansend_8c-example.html#a16">rtcansend.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaedd7bd75a1983735052fed62e101e5ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTCAN_RTIOC_TAKE_TIMESTAMP&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x09, int)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable storing a high precision timestamp upon reception of a CAN frame. </p>
<p>A newly created socket takes no timestamps by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>int variable, see <a class="el" href="group__rtdm__can.html#RTCAN_TIMESTAMPS">Timestamp switches</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Activating taking timestamps only has an effect on newly received CAN messages from the bus. Frames that already are in the socket buffer do not have timestamps if it was deactivated before. See <a class="el" href="group__rtdm__can.html#Recv">Receive</a> for more details. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanrecv_8c-example.html#a24">rtcanrecv.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga9a3032f07b3a6a2f92eb2ba25a4ff8bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCGCANBAUDRATE&#160;&#160;&#160;_IOWR(RTIOC_TYPE_CAN, 0x02, struct can_ifreq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get baud rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arg</td><td>Pointer to interface request structure buffer (<code>struct <a class="el" href="structcan__ifreq.html" title="CAN interface request descriptor. ">can_ifreq</a></code>). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> will be filled with an instance of <a class="el" href="group__rtdm__can.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No baud rate was set yet.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa78d64e69ffd68a20f93a6aa64393d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCGCANCTRLMODE&#160;&#160;&#160;_IOWR(RTIOC_TYPE_CAN, 0x08, struct can_ifreq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get special controller modes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Pointer to interface request structure buffer (<code>struct <a class="el" href="structcan__ifreq.html" title="CAN interface request descriptor. ">can_ifreq</a></code>). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtdm__can.html#gaa1db20ee5ae4803157e38db4b6c6150b">can_ctrlmode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No baud rate was set yet.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab92b51127ca47c491069b9f3e5013a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCGCANCUSTOMBITTIME&#160;&#160;&#160;_IOWR(RTIOC_TYPE_CAN, 0x04, struct can_ifreq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get custom bit-time parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arg</td><td>Pointer to interface request structure buffer (<code>struct <a class="el" href="structcan__ifreq.html" title="CAN interface request descriptor. ">can_ifreq</a></code>). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> will be filled with an instance of struct <a class="el" href="structcan__bittime.html" title="Custom CAN bit-time definition. ">can_bittime</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No baud rate was set yet.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b5f750db08d56f40489679f22236ef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCGCANSTATE&#160;&#160;&#160;_IOWR(RTIOC_TYPE_CAN, 0x06, struct can_ifreq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current state of CAN controller. </p>
<p>States are divided into main states and additional error indicators. A CAN controller is always in exactly one main state. CAN bus errors are registered by the CAN hardware and collected by the driver. There is one error indicator (bit) per error type. If this IOCTL is triggered the error types which occured since the last call of this IOCTL are reported and thereafter the error indicators are cleared. See also <a class="el" href="group__rtdm__can.html#CAN_STATE">CAN controller states</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arg</td><td>Pointer to interface request structure buffer (<code>struct <a class="el" href="structcan__ifreq.html" title="CAN interface request descriptor. ">can_ifreq</a></code>). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> will be filled with an instance of <a class="el" href="group__rtdm__can.html#ga47a129d7188a7cd7b68fbf60ebbfd9e8">can_mode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted, might-switch</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaee74ae50c8ea0a6aee277c6f124a3866"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCGIFINDEX&#160;&#160;&#160;defined_by_kernel_header_file</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get CAN interface index by name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arg</td><td>Pointer to interface request structure buffer (<code>struct <a class="el" href="structcan__ifreq.html" title="CAN interface request descriptor. ">can_ifreq</a></code>). If <code>ifr_name</code> holds a valid CAN interface name <code>ifr_ifindex</code> will be filled with the corresponding interface index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="can-rtt_8c-example.html#a13">can-rtt.c</a>, <a class="el" href="rtcanconfig_8c-example.html#a9">rtcanconfig.c</a>, <a class="el" href="rtcanrecv_8c-example.html#a18">rtcanrecv.c</a>, and <a class="el" href="rtcansend_8c-example.html#a12">rtcansend.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga7c070037c218b40de849ebf4d299f977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCSCANBAUDRATE&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x01, struct can_ifreq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set baud rate. </p>
<p>The baudrate must be specified in bits per second. The driver will try to calculate resonable CAN bit-timing parameters. You can use <a class="el" href="group__rtdm__can.html#ga4e9547dcb608fd0b8d5cf57f926e5176">SIOCSCANCUSTOMBITTIME</a> to set custom bit-timing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Pointer to interface request structure buffer (<code>struct <a class="el" href="structcan__ifreq.html" title="CAN interface request descriptor. ">can_ifreq</a></code>). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtdm__can.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No valid baud rate, see <a class="el" href="group__rtdm__can.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a>.</li>
<li>-EDOM : Baud rate not possible.</li>
<li>-EAGAIN: Request could not be successully fulfilled. Try again.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted, might-switch</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Setting the baud rate is a configuration task. It should be done deliberately or otherwise CAN messages will likely be lost. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanconfig_8c-example.html#a10">rtcanconfig.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga26fa69d2cded6e172b96b4a6dc3798df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCSCANCTRLMODE&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x07, struct can_ifreq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set special controller modes. </p>
<p>Various special controller modes could be or'ed together (see <a class="el" href="group__rtdm__can.html#CAN_CTRLMODE">CAN_CTRLMODE</a> for further information).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Pointer to interface request structure buffer (<code>struct <a class="el" href="structcan__ifreq.html" title="CAN interface request descriptor. ">can_ifreq</a></code>). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtdm__can.html#gaa1db20ee5ae4803157e38db4b6c6150b">can_ctrlmode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No valid baud rate, see <a class="el" href="group__rtdm__can.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a>.</li>
<li>-EAGAIN: Request could not be successully fulfilled. Try again.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted, might-switch</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Setting special controller modes is a configuration task. It should be done deliberately or otherwise CAN messages will likely be lost. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanconfig_8c-example.html#a25">rtcanconfig.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga4e9547dcb608fd0b8d5cf57f926e5176"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCSCANCUSTOMBITTIME&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x03, struct can_ifreq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set custom bit time parameter. </p>
<p>Custem-bit time could be defined in various formats (see struct <a class="el" href="structcan__bittime.html" title="Custom CAN bit-time definition. ">can_bittime</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Pointer to interface request structure buffer (<code>struct <a class="el" href="structcan__ifreq.html" title="CAN interface request descriptor. ">can_ifreq</a></code>). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of struct <a class="el" href="structcan__bittime.html" title="Custom CAN bit-time definition. ">can_bittime</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EINVAL: No valid baud rate, see <a class="el" href="group__rtdm__can.html#ga1c314e1f81a7211a9778da835202a741">can_baudrate_t</a>.</li>
<li>-EAGAIN: Request could not be successully fulfilled. Try again.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted, might-switch</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Setting the bit-time is a configuration task. It should be done deliberately or otherwise CAN messages will likely be lost. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanconfig_8c-example.html#a24">rtcanconfig.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga72b56a34fe466bca858b1f5f401e1076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SIOCSCANMODE&#160;&#160;&#160;_IOW(RTIOC_TYPE_CAN, 0x05, struct can_ifreq)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set operation mode of CAN controller. </p>
<p>See <a class="el" href="group__rtdm__can.html#CAN_MODE">CAN controller modes</a> for available modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Pointer to interface request structure buffer (<code>struct <a class="el" href="structcan__ifreq.html" title="CAN interface request descriptor. ">can_ifreq</a></code>). <code>ifr_name</code> must hold a valid CAN interface name, <code>ifr_ifru</code> must be filled with an instance of <a class="el" href="group__rtdm__can.html#ga47a129d7188a7cd7b68fbf60ebbfd9e8">can_mode_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, otherwise:<ul>
<li>-EFAULT: It was not possible to access user space memory area at the specified address.</li>
<li>-ENODEV: No device with specified name exists.</li>
<li>-EAGAIN: (<a class="el" href="group__rtdm__can.html#ggac0d6cdda2cf4abb51116b86bc99acf99af9c617b6b198770017f6e7198bfb50b6">CAN_MODE_START</a>, <a class="el" href="group__rtdm__can.html#ggac0d6cdda2cf4abb51116b86bc99acf99a04f549e87bf7ddf764c563062dd76790">CAN_MODE_STOP</a>) Could not successfully set mode, hardware is busy. Try again.</li>
<li>-EINVAL: (<a class="el" href="group__rtdm__can.html#ggac0d6cdda2cf4abb51116b86bc99acf99af9c617b6b198770017f6e7198bfb50b6">CAN_MODE_START</a>) Cannot start controller, set baud rate first.</li>
<li>-ENETDOWN: (<a class="el" href="group__rtdm__can.html#ggac0d6cdda2cf4abb51116b86bc99acf99a57866c198e12c54747aca0786dc33e3e">CAN_MODE_SLEEP</a>) Cannot go into sleep mode because controller is stopped or bus off.</li>
<li>-EOPNOTSUPP: unknown mode</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted, might-switch</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Setting a CAN controller into normal operation after a bus-off can take some time (128 occurrences of 11 consecutive recessive bits). In such a case, although this IOCTL will return immediately with success and <a class="el" href="group__rtdm__can.html#ga5b5f750db08d56f40489679f22236ef4">SIOCGCANSTATE</a> will report <a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226ba7db2add3bd2ed5a01893a3d2a012ac67">CAN_STATE_ACTIVE</a>, bus-off recovery may still be in progress. <br />
If a controller is bus-off, setting it into stop mode will return no error but the controller remains bus-off. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanconfig_8c-example.html#a26">rtcanconfig.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad981aa82a29d828882a2fb4c35c1cdd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOL_CAN_RAW&#160;&#160;&#160;103</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN socket levels. </p>
<p>Used for <a class="el" href="group__rtdm__can.html#Sockopts">Sockopts</a> for the particular protocols. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="can-rtt_8c-example.html#a14">can-rtt.c</a>, <a class="el" href="rtcanrecv_8c-example.html#a19">rtcanrecv.c</a>, and <a class="el" href="rtcansend_8c-example.html#a10">rtcansend.c</a>.</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga95d9c00c42529e030dcc8d43a98127a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcan__filter.html">can_filter</a>  <a class="el" href="group__rtdm__can.html#ga95d9c00c42529e030dcc8d43a98127a2">can_filter_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter for reception of CAN messages. </p>
<p>This filter works as follows: A received CAN ID is AND'ed bitwise with <code>can_mask</code> and then compared to <code>can_id</code>. This also includes the <a class="el" href="group__rtdm__can.html#ga5ae55ab3741140024858bd7b8762ea42">CAN_EFF_FLAG</a> and <a class="el" href="group__rtdm__can.html#gaf324d65226057755175038a15d9bbd75">CAN_RTR_FLAG</a> of <a class="el" href="group__rtdm__can.html#CAN_xxx_FLAG">CAN_xxx_FLAG</a>. If this comparison is true, the message will be received by the socket. The logic can be inverted with the <code>can_id</code> flag <a class="el" href="group__rtdm__can.html#ga5cb484fa2d90489f6b4e7a77c254c59f">CAN_INV_FILTER</a> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if (can_id &amp; CAN_INV_FILTER) {</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;   if ((received_can_id &amp; can_mask) != (can_id &amp; ~CAN_INV_FILTER))</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;      accept-message;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;} else {</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;   if ((received_can_id &amp; can_mask) == can_id)</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;      accept-message;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
</div><!-- fragment --><p>Multiple filters can be arranged in a filter list and set with <a class="el" href="group__rtdm__can.html#Sockopts">Sockopts</a>. If one of these filters matches a CAN ID upon reception of a CAN frame, this frame is accepted. </p>

</div>
</div>
<a class="anchor" id="gace340cdd98cbfd2525c9d6b23cdd2188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcan__frame.html">can_frame</a>  <a class="el" href="group__rtdm__can.html#gace340cdd98cbfd2525c9d6b23cdd2188">can_frame_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raw CAN frame. </p>
<p>Central structure for receiving and sending CAN frames. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanrecv_8c-example.html#a5">rtcanrecv.c</a>.</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga42c4f551b57f47d4e004c02505a01f71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__rtdm__can.html#ga42c4f551b57f47d4e004c02505a01f71">CAN_BITTIME_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported CAN bit-time types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga42c4f551b57f47d4e004c02505a01f71a160d7c514df2477f8016ed1bf5a6709f"></a>CAN_BITTIME_STD&#160;</td><td class="fielddoc">
<p>Standard bit-time definition according to Bosch. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga42c4f551b57f47d4e004c02505a01f71ae164a942c698440f2548bd82fea33e55"></a>CAN_BITTIME_BTR&#160;</td><td class="fielddoc">
<p>Hardware-specific BTR bit-time definition. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gac0d6cdda2cf4abb51116b86bc99acf99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__rtdm__can.html#gac0d6cdda2cf4abb51116b86bc99acf99">CAN_MODE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggac0d6cdda2cf4abb51116b86bc99acf99a04f549e87bf7ddf764c563062dd76790"></a>CAN_MODE_STOP&#160;</td><td class="fielddoc">
<p>Set controller in Stop mode (no reception / transmission possible) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac0d6cdda2cf4abb51116b86bc99acf99af9c617b6b198770017f6e7198bfb50b6"></a>CAN_MODE_START&#160;</td><td class="fielddoc">
<p>Set controller into normal operation. <br />
 Coming from stopped mode or bus off, the controller begins with no errors in <a class="el" href="group__rtdm__can.html#gga8680f5710e1a13d553067cc32c86226ba7db2add3bd2ed5a01893a3d2a012ac67">CAN_STATE_ACTIVE</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac0d6cdda2cf4abb51116b86bc99acf99a57866c198e12c54747aca0786dc33e3e"></a>CAN_MODE_SLEEP&#160;</td><td class="fielddoc">
<p>Set controller into Sleep mode. <br />
 This is only possible if the controller is not stopped or bus-off. <br />
 Notice that sleep mode will only be entered when there is no bus activity. If the controller detects bus activity while "sleeping" it will go into operating mode again. <br />
 To actively leave sleep mode again trigger <code>CAN_MODE_START</code>. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga8680f5710e1a13d553067cc32c86226b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__rtdm__can.html#ga8680f5710e1a13d553067cc32c86226b">CAN_STATE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba026154ef3a7f9cb633e43ab7e63d769c"></a>CAN_STATE_ERROR_ACTIVE&#160;</td><td class="fielddoc">
<p>CAN controller is error active. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba7db2add3bd2ed5a01893a3d2a012ac67"></a>CAN_STATE_ACTIVE&#160;</td><td class="fielddoc">
<p>CAN controller is active. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba15263a89961afbc4e813c7ccfc59e5ff"></a>CAN_STATE_ERROR_WARNING&#160;</td><td class="fielddoc">
<p>CAN controller is error active, warning level is reached. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba8e8ffc38c3886c8ab4b7a6ebd24db2e1"></a>CAN_STATE_BUS_WARNING&#160;</td><td class="fielddoc">
<p>CAN controller is error active, warning level is reached. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226bac2cd08cde738273c5e5df8306c48d8ae"></a>CAN_STATE_ERROR_PASSIVE&#160;</td><td class="fielddoc">
<p>CAN controller is error passive. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba16806979589ee8f20ee84c767903b667"></a>CAN_STATE_BUS_PASSIVE&#160;</td><td class="fielddoc">
<p>CAN controller is error passive. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba679935a8710667fcb99423d217cd9959"></a>CAN_STATE_BUS_OFF&#160;</td><td class="fielddoc">
<p>CAN controller went into Bus Off. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226bacc4b4039f38316b01662d775eeb981ff"></a>CAN_STATE_SCANNING_BAUDRATE&#160;</td><td class="fielddoc">
<p>CAN controller is scanning to get the baudrate. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba644e7a441f2e607b93528d3128508cc8"></a>CAN_STATE_STOPPED&#160;</td><td class="fielddoc">
<p>CAN controller is in stopped mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8680f5710e1a13d553067cc32c86226ba2bb74d448dac491e9cfcc7f7bcc14857"></a>CAN_STATE_SLEEPING&#160;</td><td class="fielddoc">
<p>CAN controller is in Sleep mode. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
