<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Message queue services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__alchemy__queue.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Message queue services<div class="ingroups"><a class="el" href="group__alchemy.html">Alchemy API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>real-time IPC mechanism for sending messages of arbitrary size  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Message queue services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__alchemy__queue.png" border="0" alt="" usemap="#group____alchemy____queue"/>
<map name="group____alchemy____queue" id="group____alchemy____queue">
<area shape="rect" id="node2" href="group__alchemy.html" title="A programming interface reminiscent from traditional RTOS APIs. " alt="" coords="5,5,104,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRT__QUEUE__INFO.html">RT_QUEUE_INFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue status descriptor.  <a href="structRT__QUEUE__INFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6184fd1b608179ebfe57a86d45555846"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga6184fd1b608179ebfe57a86d45555846">Q_PRIO</a>&#160;&#160;&#160;0x1	/* Pend by task priority order. */</td></tr>
<tr class="memdesc:ga6184fd1b608179ebfe57a86d45555846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation flags.  <a href="#ga6184fd1b608179ebfe57a86d45555846">More...</a><br /></td></tr>
<tr class="separator:ga6184fd1b608179ebfe57a86d45555846"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafcca092449615e243e02050d9fe9cedb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#gafcca092449615e243e02050d9fe9cedb">rt_queue_create</a> (RT_QUEUE *queue, const char *name, size_t poolsize, size_t qlimit, int mode)</td></tr>
<tr class="memdesc:gafcca092449615e243e02050d9fe9cedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a message queue.  <a href="#gafcca092449615e243e02050d9fe9cedb">More...</a><br /></td></tr>
<tr class="separator:gafcca092449615e243e02050d9fe9cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78663d153bbaa62a19d23b7916b3c0d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga78663d153bbaa62a19d23b7916b3c0d9">rt_queue_delete</a> (RT_QUEUE *queue)</td></tr>
<tr class="memdesc:ga78663d153bbaa62a19d23b7916b3c0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a message queue.  <a href="#ga78663d153bbaa62a19d23b7916b3c0d9">More...</a><br /></td></tr>
<tr class="separator:ga78663d153bbaa62a19d23b7916b3c0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2d9dd0be6cb739ebfe97a7ce158302"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga1f2d9dd0be6cb739ebfe97a7ce158302">rt_queue_alloc</a> (RT_QUEUE *queue, size_t size)</td></tr>
<tr class="memdesc:ga1f2d9dd0be6cb739ebfe97a7ce158302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a message buffer.  <a href="#ga1f2d9dd0be6cb739ebfe97a7ce158302">More...</a><br /></td></tr>
<tr class="separator:ga1f2d9dd0be6cb739ebfe97a7ce158302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dde50ae5c62445b781bd6087f5b58c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga7dde50ae5c62445b781bd6087f5b58c0">rt_queue_free</a> (RT_QUEUE *queue, void *buf)</td></tr>
<tr class="memdesc:ga7dde50ae5c62445b781bd6087f5b58c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a message buffer.  <a href="#ga7dde50ae5c62445b781bd6087f5b58c0">More...</a><br /></td></tr>
<tr class="separator:ga7dde50ae5c62445b781bd6087f5b58c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f667487f19b7611a999481a9eb56757"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga1f667487f19b7611a999481a9eb56757">rt_queue_send</a> (RT_QUEUE *queue, const void *buf, size_t size, int mode)</td></tr>
<tr class="memdesc:ga1f667487f19b7611a999481a9eb56757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to a queue.  <a href="#ga1f667487f19b7611a999481a9eb56757">More...</a><br /></td></tr>
<tr class="separator:ga1f667487f19b7611a999481a9eb56757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23257e3a6ad962b5e02a54b2e252bbca"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga23257e3a6ad962b5e02a54b2e252bbca">rt_queue_receive_timed</a> (RT_QUEUE *queue, void **bufp, const struct timespec *abs_timeout)</td></tr>
<tr class="memdesc:ga23257e3a6ad962b5e02a54b2e252bbca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message from a queue (with absolute timeout date).  <a href="#ga23257e3a6ad962b5e02a54b2e252bbca">More...</a><br /></td></tr>
<tr class="separator:ga23257e3a6ad962b5e02a54b2e252bbca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6bc941d00c44d2ed4302aec747f9e09"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#gaf6bc941d00c44d2ed4302aec747f9e09">rt_queue_receive_until</a> (RT_QUEUE *queue, void **bufp, RTIME timeout)</td></tr>
<tr class="memdesc:gaf6bc941d00c44d2ed4302aec747f9e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive from a queue (with absolute scalar timeout).  <a href="#gaf6bc941d00c44d2ed4302aec747f9e09">More...</a><br /></td></tr>
<tr class="separator:gaf6bc941d00c44d2ed4302aec747f9e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f06e6c79aad6996e3c98103e06e464"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga53f06e6c79aad6996e3c98103e06e464">rt_queue_receive</a> (RT_QUEUE *queue, void **bufp, RTIME timeout)</td></tr>
<tr class="memdesc:ga53f06e6c79aad6996e3c98103e06e464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive from a queue (with relative scalar timeout).  <a href="#ga53f06e6c79aad6996e3c98103e06e464">More...</a><br /></td></tr>
<tr class="separator:ga53f06e6c79aad6996e3c98103e06e464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa804ad003381fa7d6c67ca3fcc5851a3"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#gaa804ad003381fa7d6c67ca3fcc5851a3">rt_queue_read_timed</a> (RT_QUEUE *queue, void *buf, size_t size, const struct timespec *abs_timeout)</td></tr>
<tr class="memdesc:gaa804ad003381fa7d6c67ca3fcc5851a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a queue.  <a href="#gaa804ad003381fa7d6c67ca3fcc5851a3">More...</a><br /></td></tr>
<tr class="separator:gaa804ad003381fa7d6c67ca3fcc5851a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d29fcc0592c5da196df9f6cb6fd84d3"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga0d29fcc0592c5da196df9f6cb6fd84d3">rt_queue_read_until</a> (RT_QUEUE *queue, void *buf, size_t size, RTIME timeout)</td></tr>
<tr class="memdesc:ga0d29fcc0592c5da196df9f6cb6fd84d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a queue (with absolute scalar timeout).  <a href="#ga0d29fcc0592c5da196df9f6cb6fd84d3">More...</a><br /></td></tr>
<tr class="separator:ga0d29fcc0592c5da196df9f6cb6fd84d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7baca65c1d6abfc51f170f7f9b5e6d31"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga7baca65c1d6abfc51f170f7f9b5e6d31">rt_queue_read</a> (RT_QUEUE *queue, void *buf, size_t size, RTIME timeout)</td></tr>
<tr class="memdesc:ga7baca65c1d6abfc51f170f7f9b5e6d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a queue (with relative scalar timeout).  <a href="#ga7baca65c1d6abfc51f170f7f9b5e6d31">More...</a><br /></td></tr>
<tr class="separator:ga7baca65c1d6abfc51f170f7f9b5e6d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a8f862917b9092ec5f7ebbfc435a6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga80a8f862917b9092ec5f7ebbfc435a6a">rt_queue_flush</a> (RT_QUEUE *queue)</td></tr>
<tr class="memdesc:ga80a8f862917b9092ec5f7ebbfc435a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush pending messages from a queue.  <a href="#ga80a8f862917b9092ec5f7ebbfc435a6a">More...</a><br /></td></tr>
<tr class="separator:ga80a8f862917b9092ec5f7ebbfc435a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga210650dcda8e22635fa8d1f167d84afb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga210650dcda8e22635fa8d1f167d84afb">rt_queue_inquire</a> (RT_QUEUE *queue, <a class="el" href="structRT__QUEUE__INFO.html">RT_QUEUE_INFO</a> *info)</td></tr>
<tr class="memdesc:ga210650dcda8e22635fa8d1f167d84afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query queue status.  <a href="#ga210650dcda8e22635fa8d1f167d84afb">More...</a><br /></td></tr>
<tr class="separator:ga210650dcda8e22635fa8d1f167d84afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb4a6f6f3e87f730450b1b1c1bfa4bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga0cb4a6f6f3e87f730450b1b1c1bfa4bb">rt_queue_bind</a> (RT_QUEUE *queue, const char *name, RTIME timeout)</td></tr>
<tr class="memdesc:ga0cb4a6f6f3e87f730450b1b1c1bfa4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to a message queue.  <a href="#ga0cb4a6f6f3e87f730450b1b1c1bfa4bb">More...</a><br /></td></tr>
<tr class="separator:ga0cb4a6f6f3e87f730450b1b1c1bfa4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d038345e1eb8d0633e6108af68387d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__queue.html#ga0d038345e1eb8d0633e6108af68387d3">rt_queue_unbind</a> (RT_QUEUE *queue)</td></tr>
<tr class="memdesc:ga0d038345e1eb8d0633e6108af68387d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind from a message queue.  <a href="#ga0d038345e1eb8d0633e6108af68387d3">More...</a><br /></td></tr>
<tr class="separator:ga0d038345e1eb8d0633e6108af68387d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>real-time IPC mechanism for sending messages of arbitrary size </p>
<p>Message queueing is a method by which real-time tasks can exchange or pass data through a Xenomai-managed queue of messages. Messages can vary in length and be assigned different types or usages. A message queue can be created by one task and used by multiple tasks that send and/or receive messages to the queue. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga6184fd1b608179ebfe57a86d45555846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Q_PRIO&#160;&#160;&#160;0x1	/* Pend by task priority order. */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation flags. </p>

<p>Referenced by <a class="el" href="group__alchemy__queue.html#gafcca092449615e243e02050d9fe9cedb">rt_queue_create()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1f2d9dd0be6cb739ebfe97a7ce158302"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rt_queue_alloc </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a message buffer. </p>
<p>This service allocates a message buffer from the queue's internal pool. This buffer can be filled in with payload information, prior enqueuing it by a call to <a class="el" href="group__alchemy__queue.html#ga1f667487f19b7611a999481a9eb56757" title="Send a message to a queue. ">rt_queue_send()</a>. When used in pair, these services provide a zero-copy interface for sending messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
    <tr><td class="paramname">size</td><td>The requested size in bytes of the buffer. Zero is an acceptable value, which means that the message conveys no payload; in this case, the receiver will get a zero-sized message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the allocated buffer upon success, or NULL if the call fails.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted, switch-primary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0cb4a6f6f3e87f730450b1b1c1bfa4bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_bind </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind to a message queue. </p>
<p>This routine creates a new descriptor to refer to an existing message queue identified by its symbolic name. If the object does not exist on entry, the caller may block until a queue of the given name is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The address of a queue descriptor filled in by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td class="paramname">name</td><td>A valid NULL-terminated name which identifies the queue to bind to. This string should match the object name argument passed to <a class="el" href="group__alchemy__queue.html#gafcca092449615e243e02050d9fe9cedb" title="Create a message queue. ">rt_queue_create()</a>.</td></tr>
    <tr><td class="paramname">timeout</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before the retrieval has completed.</li>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

</div>
</div>
<a class="anchor" id="gafcca092449615e243e02050d9fe9cedb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_create </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>poolsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>qlimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a message queue. </p>
<p>Create a message queue object which allows multiple tasks to exchange data through the use of variable-sized messages. A message queue is created empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The address of a queue descriptor which can be later used to identify uniquely the created object, upon success of this call.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the queue. When non-NULL and non-empty, a copy of this string is used for indexing the created queue into the object registry.</td></tr>
    <tr><td class="paramname">poolsize</td><td>The size (in bytes) of the message buffer pool to be pre-allocated for holding messages. Message buffers will be claimed and released to this pool. The buffer pool memory cannot be extended. See note.</td></tr>
    <tr><td class="paramname">qlimit</td><td>This parameter allows to limit the maximum number of messages which can be queued at any point in time, sending to a full queue begets an error. The special value Q_UNLIMITED can be passed to disable the limit check.</td></tr>
    <tr><td class="paramname">mode</td><td>The queue creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new queue:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Q_FIFO makes tasks pend in FIFO order on the queue for consuming messages.</li>
<li>Q_PRIO makes tasks pend in priority order on the queue.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mode</em> is invalid or <em>poolsize</em> is zero.</li>
<li>-ENOMEM is returned if the system fails to get memory from the main heap in order to create the queue.</li>
<li>-EEXIST is returned if the <em>name</em> is conflicting with an already registered queue.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Queues can be shared by multiple processes which belong to the same Xenomai session.</dd>
<dd>
Each message pending into the queue consumes four long words plus the actual payload size, aligned to the next long word boundary. e.g. a 6 byte message on a 32 bit platform would require 24 bytes of storage into the pool.</dd></dl>
<p>When <em>qlimit</em> is given (i.e. different from Q_UNLIMITED), this overhead is accounted for automatically, so that <em>qlimit</em> messages of <em>poolsize</em> / <em>qlimit</em> bytes can be stored into the pool concurrently. Otherwise, <em>poolsize</em> is increased by 5% internally to cope with such overhead. </p>

<p>References <a class="el" href="group__alchemy__queue.html#ga6184fd1b608179ebfe57a86d45555846">Q_PRIO</a>.</p>

</div>
</div>
<a class="anchor" id="ga78663d153bbaa62a19d23b7916b3c0d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_delete </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a message queue. </p>
<p>This routine deletes a queue object previously created by a call to <a class="el" href="group__alchemy__queue.html#gafcca092449615e243e02050d9fe9cedb" title="Create a message queue. ">rt_queue_create()</a>. All resources attached to that queue are automatically released, including all pending messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>q</em> is not a valid queue descriptor.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga80a8f862917b9092ec5f7ebbfc435a6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_flush </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush pending messages from a queue. </p>
<p>This routine flushes all messages currently pending in a queue, releasing all message buffers appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>q</em> is not a valid queue descriptor.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted, switch-primary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7dde50ae5c62445b781bd6087f5b58c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_free </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a message buffer. </p>
<p>This service releases a message buffer to the queue's internal pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
    <tr><td class="paramname">buf</td><td>The address of the message buffer to free. Even zero-sized messages carrying no payload data must be freed, since they are assigned a valid memory space to store internal information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success, or -EINVAL if <em>buf</em> is not a valid message buffer previously allocated by the <a class="el" href="group__alchemy__queue.html#ga1f2d9dd0be6cb739ebfe97a7ce158302" title="Allocate a message buffer. ">rt_queue_alloc()</a> service, or the caller did not get ownership of the message through a successful return from <a class="el" href="group__alchemy__queue.html#ga53f06e6c79aad6996e3c98103e06e464" title="Receive from a queue (with relative scalar timeout). ">rt_queue_receive()</a>.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted, switch-primary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga210650dcda8e22635fa8d1f167d84afb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_inquire </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRT__QUEUE__INFO.html">RT_QUEUE_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query queue status. </p>
<p>This routine returns the status information about the specified queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
    <tr><td class="paramname">info</td><td>A pointer to the <a class="el" href="structRT__QUEUE__INFO.html#RT_QUEUE_INFO">return</a>buffer" to copy the information to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>q</em> is not a valid queue descriptor.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted, switch-primary</a> </dd></dl>

<p>References <a class="el" href="structRT__QUEUE__INFO.html#a81c53102b3b42deb57e1a6ccffdba5b9">RT_QUEUE_INFO::mode</a>, <a class="el" href="structRT__QUEUE__INFO.html#afd5e97a2c5e83451dab949b6f43b9f1b">RT_QUEUE_INFO::name</a>, <a class="el" href="structRT__QUEUE__INFO.html#a280258c4d2ad599d6e38c84c1d295bd2">RT_QUEUE_INFO::nmessages</a>, <a class="el" href="structRT__QUEUE__INFO.html#aec41dd74c0002db14f8da88b4df73d52">RT_QUEUE_INFO::nwaiters</a>, <a class="el" href="structRT__QUEUE__INFO.html#a5a91d7436be72dc6ac4900e759709a35">RT_QUEUE_INFO::poolsize</a>, <a class="el" href="structRT__QUEUE__INFO.html#a3f82152fe946a24ff4feae8b14fc45ac">RT_QUEUE_INFO::qlimit</a>, and <a class="el" href="structRT__QUEUE__INFO.html#acf2095e8a9c0e1f7da197123bb324a21">RT_QUEUE_INFO::usedmem</a>.</p>

</div>
</div>
<a class="anchor" id="ga7baca65c1d6abfc51f170f7f9b5e6d31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_queue_read </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from a queue (with relative scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__queue.html#gaa804ad003381fa7d6c67ca3fcc5851a3" title="Read from a queue. ">rt_queue_read_timed()</a> accepting a relative timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
    <tr><td class="paramname">buf</td><td>A pointer to a memory area which will be written upon success with the received message payload.</td></tr>
    <tr><td class="paramname">size</td><td>The length in bytes of the memory area pointed to by <em>buf</em>.</td></tr>
    <tr><td class="paramname">timeout</td><td>A delay expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__queue.html#gaa804ad003381fa7d6c67ca3fcc5851a3">rt_queue_read_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa804ad003381fa7d6c67ca3fcc5851a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_queue_read_timed </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from a queue. </p>
<p>This service reads the next available message from a given queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
    <tr><td class="paramname">buf</td><td>A pointer to a memory area which will be written upon success with the received message payload. The internal message buffer conveying the data is automatically freed by this call. If &ndash;enable-pshared is enabled in the configuration, <em>buf</em> must have been obtained from the Xenomai memory allocator via xnmalloc() or any service based on it, such as <a class="el" href="group__alchemy__heap.html#ga52678149ff2b66e47aa8cdcddab653a4" title="Allocate a block from a heap (with relative scalar timeout). ">rt_heap_alloc()</a>.</td></tr>
    <tr><td class="paramname">size</td><td>The length in bytes of the memory area pointed to by <em>buf</em>. Messages larger than <em>size</em> are truncated appropriately.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks, specifying a time limit to wait for a message to be available from the queue (see note). Passing NULL causes the caller to block indefinitely until a message is available. Passing { .tv_sec = 0, .tv_nsec = 0 } causes the service to return immediately without blocking in case no message is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes copied to <em>buf</em> is returned upon success. Zero is a possible value corresponding to a zero-sized message passed to <a class="el" href="group__alchemy__queue.html#ga1f667487f19b7611a999481a9eb56757" title="Send a message to a queue. ">rt_queue_send()</a> or rt_queue_write(). Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if <em>abs_timeout</em> is reached before a message arrives.</li>
<li>-EWOULDBLOCK is returned if <em>abs_timeout</em> is { .tv_sec = 0, .tv_nsec = 0 } and no message is immediately available on entry to the call.</li>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before a message was available.</li>
<li>-EINVAL is returned if <em>q</em> is not a valid queue descriptor.</li>
<li>-EIDRM is returned if <em>q</em> is deleted while the caller was waiting for a message. In such event, <em>q</em> is no more valid upon return of this service.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>abs_timeout</em> is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

<p>Referenced by <a class="el" href="group__alchemy__queue.html#ga7baca65c1d6abfc51f170f7f9b5e6d31">rt_queue_read()</a>, and <a class="el" href="group__alchemy__queue.html#ga0d29fcc0592c5da196df9f6cb6fd84d3">rt_queue_read_until()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0d29fcc0592c5da196df9f6cb6fd84d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_queue_read_until </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from a queue (with absolute scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__queue.html#gaa804ad003381fa7d6c67ca3fcc5851a3" title="Read from a queue. ">rt_queue_read_timed()</a> accepting an absolute timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
    <tr><td class="paramname">buf</td><td>A pointer to a memory area which will be written upon success with the received message payload.</td></tr>
    <tr><td class="paramname">size</td><td>The length in bytes of the memory area pointed to by <em>buf</em>.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__queue.html#gaa804ad003381fa7d6c67ca3fcc5851a3">rt_queue_read_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga53f06e6c79aad6996e3c98103e06e464"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_queue_receive </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>bufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive from a queue (with relative scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__queue.html#ga23257e3a6ad962b5e02a54b2e252bbca" title="Receive a message from a queue (with absolute timeout date). ">rt_queue_receive_timed()</a> accepting a relative timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
    <tr><td class="paramname">bufp</td><td>A pointer to a memory location which will be written with the address of the received message.</td></tr>
    <tr><td class="paramname">timeout</td><td>A delay expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__queue.html#ga23257e3a6ad962b5e02a54b2e252bbca">rt_queue_receive_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga23257e3a6ad962b5e02a54b2e252bbca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_queue_receive_timed </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>bufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a message from a queue (with absolute timeout date). </p>
<p>This service receives the next available message from a given queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
    <tr><td class="paramname">bufp</td><td>A pointer to a memory location which will be written with the address of the received message, upon success. Once consumed, the message space should be freed using <a class="el" href="group__alchemy__queue.html#ga7dde50ae5c62445b781bd6087f5b58c0" title="Free a message buffer. ">rt_queue_free()</a>.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks, specifying a time limit to wait for a message to be available from the queue (see note). Passing NULL causes the caller to block indefinitely until a message is available. Passing { .tv_sec = 0, .tv_nsec = 0 } causes the service to return immediately without blocking in case no message is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes available from the received message is returned upon success. Zero is a possible value corresponding to a zero-sized message passed to <a class="el" href="group__alchemy__queue.html#ga1f667487f19b7611a999481a9eb56757" title="Send a message to a queue. ">rt_queue_send()</a> or rt_queue_write(). Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if <em>abs_timeout</em> is reached before a message arrives.</li>
<li>-EWOULDBLOCK is returned if <em>abs_timeout</em> is { .tv_sec = 0, .tv_nsec = 0 } and no message is immediately available on entry to the call.</li>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before a message was available.</li>
<li>-EINVAL is returned if <em>q</em> is not a valid queue descriptor.</li>
<li>-EIDRM is returned if <em>q</em> is deleted while the caller was waiting for a message. In such event, <em>q</em> is no more valid upon return of this service.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>abs_timeout</em> is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

<p>Referenced by <a class="el" href="group__alchemy__queue.html#ga53f06e6c79aad6996e3c98103e06e464">rt_queue_receive()</a>, and <a class="el" href="group__alchemy__queue.html#gaf6bc941d00c44d2ed4302aec747f9e09">rt_queue_receive_until()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf6bc941d00c44d2ed4302aec747f9e09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_queue_receive_until </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>bufp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive from a queue (with absolute scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__queue.html#ga23257e3a6ad962b5e02a54b2e252bbca" title="Receive a message from a queue (with absolute timeout date). ">rt_queue_receive_timed()</a> accepting an absolute timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
    <tr><td class="paramname">bufp</td><td>A pointer to a memory location which will be written with the address of the received message.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__queue.html#ga23257e3a6ad962b5e02a54b2e252bbca">rt_queue_receive_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f667487f19b7611a999481a9eb56757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_send </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to a queue. </p>
<p>This service sends a complete message to a given queue. The message must have been allocated by a previous call to <a class="el" href="group__alchemy__queue.html#ga1f2d9dd0be6cb739ebfe97a7ce158302" title="Allocate a message buffer. ">rt_queue_alloc()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
    <tr><td class="paramname">buf</td><td>The address of the message buffer to be sent. The message buffer must have been allocated using the <a class="el" href="group__alchemy__queue.html#ga1f2d9dd0be6cb739ebfe97a7ce158302" title="Allocate a message buffer. ">rt_queue_alloc()</a> service. Once passed to <a class="el" href="group__alchemy__queue.html#ga1f667487f19b7611a999481a9eb56757" title="Send a message to a queue. ">rt_queue_send()</a>, the memory pointed to by <em>buf</em> is no more under the control of the sender and thus should not be referenced by it anymore; deallocation of this memory must be handled on the receiving side.</td></tr>
    <tr><td class="paramname">size</td><td>The actual size in bytes of the message, which may be lower than the allocated size for the buffer obtained from <a class="el" href="group__alchemy__queue.html#ga1f2d9dd0be6cb739ebfe97a7ce158302" title="Allocate a message buffer. ">rt_queue_alloc()</a>. Zero is a valid value, in which case an empty message will be sent.</td></tr>
    <tr><td class="paramname">mode</td><td>A set of flags affecting the operation:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Q_URGENT causes the message to be prepended to the message queue, ensuring a LIFO ordering.</li>
<li>Q_NORMAL causes the message to be appended to the message queue, ensuring a FIFO ordering.</li>
<li>Q_BROADCAST causes the message to be sent to all tasks currently waiting for messages. The message is not copied; a reference count is maintained instead so that the message will remain valid until the last receiver releases its own reference using <a class="el" href="group__alchemy__queue.html#ga7dde50ae5c62445b781bd6087f5b58c0" title="Free a message buffer. ">rt_queue_free()</a>, after which the message space will be returned to the queue's internal pool.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Upon success, this service returns the number of receivers which got awaken as a result of the operation. If zero is returned, no task was waiting on the receiving side of the queue, and the message has been enqueued. Upon error, one of the following error codes is returned:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>q</em> is not a message queue descriptor, <em>mode</em> is invalid, or <em>buf</em> is NULL.</li>
<li>-ENOMEM is returned if queuing the message would exceed the limit defined for the queue at creation.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted, switch-primary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d038345e1eb8d0633e6108af68387d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_queue_unbind </td>
          <td>(</td>
          <td class="paramtype">RT_QUEUE *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind from a message queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases a previous binding to a message queue. After this call has returned, the descriptor is no more valid for referencing this object.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
