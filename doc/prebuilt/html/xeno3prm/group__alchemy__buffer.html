<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Buffer services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__alchemy__buffer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Buffer services<div class="ingroups"><a class="el" href="group__alchemy.html">Alchemy API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Lightweight FIFO IPC mechanism.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Buffer services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__alchemy__buffer.png" border="0" alt="" usemap="#group____alchemy____buffer"/>
<map name="group____alchemy____buffer" id="group____alchemy____buffer">
<area shape="rect" id="node2" href="group__alchemy.html" title="A programming interface reminiscent from traditional RTOS APIs. " alt="" coords="5,5,104,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRT__BUFFER__INFO.html">RT_BUFFER_INFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer status descriptor.  <a href="structRT__BUFFER__INFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9d3f5e94949bfd90355a52406dc7967d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#ga9d3f5e94949bfd90355a52406dc7967d">B_PRIO</a>&#160;&#160;&#160;0x1	/* Pend by task priority order. */</td></tr>
<tr class="memdesc:ga9d3f5e94949bfd90355a52406dc7967d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation flags.  <a href="#ga9d3f5e94949bfd90355a52406dc7967d">More...</a><br /></td></tr>
<tr class="separator:ga9d3f5e94949bfd90355a52406dc7967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7aa6a3b48ba6b6ecdd7f2ad9152d2a61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#ga7aa6a3b48ba6b6ecdd7f2ad9152d2a61">rt_buffer_create</a> (RT_BUFFER *bf, const char *name, size_t bufsz, int mode)</td></tr>
<tr class="memdesc:ga7aa6a3b48ba6b6ecdd7f2ad9152d2a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an IPC buffer.  <a href="#ga7aa6a3b48ba6b6ecdd7f2ad9152d2a61">More...</a><br /></td></tr>
<tr class="separator:ga7aa6a3b48ba6b6ecdd7f2ad9152d2a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd852c3c957d2dd37c15899119a3551e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#gabd852c3c957d2dd37c15899119a3551e">rt_buffer_delete</a> (RT_BUFFER *bf)</td></tr>
<tr class="memdesc:gabd852c3c957d2dd37c15899119a3551e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an IPC buffer.  <a href="#gabd852c3c957d2dd37c15899119a3551e">More...</a><br /></td></tr>
<tr class="separator:gabd852c3c957d2dd37c15899119a3551e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93616331b7f6fda3dc8e01cac7b1c350"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#ga93616331b7f6fda3dc8e01cac7b1c350">rt_buffer_write_timed</a> (RT_BUFFER *bf, const void *ptr, size_t size, const struct timespec *abs_timeout)</td></tr>
<tr class="memdesc:ga93616331b7f6fda3dc8e01cac7b1c350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to an IPC buffer.  <a href="#ga93616331b7f6fda3dc8e01cac7b1c350">More...</a><br /></td></tr>
<tr class="separator:ga93616331b7f6fda3dc8e01cac7b1c350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2ff96871bd86e4d7304b05ea401ed72"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#gab2ff96871bd86e4d7304b05ea401ed72">rt_buffer_write_until</a> (RT_BUFFER *bf, const void *ptr, size_t size, RTIME timeout)</td></tr>
<tr class="memdesc:gab2ff96871bd86e4d7304b05ea401ed72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to an IPC buffer (with absolute scalar timeout).  <a href="#gab2ff96871bd86e4d7304b05ea401ed72">More...</a><br /></td></tr>
<tr class="separator:gab2ff96871bd86e4d7304b05ea401ed72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca66b283211381a978c4e905af05e96"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#ga2ca66b283211381a978c4e905af05e96">rt_buffer_write</a> (RT_BUFFER *bf, const void *ptr, size_t size, RTIME timeout)</td></tr>
<tr class="memdesc:ga2ca66b283211381a978c4e905af05e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to an IPC buffer (with relative scalar timeout).  <a href="#ga2ca66b283211381a978c4e905af05e96">More...</a><br /></td></tr>
<tr class="separator:ga2ca66b283211381a978c4e905af05e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97409b5310b1d6e3fab95d29492a81be"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#ga97409b5310b1d6e3fab95d29492a81be">rt_buffer_read_timed</a> (RT_BUFFER *bf, void *ptr, size_t size, const struct timespec *abs_timeout)</td></tr>
<tr class="memdesc:ga97409b5310b1d6e3fab95d29492a81be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from an IPC buffer.  <a href="#ga97409b5310b1d6e3fab95d29492a81be">More...</a><br /></td></tr>
<tr class="separator:ga97409b5310b1d6e3fab95d29492a81be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f640c6665eec926ff7f55f23bd4211a"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#ga7f640c6665eec926ff7f55f23bd4211a">rt_buffer_read_until</a> (RT_BUFFER *bf, void *ptr, size_t size, RTIME timeout)</td></tr>
<tr class="memdesc:ga7f640c6665eec926ff7f55f23bd4211a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from an IPC buffer (with absolute scalar timeout).  <a href="#ga7f640c6665eec926ff7f55f23bd4211a">More...</a><br /></td></tr>
<tr class="separator:ga7f640c6665eec926ff7f55f23bd4211a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4211643dcc88b52233c815fb9ba921e5"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#ga4211643dcc88b52233c815fb9ba921e5">rt_buffer_read</a> (RT_BUFFER *bf, void *ptr, size_t size, RTIME timeout)</td></tr>
<tr class="memdesc:ga4211643dcc88b52233c815fb9ba921e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from an IPC buffer (with relative scalar timeout).  <a href="#ga4211643dcc88b52233c815fb9ba921e5">More...</a><br /></td></tr>
<tr class="separator:ga4211643dcc88b52233c815fb9ba921e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf78c43664dda8a17c5c63ad4be2da179"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#gaf78c43664dda8a17c5c63ad4be2da179">rt_buffer_clear</a> (RT_BUFFER *bf)</td></tr>
<tr class="memdesc:gaf78c43664dda8a17c5c63ad4be2da179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear an IPC buffer.  <a href="#gaf78c43664dda8a17c5c63ad4be2da179">More...</a><br /></td></tr>
<tr class="separator:gaf78c43664dda8a17c5c63ad4be2da179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98722ca524c008906069607a289fb26a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#ga98722ca524c008906069607a289fb26a">rt_buffer_inquire</a> (RT_BUFFER *bf, <a class="el" href="structRT__BUFFER__INFO.html">RT_BUFFER_INFO</a> *info)</td></tr>
<tr class="memdesc:ga98722ca524c008906069607a289fb26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query buffer status.  <a href="#ga98722ca524c008906069607a289fb26a">More...</a><br /></td></tr>
<tr class="separator:ga98722ca524c008906069607a289fb26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d88ba56f1dc341b1b78c1549678fa4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#ga9d88ba56f1dc341b1b78c1549678fa4e">rt_buffer_bind</a> (RT_BUFFER *bf, const char *name, RTIME timeout)</td></tr>
<tr class="memdesc:ga9d88ba56f1dc341b1b78c1549678fa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to an IPC buffer.  <a href="#ga9d88ba56f1dc341b1b78c1549678fa4e">More...</a><br /></td></tr>
<tr class="separator:ga9d88ba56f1dc341b1b78c1549678fa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85e669d38297fa6dff6e78339bb8329d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__buffer.html#ga85e669d38297fa6dff6e78339bb8329d">rt_buffer_unbind</a> (RT_BUFFER *bf)</td></tr>
<tr class="memdesc:ga85e669d38297fa6dff6e78339bb8329d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind from an IPC buffer.  <a href="#ga85e669d38297fa6dff6e78339bb8329d">More...</a><br /></td></tr>
<tr class="separator:ga85e669d38297fa6dff6e78339bb8329d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Lightweight FIFO IPC mechanism. </p>
<p>A buffer is a lightweight IPC mechanism, implementing a fast, one-way producer-consumer data path. All messages written are buffered in a single memory area in strict FIFO order, until read either in blocking or non-blocking mode.</p>
<p>Message are always atomically handled on the write side (i.e. no interleave, no short writes), whilst only complete messages are normally returned to the read side. However, short reads may happen under a well-defined situation (see note in <a class="el" href="group__alchemy__buffer.html#ga4211643dcc88b52233c815fb9ba921e5" title="Read from an IPC buffer (with relative scalar timeout). ">rt_buffer_read()</a>), albeit they can be fully avoided by proper use of the buffer. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga9d3f5e94949bfd90355a52406dc7967d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define B_PRIO&#160;&#160;&#160;0x1	/* Pend by task priority order. */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation flags. </p>

<p>Referenced by <a class="el" href="group__alchemy__buffer.html#ga7aa6a3b48ba6b6ecdd7f2ad9152d2a61">rt_buffer_create()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9d88ba56f1dc341b1b78c1549678fa4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_bind </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind to an IPC buffer. </p>
<p>This routine creates a new descriptor to refer to an existing IPC buffer identified by its symbolic name. If the object does not exist on entry, the caller may block until a buffer of the given name is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The address of a buffer descriptor filled in by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td class="paramname">name</td><td>A valid NULL-terminated name which identifies the buffer to bind to. This string should match the object name argument passed to <a class="el" href="group__alchemy__buffer.html#ga7aa6a3b48ba6b6ecdd7f2ad9152d2a61" title="Create an IPC buffer. ">rt_buffer_create()</a>.</td></tr>
    <tr><td class="paramname">timeout</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before the retrieval has completed.</li>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

</div>
</div>
<a class="anchor" id="gaf78c43664dda8a17c5c63ad4be2da179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_clear </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear an IPC buffer. </p>
<p>This routine empties a buffer from any data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The buffer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>bf</em> is not a valid buffer descriptor.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted, switch-primary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7aa6a3b48ba6b6ecdd7f2ad9152d2a61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_create </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an IPC buffer. </p>
<p>This routine creates an IPC object that allows tasks to send and receive data asynchronously via a memory buffer. Data may be of an arbitrary length, albeit this IPC is best suited for small to medium-sized messages, since data always have to be copied to the buffer during transit. Large messages may be more efficiently handled by message queues (RT_QUEUE).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The address of a buffer descriptor which can be later used to identify uniquely the created object, upon success of this call.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the buffer. When non-NULL and non-empty, a copy of this string is used for indexing the created buffer into the object registry.</td></tr>
    <tr><td class="paramname">bufsz</td><td>The size of the buffer space available to hold data. The required memory is obtained from the main heap.</td></tr>
    <tr><td class="paramname">mode</td><td>The buffer creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new buffer:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>B_FIFO makes tasks pend in FIFO order for reading data from the buffer.</li>
<li>B_PRIO makes tasks pend in priority order for reading data from the buffer.</li>
</ul>
<p>This parameter also applies to tasks blocked on the buffer's write side (see <a class="el" href="group__alchemy__buffer.html#ga2ca66b283211381a978c4e905af05e96" title="Write to an IPC buffer (with relative scalar timeout). ">rt_buffer_write()</a>).</p>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mode</em> is invalid or <em>bufsz</em> is zero.</li>
<li>-ENOMEM is returned if the system fails to get memory from the main heap in order to create the buffer.</li>
<li>-EEXIST is returned if the <em>name</em> is conflicting with an already registered buffer.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Buffers can be shared by multiple processes which belong to the same Xenomai session. </dd></dl>

<p>References <a class="el" href="group__alchemy__buffer.html#ga9d3f5e94949bfd90355a52406dc7967d">B_PRIO</a>.</p>

</div>
</div>
<a class="anchor" id="gabd852c3c957d2dd37c15899119a3551e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_delete </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete an IPC buffer. </p>
<p>This routine deletes a buffer object previously created by a call to <a class="el" href="group__alchemy__buffer.html#ga7aa6a3b48ba6b6ecdd7f2ad9152d2a61" title="Create an IPC buffer. ">rt_buffer_create()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The buffer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>bf</em> is not a valid buffer descriptor.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga98722ca524c008906069607a289fb26a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_inquire </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRT__BUFFER__INFO.html">RT_BUFFER_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query buffer status. </p>
<p>This routine returns the status information about the specified buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The buffer descriptor.</td></tr>
    <tr><td class="paramname">info</td><td>A pointer to the <a class="el" href="structRT__BUFFER__INFO.html#RT_BUFFER_INFO">return</a>buffer" to copy the information to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>bf</em> is not a valid buffer descriptor.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted, switch-primary</a> </dd></dl>

<p>References <a class="el" href="structRT__BUFFER__INFO.html#a9a53f67717bc506a09fc3e6ea3059e66">RT_BUFFER_INFO::availmem</a>, <a class="el" href="structRT__BUFFER__INFO.html#a68910bb1f35118aa27f3b8e2bf63a687">RT_BUFFER_INFO::iwaiters</a>, <a class="el" href="structRT__BUFFER__INFO.html#aa2f3800a47dde889649c68f172514561">RT_BUFFER_INFO::name</a>, <a class="el" href="structRT__BUFFER__INFO.html#a580872155787341161835de44f66e65e">RT_BUFFER_INFO::owaiters</a>, and <a class="el" href="structRT__BUFFER__INFO.html#a807e474d38f82566811ad5f13476c87f">RT_BUFFER_INFO::totalmem</a>.</p>

</div>
</div>
<a class="anchor" id="ga4211643dcc88b52233c815fb9ba921e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_buffer_read </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from an IPC buffer (with relative scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__buffer.html#ga97409b5310b1d6e3fab95d29492a81be" title="Read from an IPC buffer. ">rt_buffer_read_timed()</a> accepting a relative timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The buffer descriptor.</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a memory area which will be written upon success with the received data.</td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of the memory area pointed to by <em>ptr</em>.</td></tr>
    <tr><td class="paramname">timeout</td><td>A delay expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__buffer.html#ga97409b5310b1d6e3fab95d29492a81be">rt_buffer_read_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga97409b5310b1d6e3fab95d29492a81be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_buffer_read_timed </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from an IPC buffer. </p>
<p>This routine reads the next message from the specified buffer. If no message is available on entry, the caller is allowed to block until enough data is written to the buffer, or a timeout elapses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The buffer descriptor.</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a memory area which will be written upon success with the received data.</td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of the memory area pointed to by <em>ptr</em>. Under normal circumstances, <a class="el" href="group__alchemy__buffer.html#ga97409b5310b1d6e3fab95d29492a81be" title="Read from an IPC buffer. ">rt_buffer_read_timed()</a> only returns entire messages as specified by the <em>len</em> argument, or an error value. However, short reads are allowed when a potential deadlock situation is detected (see note below).</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks, specifying a time limit to wait for a message to be available from the buffer (see note). Passing NULL causes the caller to block indefinitely until enough data is available. Passing { .tv_sec = 0, .tv_nsec = 0 } causes the service to return immediately without blocking in case not enough data is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read from the buffer is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if <em>abs_timeout</em> is reached before a complete message arrives.</li>
<li>-EWOULDBLOCK is returned if <em>abs_timeout</em> is { .tv_sec = 0, .tv_nsec = 0 } and not enough data is immediately available on entry to form a complete message.</li>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before enough data became available to form a complete message.</li>
<li>-EINVAL is returned if <em>bf</em> is not a valid buffer descriptor, or <em>len</em> is greater than the actual buffer length.</li>
<li>-EIDRM is returned if <em>bf</em> is deleted while the caller was waiting for data. In such event, <em>bf</em> is no more valid upon return of this service.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>A short read (i.e. fewer bytes returned than requested by <em>len</em>) may happen whenever a pathological use of the buffer is encountered. This condition only arises when the system detects that one or more writers are waiting for sending data, while a reader would have to wait for receiving a complete message at the same time. For instance, consider the following sequence, involving a 1024-byte buffer (bf) and two threads:</dd></dl>
<p>writer thread &gt; rt_write_buffer(&amp;bf, ptr, 1, TM_INFINITE); (one byte to read, 1023 bytes available for sending) writer thread &gt; rt_write_buffer(&amp;bf, ptr, 1024, TM_INFINITE); (writer blocks - no space for another 1024-byte message) reader thread &gt; rt_read_buffer(&amp;bf, ptr, 1024, TM_INFINITE); (short read - a truncated (1-byte) message is returned)</p>
<p>In order to prevent both threads to wait for each other indefinitely, a short read is allowed, which may be completed by a subsequent call to <a class="el" href="group__alchemy__buffer.html#ga4211643dcc88b52233c815fb9ba921e5" title="Read from an IPC buffer (with relative scalar timeout). ">rt_buffer_read()</a> or <a class="el" href="group__alchemy__buffer.html#ga7f640c6665eec926ff7f55f23bd4211a" title="Read from an IPC buffer (with absolute scalar timeout). ">rt_buffer_read_until()</a>. If that case arises, thread priorities, buffer and/or message lengths should likely be fixed, in order to eliminate such condition.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>abs_timeout</em> is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

<p>Referenced by <a class="el" href="group__alchemy__buffer.html#ga4211643dcc88b52233c815fb9ba921e5">rt_buffer_read()</a>, and <a class="el" href="group__alchemy__buffer.html#ga7f640c6665eec926ff7f55f23bd4211a">rt_buffer_read_until()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7f640c6665eec926ff7f55f23bd4211a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_buffer_read_until </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from an IPC buffer (with absolute scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__buffer.html#ga97409b5310b1d6e3fab95d29492a81be" title="Read from an IPC buffer. ">rt_buffer_read_timed()</a> accepting an absolute timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The buffer descriptor.</td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a memory area which will be written upon success with the received data.</td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of the memory area pointed to by <em>ptr</em>.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__buffer.html#ga97409b5310b1d6e3fab95d29492a81be">rt_buffer_read_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga85e669d38297fa6dff6e78339bb8329d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_buffer_unbind </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind from an IPC buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The buffer descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases a previous binding to an IPC buffer. After this call has returned, the descriptor is no more valid for referencing this object.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2ca66b283211381a978c4e905af05e96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_buffer_write </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write to an IPC buffer (with relative scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__buffer.html#ga93616331b7f6fda3dc8e01cac7b1c350" title="Write to an IPC buffer. ">rt_buffer_write_timed()</a> accepting a relative timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The buffer descriptor.</td></tr>
    <tr><td class="paramname">ptr</td><td>The address of the message data to be written to the buffer.</td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of the message data.</td></tr>
    <tr><td class="paramname">timeout</td><td>A delay expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__buffer.html#ga93616331b7f6fda3dc8e01cac7b1c350">rt_buffer_write_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga93616331b7f6fda3dc8e01cac7b1c350"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_buffer_write_timed </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to an IPC buffer. </p>
<p>This routine writes a message to the specified buffer. If not enough buffer space is available on entry to hold the message, the caller is allowed to block until enough room is freed, or a timeout elapses, whichever comes first.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The buffer descriptor.</td></tr>
    <tr><td class="paramname">ptr</td><td>The address of the message data to be written to the buffer.</td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of the message data. Zero is a valid value, in which case the buffer is left untouched, and zero is returned to the caller.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks, specifying a time limit to wait for enough buffer space to be available to hold the message (see note). Passing NULL causes the caller to block indefinitely until enough buffer space is available. Passing { .tv_sec = 0, .tv_nsec = 0 } causes the service to return immediately without blocking in case of buffer space shortage.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written to the buffer is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if the absolute <em>abs_timeout</em> date is reached before enough buffer space is available to hold the message.</li>
<li>-EWOULDBLOCK is returned if <em>abs_timeout</em> is { .tv_sec = 0, .tv_nsec = 0 } and no buffer space is immediately available on entry to hold the message.</li>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before enough buffer space became available to hold the message.</li>
<li>-EINVAL is returned if <em>bf</em> is not a valid buffer descriptor, or <em>len</em> is greater than the actual buffer length.</li>
<li>-EIDRM is returned if <em>bf</em> is deleted while the caller was waiting for buffer space. In such event, <em>bf</em> is no more valid upon return of this service.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>abs_timeout</em> is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

<p>Referenced by <a class="el" href="group__alchemy__buffer.html#ga2ca66b283211381a978c4e905af05e96">rt_buffer_write()</a>, and <a class="el" href="group__alchemy__buffer.html#gab2ff96871bd86e4d7304b05ea401ed72">rt_buffer_write_until()</a>.</p>

</div>
</div>
<a class="anchor" id="gab2ff96871bd86e4d7304b05ea401ed72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_buffer_write_until </td>
          <td>(</td>
          <td class="paramtype">RT_BUFFER *&#160;</td>
          <td class="paramname"><em>bf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write to an IPC buffer (with absolute scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__buffer.html#ga93616331b7f6fda3dc8e01cac7b1c350" title="Write to an IPC buffer. ">rt_buffer_write_timed()</a> accepting an absolute timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bf</td><td>The buffer descriptor.</td></tr>
    <tr><td class="paramname">ptr</td><td>The address of the message data to be written to the buffer.</td></tr>
    <tr><td class="paramname">len</td><td>The length in bytes of the message data.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__buffer.html#ga93616331b7f6fda3dc8e01cac7b1c350">rt_buffer_write_timed()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
