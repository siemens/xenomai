<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Message pipe services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__alchemy__pipe.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Message pipe services<div class="ingroups"><a class="el" href="group__alchemy.html">Alchemy API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Two-way communication channel between Xenomai &amp; Linux domains.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Message pipe services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__alchemy__pipe.png" border="0" alt="" usemap="#group____alchemy____pipe"/>
<map name="group____alchemy____pipe" id="group____alchemy____pipe">
<area shape="rect" id="node2" href="group__alchemy.html" title="A programming interface reminiscent from traditional RTOS APIs. " alt="" coords="5,5,104,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab3c99a1ac3ecd4d50be1b66be891a1db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__pipe.html#gab3c99a1ac3ecd4d50be1b66be891a1db">P_MINOR_AUTO</a>&#160;&#160;&#160;XNPIPE_MINOR_AUTO</td></tr>
<tr class="memdesc:gab3c99a1ac3ecd4d50be1b66be891a1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation flags.  <a href="#gab3c99a1ac3ecd4d50be1b66be891a1db">More...</a><br /></td></tr>
<tr class="separator:gab3c99a1ac3ecd4d50be1b66be891a1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ec5fa58851654f7b9770fc25c53335d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__pipe.html#ga5ec5fa58851654f7b9770fc25c53335d">P_URGENT</a>&#160;&#160;&#160;XNPIPE_URGENT</td></tr>
<tr class="memdesc:ga5ec5fa58851654f7b9770fc25c53335d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation flags.  <a href="#ga5ec5fa58851654f7b9770fc25c53335d">More...</a><br /></td></tr>
<tr class="separator:ga5ec5fa58851654f7b9770fc25c53335d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1d84976a1b9b668366261ca9b836b677"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__pipe.html#ga1d84976a1b9b668366261ca9b836b677">rt_pipe_delete</a> (RT_PIPE *pipe)</td></tr>
<tr class="memdesc:ga1d84976a1b9b668366261ca9b836b677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a message pipe.  <a href="#ga1d84976a1b9b668366261ca9b836b677">More...</a><br /></td></tr>
<tr class="separator:ga1d84976a1b9b668366261ca9b836b677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc073cf31f08531be5ae612864808c8"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__pipe.html#ga7dc073cf31f08531be5ae612864808c8">rt_pipe_read_timed</a> (RT_PIPE *pipe, void *buf, size_t size, const struct timespec *abs_timeout)</td></tr>
<tr class="memdesc:ga7dc073cf31f08531be5ae612864808c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a message from a pipe.  <a href="#ga7dc073cf31f08531be5ae612864808c8">More...</a><br /></td></tr>
<tr class="separator:ga7dc073cf31f08531be5ae612864808c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfa116f727ec6d1f9fd89df1332d210e"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__pipe.html#gabfa116f727ec6d1f9fd89df1332d210e">rt_pipe_read_until</a> (RT_PIPE *pipe, void *buf, size_t size, RTIME timeout)</td></tr>
<tr class="memdesc:gabfa116f727ec6d1f9fd89df1332d210e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a pipe (with absolute scalar timeout).  <a href="#gabfa116f727ec6d1f9fd89df1332d210e">More...</a><br /></td></tr>
<tr class="separator:gabfa116f727ec6d1f9fd89df1332d210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62cb64807c2c843f8e8eebb2dc3a7d4e"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__pipe.html#ga62cb64807c2c843f8e8eebb2dc3a7d4e">rt_pipe_read</a> (RT_PIPE *pipe, void *buf, size_t size, RTIME timeout)</td></tr>
<tr class="memdesc:ga62cb64807c2c843f8e8eebb2dc3a7d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from a pipe (with relative scalar timeout).  <a href="#ga62cb64807c2c843f8e8eebb2dc3a7d4e">More...</a><br /></td></tr>
<tr class="separator:ga62cb64807c2c843f8e8eebb2dc3a7d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f801963d0db6aa60bc6cf92f65697a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__pipe.html#ga12f801963d0db6aa60bc6cf92f65697a">rt_pipe_write</a> (RT_PIPE *pipe, const void *buf, size_t size, int mode)</td></tr>
<tr class="memdesc:ga12f801963d0db6aa60bc6cf92f65697a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a message to a pipe.  <a href="#ga12f801963d0db6aa60bc6cf92f65697a">More...</a><br /></td></tr>
<tr class="separator:ga12f801963d0db6aa60bc6cf92f65697a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8edc920499d2c5c5d821ee7b9fa2bcd"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__pipe.html#gad8edc920499d2c5c5d821ee7b9fa2bcd">rt_pipe_stream</a> (RT_PIPE *pipe, const void *buf, size_t size)</td></tr>
<tr class="memdesc:gad8edc920499d2c5c5d821ee7b9fa2bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream bytes through a pipe.  <a href="#gad8edc920499d2c5c5d821ee7b9fa2bcd">More...</a><br /></td></tr>
<tr class="separator:gad8edc920499d2c5c5d821ee7b9fa2bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac732fe4dbc24f9c57a79b58817119048"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__pipe.html#gac732fe4dbc24f9c57a79b58817119048">rt_pipe_bind</a> (RT_PIPE *pipe, const char *name, RTIME timeout)</td></tr>
<tr class="memdesc:gac732fe4dbc24f9c57a79b58817119048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to a message pipe.  <a href="#gac732fe4dbc24f9c57a79b58817119048">More...</a><br /></td></tr>
<tr class="separator:gac732fe4dbc24f9c57a79b58817119048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77722465437c7d65241cc6823b5b6793"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__pipe.html#ga77722465437c7d65241cc6823b5b6793">rt_pipe_unbind</a> (RT_PIPE *pipe)</td></tr>
<tr class="memdesc:ga77722465437c7d65241cc6823b5b6793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind from a message pipe.  <a href="#ga77722465437c7d65241cc6823b5b6793">More...</a><br /></td></tr>
<tr class="separator:ga77722465437c7d65241cc6823b5b6793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29521cc898afa0069963964955167aa5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__pipe.html#ga29521cc898afa0069963964955167aa5">rt_pipe_create</a> (RT_PIPE *pipe, const char *name, int minor, size_t poolsize)</td></tr>
<tr class="memdesc:ga29521cc898afa0069963964955167aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a message pipe.  <a href="#ga29521cc898afa0069963964955167aa5">More...</a><br /></td></tr>
<tr class="separator:ga29521cc898afa0069963964955167aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Two-way communication channel between Xenomai &amp; Linux domains. </p>
<p>A message pipe is a two-way communication channel between Xenomai threads and normal Linux threads using regular file I/O operations on a pseudo-device. Pipes can be operated in a message-oriented fashion so that message boundaries are preserved, and also in byte-oriented streaming mode from real-time to normal Linux threads for optimal throughput.</p>
<p>Xenomai threads open their side of the pipe using the <a class="el" href="group__alchemy__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe. ">rt_pipe_create()</a> service; regular Linux threads do the same by opening one of the /dev/rtpN special devices, where N is the minor number agreed upon between both ends of each pipe.</p>
<p>In addition, named pipes are available through the registry support, which automatically creates a symbolic link from entries under /proc/xenomai/registry/rtipc/xddp/ to the corresponding special device file.</p>
<dl class="section note"><dt>Note</dt><dd>Alchemy's message pipes are fully based on the <a class="el" href="group__rtdm__ipc.html#RTIPC_PROTO">XDDP protocol</a> available from the RTDM/ipc driver. </dd></dl>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gab3c99a1ac3ecd4d50be1b66be891a1db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define P_MINOR_AUTO&#160;&#160;&#160;XNPIPE_MINOR_AUTO</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation flags. </p>

<p>Referenced by <a class="el" href="group__alchemy__pipe.html#ga29521cc898afa0069963964955167aa5">rt_pipe_create()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ec5fa58851654f7b9770fc25c53335d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define P_URGENT&#160;&#160;&#160;XNPIPE_URGENT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation flags. </p>

<p>Referenced by <a class="el" href="group__alchemy__pipe.html#ga12f801963d0db6aa60bc6cf92f65697a">rt_pipe_write()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac732fe4dbc24f9c57a79b58817119048"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_bind </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind to a message pipe. </p>
<p>This routine creates a new descriptor to refer to an existing message pipe identified by its symbolic name. If the object does not exist on entry, the caller may block until a pipe of the given name is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The address of a pipe descriptor filled in by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td class="paramname">name</td><td>A valid NULL-terminated name which identifies the pipe to bind to. This string should match the object name argument passed to <a class="el" href="group__alchemy__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe. ">rt_pipe_create()</a>.</td></tr>
    <tr><td class="paramname">timeout</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before the retrieval has completed.</li>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

</div>
</div>
<a class="anchor" id="ga29521cc898afa0069963964955167aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_create </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>poolsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a message pipe. </p>
<p>This service opens a bi-directional communication channel for exchanging messages between Xenomai threads and regular Linux threads. Pipes natively preserve message boundaries, but can also be used in byte-oriented streaming mode from Xenomai to Linux.</p>
<p><a class="el" href="group__alchemy__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe. ">rt_pipe_create()</a> always returns immediately, even if no thread has opened the associated special device file yet. On the contrary, the non real-time side could block upon attempt to open the special device file until <a class="el" href="group__alchemy__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe. ">rt_pipe_create()</a> is issued on the same pipe from a Xenomai thread, unless O_NONBLOCK was given to the open(2) system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The address of a pipe descriptor which can be later used to identify uniquely the created object, upon success of this call.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the pipe. When non-NULL and non-empty, a copy of this string is used for indexing the created pipe into the object registry.</td></tr>
  </table>
  </dd>
</dl>
<p>Named pipes are supported through the use of the registry. Passing a valid <em>name</em> parameter when creating a message pipe causes a symbolic link to be created from /proc/xenomai/registry/rtipc/xddp/<em>name</em> to the associated special device (i.e. /dev/rtp*), so that the specific <em>minor</em> information does not need to be known from those processes for opening the proper device file. In such a case, both sides of the pipe only need to agree upon a symbolic name to refer to the same data path, which is especially useful whenever the <em>minor</em> number is picked up dynamically using an adaptive algorithm, such as passing P_MINOR_AUTO as <em>minor</em> value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minor</td><td>The minor number of the device associated with the pipe. Passing P_MINOR_AUTO causes the minor number to be auto-allocated. In such a case, a symbolic link will be automatically created from /proc/xenomai/registry/rtipc/xddp/<em>name</em> to the allocated pipe device entry. Valid minor numbers range from 0 to CONFIG_XENO_OPT_PIPE_NRDEV-1.</td></tr>
    <tr><td class="paramname">poolsize</td><td>Specifies the size of a dedicated buffer pool for the pipe. Passing 0 means that all message allocations for this pipe are performed on the Cobalt core heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <em>minor</em> number assigned to the connection is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ENOMEM is returned if the system fails to get memory from the main heap in order to create the pipe.</li>
<li>-ENODEV is returned if <em>minor</em> is different from P_MINOR_AUTO and is not a valid minor number.</li>
<li>-EEXIST is returned if the <em>name</em> is conflicting with an already registered pipe.</li>
<li>-EBUSY is returned if <em>minor</em> is already open.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a> </dd></dl>

<p>References <a class="el" href="group__rtdm__ipc.html#gga77867ab4129f63159b37bca3b652a798a28a488c3e7fc47dee4d5757f215f62e9">IPCPROTO_XDDP</a>, <a class="el" href="structrtipc__port__label.html#a24cdc7d42efdcf42b76e4fbfe8b238e9">rtipc_port_label::label</a>, <a class="el" href="group__alchemy__pipe.html#gab3c99a1ac3ecd4d50be1b66be891a1db">P_MINOR_AUTO</a>, <a class="el" href="structsockaddr__ipc.html#a34159a73aefb7bde8064259a058599bb">sockaddr_ipc::sipc_family</a>, <a class="el" href="structsockaddr__ipc.html#a03b5a7ead5dab3968fc543aaee649dd2">sockaddr_ipc::sipc_port</a>, <a class="el" href="group__rtdm__ipc.html#ga61a2c99e1588e761aff890c27df6e5bd">XDDP_BUFSZ</a>, <a class="el" href="group__rtdm__ipc.html#gaf8b123d7b54c95dd655b8a3b02d2759f">XDDP_LABEL</a>, and <a class="el" href="group__rtdm__ipc.html#ga40cc2513c4beb830fe3af2c205292d27">XDDP_POOLSZ</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d84976a1b9b668366261ca9b836b677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_delete </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&#160;</td>
          <td class="paramname"><em>pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a message pipe. </p>
<p>This routine deletes a pipe object previously created by a call to <a class="el" href="group__alchemy__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe. ">rt_pipe_create()</a>. All resources attached to that pipe are automatically released, all pending data is flushed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The pipe descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>pipe</em> is not a valid pipe descriptor.</li>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga62cb64807c2c843f8e8eebb2dc3a7d4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_read </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from a pipe (with relative scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__queue.html#gaa804ad003381fa7d6c67ca3fcc5851a3" title="Read from a queue. ">rt_queue_read_timed()</a> accepting a relative timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The pipe descriptor.</td></tr>
    <tr><td class="paramname">buf</td><td>A pointer to a memory area which will be written upon success with the message received.</td></tr>
    <tr><td class="paramname">size</td><td>The count of bytes from the received message to read up into <em>buf</em>. If <em>size</em> is lower than the actual message size, -ENOBUFS is returned since the incompletely received message would be lost. If <em>size</em> is zero, this call returns immediately with no other action.</td></tr>
    <tr><td class="paramname">timeout</td><td>A delay expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__pipe.html#ga7dc073cf31f08531be5ae612864808c8">rt_pipe_read_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7dc073cf31f08531be5ae612864808c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_read_timed </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a message from a pipe. </p>
<p>This service reads the next available message from a given pipe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The pipe descriptor.</td></tr>
    <tr><td class="paramname">buf</td><td>A pointer to a memory area which will be written upon success with the message received.</td></tr>
    <tr><td class="paramname">size</td><td>The count of bytes from the received message to read up into <em>buf</em>. If <em>size</em> is lower than the actual message size, -ENOBUFS is returned since the incompletely received message would be lost. If <em>size</em> is zero, this call returns immediately with no other action.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks, specifying a time limit to wait for a message to be available from the pipe (see note). Passing NULL causes the caller to block indefinitely until a message is available. Passing { .tv_sec = 0, .tv_nsec = 0 } causes the service to return immediately without blocking in case no message is available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes available from the received message is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if <em>abs_timeout</em> is reached before a message arrives.</li>
<li>-EWOULDBLOCK is returned if <em>abs_timeout</em> is { .tv_sec = 0, .tv_nsec = 0 } and no message is immediately available on entry to the call.</li>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before a message was available.</li>
<li>-EINVAL is returned if <em>pipe</em> is not a valid pipe descriptor.</li>
<li>-EIDRM is returned if <em>pipe</em> is deleted while the caller was waiting for a message. In such event, <em>pipe</em> is no more valid upon return of this service.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>abs_timeout</em> is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

<p>References <a class="el" href="group__rtdm__ipc.html#gaf2d1ed6a34336a6f3df80fb518325846">SO_RCVTIMEO</a>.</p>

<p>Referenced by <a class="el" href="group__alchemy__pipe.html#ga62cb64807c2c843f8e8eebb2dc3a7d4e">rt_pipe_read()</a>, and <a class="el" href="group__alchemy__pipe.html#gabfa116f727ec6d1f9fd89df1332d210e">rt_pipe_read_until()</a>.</p>

</div>
</div>
<a class="anchor" id="gabfa116f727ec6d1f9fd89df1332d210e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_read_until </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from a pipe (with absolute scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__queue.html#gaa804ad003381fa7d6c67ca3fcc5851a3" title="Read from a queue. ">rt_queue_read_timed()</a> accepting an absolute timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The pipe descriptor.</td></tr>
    <tr><td class="paramname">buf</td><td>A pointer to a memory area which will be written upon success with the message received.</td></tr>
    <tr><td class="paramname">size</td><td>The count of bytes from the received message to read up into <em>buf</em>. If <em>size</em> is lower than the actual message size, -ENOBUFS is returned since the incompletely received message would be lost. If <em>size</em> is zero, this call returns immediately with no other action.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__pipe.html#ga7dc073cf31f08531be5ae612864808c8">rt_pipe_read_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="gad8edc920499d2c5c5d821ee7b9fa2bcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_stream </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream bytes through a pipe. </p>
<p>This service writes a sequence of bytes to be received from the associated special device. Unlike rt_pipe_send(), this service does not preserve message boundaries. Instead, an internal buffer is filled on the fly with the data, which will be consumed as soon as the receiver wakes up.</p>
<p>Data buffers sent by the <a class="el" href="group__alchemy__pipe.html#gad8edc920499d2c5c5d821ee7b9fa2bcd" title="Stream bytes through a pipe. ">rt_pipe_stream()</a> service are always transmitted in FIFO order (i.e. P_NORMAL mode).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The pipe descriptor.</td></tr>
    <tr><td class="paramname">buf</td><td>The address of the first data byte to send. The data will be copied to an internal buffer before transmission.</td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the buffer. Zero is a valid value, in which case the service returns immediately without sending any data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes sent upon success; this value may be lower than <em>size</em>, depending on the available space in the internal buffer. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mode</em> is invalid or <em>pipe</em> is not a pipe descriptor.</li>
<li>-ENOMEM is returned if not enough buffer space is available to complete the operation.</li>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Writing data to a pipe before any peer has opened the associated special device is allowed. The output will be buffered until then, only restricted by the available memory in the associated buffer pool (see <a class="el" href="group__alchemy__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe. ">rt_pipe_create()</a>).</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xcontext, switch-primary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga77722465437c7d65241cc6823b5b6793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_pipe_unbind </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&#160;</td>
          <td class="paramname"><em>pipe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind from a message pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The pipe descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases a previous binding to a message pipe. After this call has returned, the descriptor is no more valid for referencing this object.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga12f801963d0db6aa60bc6cf92f65697a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_pipe_write </td>
          <td>(</td>
          <td class="paramtype">RT_PIPE *&#160;</td>
          <td class="paramname"><em>pipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a message to a pipe. </p>
<p>This service writes a complete message to be received from the associated special device. <a class="el" href="group__alchemy__pipe.html#ga12f801963d0db6aa60bc6cf92f65697a" title="Write a message to a pipe. ">rt_pipe_write()</a> always preserves message boundaries, which means that all data sent through a single call of this service will be gathered in a single read(2) operation from the special device.</p>
<p>This service differs from rt_pipe_send() in that it accepts a pointer to the raw data to be sent, instead of a canned message buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The pipe descriptor.</td></tr>
    <tr><td class="paramname">buf</td><td>The address of the first data byte to send. The data will be copied to an internal buffer before transmission.</td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the message (payload data only). Zero is a valid value, in which case the service returns immediately without sending any message.</td></tr>
    <tr><td class="paramname">mode</td><td>A set of flags affecting the operation:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>P_URGENT causes the message to be prepended to the output queue, ensuring a LIFO ordering.</li>
<li>P_NORMAL causes the message to be appended to the output queue, ensuring a FIFO ordering.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Upon success, this service returns <em>size</em>. Upon error, one of the following error codes is returned:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mode</em> is invalid or <em>pipe</em> is not a pipe descriptor.</li>
<li>-ENOMEM is returned if not enough buffer space is available to complete the operation.</li>
<li>-EIDRM is returned if <em>pipe</em> is a closed pipe descriptor.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Writing data to a pipe before any peer has opened the associated special device is allowed. The output will be buffered until then, only restricted by the available memory in the associated buffer pool (see <a class="el" href="group__alchemy__pipe.html#ga29521cc898afa0069963964955167aa5" title="Create a message pipe. ">rt_pipe_create()</a>).</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xcontext, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__pipe.html#ga5ec5fa58851654f7b9770fc25c53335d">P_URGENT</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
