<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Heap management services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__alchemy__heap.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Heap management services<div class="ingroups"><a class="el" href="group__alchemy.html">Alchemy API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Region of memory dedicated to real-time allocation.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Heap management services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__alchemy__heap.png" border="0" alt="" usemap="#group____alchemy____heap"/>
<map name="group____alchemy____heap" id="group____alchemy____heap">
<area shape="rect" id="node2" href="group__alchemy.html" title="A programming interface reminiscent from traditional RTOS APIs. " alt="" coords="5,5,104,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRT__HEAP__INFO.html">RT_HEAP_INFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap status descriptor.  <a href="structRT__HEAP__INFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga03f467dfa5ca3efba8265b75ac122254"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__heap.html#ga03f467dfa5ca3efba8265b75ac122254">H_PRIO</a>&#160;&#160;&#160;0x1	/* Pend by task priority order. */</td></tr>
<tr class="memdesc:ga03f467dfa5ca3efba8265b75ac122254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creation flags.  <a href="#ga03f467dfa5ca3efba8265b75ac122254">More...</a><br /></td></tr>
<tr class="separator:ga03f467dfa5ca3efba8265b75ac122254"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1d19ad24dc9f94b969aa0f574170bdc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__heap.html#ga1d19ad24dc9f94b969aa0f574170bdc4">rt_heap_create</a> (RT_HEAP *heap, const char *name, size_t heapsize, int mode)</td></tr>
<tr class="memdesc:ga1d19ad24dc9f94b969aa0f574170bdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a heap.  <a href="#ga1d19ad24dc9f94b969aa0f574170bdc4">More...</a><br /></td></tr>
<tr class="separator:ga1d19ad24dc9f94b969aa0f574170bdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f8d244a545fd6a5719ad5708552552"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__heap.html#ga08f8d244a545fd6a5719ad5708552552">rt_heap_delete</a> (RT_HEAP *heap)</td></tr>
<tr class="memdesc:ga08f8d244a545fd6a5719ad5708552552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a heap.  <a href="#ga08f8d244a545fd6a5719ad5708552552">More...</a><br /></td></tr>
<tr class="separator:ga08f8d244a545fd6a5719ad5708552552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca496fa6b36c12f9728e4104ce3f017"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__heap.html#ga4ca496fa6b36c12f9728e4104ce3f017">rt_heap_alloc_timed</a> (RT_HEAP *heap, size_t size, const struct timespec *abs_timeout, void **blockp)</td></tr>
<tr class="memdesc:ga4ca496fa6b36c12f9728e4104ce3f017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block from a heap.  <a href="#ga4ca496fa6b36c12f9728e4104ce3f017">More...</a><br /></td></tr>
<tr class="separator:ga4ca496fa6b36c12f9728e4104ce3f017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c06c617f85bb803676aa79273023454"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__heap.html#ga1c06c617f85bb803676aa79273023454">rt_heap_alloc_until</a> (RT_HEAP *heap, size_t size, RTIME timeout, void **blockp)</td></tr>
<tr class="memdesc:ga1c06c617f85bb803676aa79273023454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block from a heap (with absolute scalar timeout).  <a href="#ga1c06c617f85bb803676aa79273023454">More...</a><br /></td></tr>
<tr class="separator:ga1c06c617f85bb803676aa79273023454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52678149ff2b66e47aa8cdcddab653a4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__heap.html#ga52678149ff2b66e47aa8cdcddab653a4">rt_heap_alloc</a> (RT_HEAP *heap, size_t size, RTIME timeout, void **blockp)</td></tr>
<tr class="memdesc:ga52678149ff2b66e47aa8cdcddab653a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block from a heap (with relative scalar timeout).  <a href="#ga52678149ff2b66e47aa8cdcddab653a4">More...</a><br /></td></tr>
<tr class="separator:ga52678149ff2b66e47aa8cdcddab653a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300ca8c868d02dad99790fe39b443f6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__heap.html#ga300ca8c868d02dad99790fe39b443f6f">rt_heap_free</a> (RT_HEAP *heap, void *block)</td></tr>
<tr class="memdesc:ga300ca8c868d02dad99790fe39b443f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a block to a heap.  <a href="#ga300ca8c868d02dad99790fe39b443f6f">More...</a><br /></td></tr>
<tr class="separator:ga300ca8c868d02dad99790fe39b443f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6af669528e1bcae4f1ed15b292bda08e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__heap.html#ga6af669528e1bcae4f1ed15b292bda08e">rt_heap_inquire</a> (RT_HEAP *heap, <a class="el" href="structRT__HEAP__INFO.html">RT_HEAP_INFO</a> *info)</td></tr>
<tr class="memdesc:ga6af669528e1bcae4f1ed15b292bda08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query heap status.  <a href="#ga6af669528e1bcae4f1ed15b292bda08e">More...</a><br /></td></tr>
<tr class="separator:ga6af669528e1bcae4f1ed15b292bda08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae17a8784a83d2eec94089a86a831a833"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__heap.html#gae17a8784a83d2eec94089a86a831a833">rt_heap_bind</a> (RT_HEAP *heap, const char *name, RTIME timeout)</td></tr>
<tr class="memdesc:gae17a8784a83d2eec94089a86a831a833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to a heap.  <a href="#gae17a8784a83d2eec94089a86a831a833">More...</a><br /></td></tr>
<tr class="separator:gae17a8784a83d2eec94089a86a831a833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea086656fe119a563e8c0b6d44f83c8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__heap.html#gaea086656fe119a563e8c0b6d44f83c8e">rt_heap_unbind</a> (RT_HEAP *heap)</td></tr>
<tr class="memdesc:gaea086656fe119a563e8c0b6d44f83c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind from a heap.  <a href="#gaea086656fe119a563e8c0b6d44f83c8e">More...</a><br /></td></tr>
<tr class="separator:gaea086656fe119a563e8c0b6d44f83c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Region of memory dedicated to real-time allocation. </p>
<p>Heaps are regions of memory used for dynamic memory allocation in a time-bounded fashion. Blocks of memory are allocated and freed in an arbitrary order and the pattern of allocation and size of blocks is not known until run time. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga03f467dfa5ca3efba8265b75ac122254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define H_PRIO&#160;&#160;&#160;0x1	/* Pend by task priority order. */</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creation flags. </p>

<p>Referenced by <a class="el" href="group__alchemy__heap.html#ga1d19ad24dc9f94b969aa0f574170bdc4">rt_heap_create()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga52678149ff2b66e47aa8cdcddab653a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_alloc </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>blockp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a block from a heap (with relative scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__heap.html#ga4ca496fa6b36c12f9728e4104ce3f017" title="Allocate a block from a heap. ">rt_heap_alloc_timed()</a> accepting a relative timeout specification expressed as a scalar value.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__heap.html#ga4ca496fa6b36c12f9728e4104ce3f017">rt_heap_alloc_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ca496fa6b36c12f9728e4104ce3f017"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_alloc_timed </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abs_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>blockp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a block from a heap. </p>
<p>This service allocates a block from a given heap, or returns the address of the single memory segment if H_SINGLE was mentioned in the creation mode to <a class="el" href="group__alchemy__heap.html#ga1d19ad24dc9f94b969aa0f574170bdc4" title="Create a heap. ">rt_heap_create()</a>. When not enough memory is available on entry to this service, tasks may be blocked until their allocation request can be fulfilled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap descriptor.</td></tr>
    <tr><td class="paramname">size</td><td>The requested size (in bytes) of the block. If the heap is managed as a single-block area (H_SINGLE), this value can be either zero, or the same value given to <a class="el" href="group__alchemy__heap.html#ga1d19ad24dc9f94b969aa0f574170bdc4" title="Create a heap. ">rt_heap_create()</a>. In that case, the same block covering the entire heap space is returned to all callers of this service.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks, specifying a time limit to wait for a block of the requested size to be available from the heap (see note). Passing NULL causes the caller to block indefinitely until a block is available. Passing { .tv_sec = 0, .tv_nsec = 0 } causes the service to return immediately without blocking in case not block is available.</td></tr>
    <tr><td class="paramname">blockp</td><td>A pointer to a memory location which will be written upon success with the address of the allocated block, or the start address of the single memory segment. In the former case, the block can be freed using <a class="el" href="group__alchemy__heap.html#ga300ca8c868d02dad99790fe39b443f6f" title="Release a block to a heap. ">rt_heap_free()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned if <em>abs_timeout</em> is reached before a block is available.</li>
<li>-EWOULDBLOCK is returned if <em>abs_timeout</em> is equal to { .tv_sec = 0, .tv_nsec = 0 } and no block is immediately available on entry to fulfill the allocation request.</li>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before a block became available.</li>
<li>-EINVAL is returned if <em>heap</em> is not a valid heap descriptor, or <em>heap</em> is managed as a single-block area (i.e. H_SINGLE mode) and <em>size</em> is non-zero but does not match the original heap size passed to <a class="el" href="group__alchemy__heap.html#ga1d19ad24dc9f94b969aa0f574170bdc4" title="Create a heap. ">rt_heap_create()</a>.</li>
<li>-EIDRM is returned if <em>heap</em> is deleted while the caller was waiting for a block. In such event, <em>heap</em> is no more valid upon return of this service.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If shared multi-processing is enabled (i.e. &ndash;enable-pshared was passed to the configure script), requests for a block size larger than twice the allocation page size are rounded up to the next page size. The allocation page size is currently 512 bytes long (HOBJ_PAGE_SIZE), which means that any request larger than 1k will be rounded up to the next 512 byte boundary.</dd>
<dd>
<em>abs_timeout</em> is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

<p>Referenced by <a class="el" href="group__alchemy__heap.html#ga52678149ff2b66e47aa8cdcddab653a4">rt_heap_alloc()</a>, and <a class="el" href="group__alchemy__heap.html#ga1c06c617f85bb803676aa79273023454">rt_heap_alloc_until()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1c06c617f85bb803676aa79273023454"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_alloc_until </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>abs_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>blockp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a block from a heap (with absolute scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__heap.html#ga4ca496fa6b36c12f9728e4104ce3f017" title="Allocate a block from a heap. ">rt_heap_alloc_timed()</a> accepting an absolute timeout specification expressed as a scalar value.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__heap.html#ga4ca496fa6b36c12f9728e4104ce3f017">rt_heap_alloc_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="gae17a8784a83d2eec94089a86a831a833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_bind </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind to a heap. </p>
<p>This routine creates a new descriptor to refer to an existing heap identified by its symbolic name. If the object does not exist on entry, the caller may block until a heap of the given name is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The address of a heap descriptor filled in by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td class="paramname">name</td><td>A valid NULL-terminated name which identifies the heap to bind to. This string should match the object name argument passed to <a class="el" href="group__alchemy__heap.html#ga1d19ad24dc9f94b969aa0f574170bdc4" title="Create a heap. ">rt_heap_create()</a>.</td></tr>
    <tr><td class="paramname">timeout</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before the retrieval has completed.</li>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d19ad24dc9f94b969aa0f574170bdc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_create </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>heapsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a heap. </p>
<p>This routine creates a memory heap suitable for time-bounded allocation requests of RAM chunks. When not enough memory is available, tasks may be blocked until their allocation request can be fulfilled.</p>
<p>By default, heaps support allocation of multiple blocks of memory in an arbitrary order. However, it is possible to ask for single-block management by passing the H_SINGLE flag into the <em>mode</em> parameter, in which case the entire memory space managed by the heap is made available as a unique block. In this mode, all allocation requests made through <a class="el" href="group__alchemy__heap.html#ga52678149ff2b66e47aa8cdcddab653a4" title="Allocate a block from a heap (with relative scalar timeout). ">rt_heap_alloc()</a> will return the same block address, pointing at the beginning of the heap memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The address of a heap descriptor which can be later used to identify uniquely the created object, upon success of this call.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the heap. When non-NULL and non-empty, a copy of this string is used for indexing the created heap into the object registry.</td></tr>
    <tr><td class="paramname">heapsz</td><td>The size (in bytes) of the memory pool, blocks will be claimed and released to. This area is not extensible, so this value must be compatible with the highest memory pressure that could be expected. The valid range is between 1 byte and 2Gb.</td></tr>
    <tr><td class="paramname">mode</td><td>The heap creation mode. The following flags can be OR'ed into this bitmask, each of them affecting the new heap:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>H_FIFO makes tasks pend in FIFO order on the heap when waiting for available blocks.</li>
<li>H_PRIO makes tasks pend in priority order on the heap when waiting for available blocks.</li>
<li>H_SINGLE causes the entire heap space to be managed as a single memory block.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>mode</em> is invalid, or <em>heapsz</em> is zero or larger than 2Gb.</li>
<li>-ENOMEM is returned if the system fails to get memory from the main heap in order to create the heap.</li>
<li>-EEXIST is returned if the <em>name</em> is conflicting with an already registered heap.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Heaps can be shared by multiple processes which belong to the same Xenomai session. </dd></dl>

<p>References <a class="el" href="group__alchemy__heap.html#ga03f467dfa5ca3efba8265b75ac122254">H_PRIO</a>.</p>

</div>
</div>
<a class="anchor" id="ga08f8d244a545fd6a5719ad5708552552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_delete </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a heap. </p>
<p>This routine deletes a heap object previously created by a call to <a class="el" href="group__alchemy__heap.html#ga1d19ad24dc9f94b969aa0f574170bdc4" title="Create a heap. ">rt_heap_create()</a>, releasing all tasks currently blocked on it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>heap</em> is not a valid heap descriptor.</li>
<li>-EPERM is returned if this service was called from an asynchronous context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga300ca8c868d02dad99790fe39b443f6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_free </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a block to a heap. </p>
<p>This service should be used to release a block to the heap it belongs to. An attempt to fulfill the request of every task blocked on <a class="el" href="group__alchemy__heap.html#ga52678149ff2b66e47aa8cdcddab653a4" title="Allocate a block from a heap (with relative scalar timeout). ">rt_heap_alloc()</a> is made once <em>block</em> is returned to the memory pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap descriptor.</td></tr>
    <tr><td class="paramname">block</td><td>The address of the block to free.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>heap</em> is not a valid heap descriptor, or <em>block</em> is not a valid block previously allocated by the <a class="el" href="group__alchemy__heap.html#ga52678149ff2b66e47aa8cdcddab653a4" title="Allocate a block from a heap (with relative scalar timeout). ">rt_heap_alloc()</a> service from <em>heap</em>.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted, switch-primary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6af669528e1bcae4f1ed15b292bda08e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_inquire </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRT__HEAP__INFO.html">RT_HEAP_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query heap status. </p>
<p>This routine returns the status information about <em>heap</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap descriptor.</td></tr>
    <tr><td class="paramname">info</td><td>A pointer to the <a class="el" href="structRT__HEAP__INFO.html#RT_HEAP_INFO">return</a>buffer" to copy the information to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned and status information is written to the structure pointed at by <em>info</em> upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>heap</em> is not a valid heap descriptor.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted, switch-primary</a> </dd></dl>

<p>References <a class="el" href="structRT__HEAP__INFO.html#ab2ffdb8f24680e5b31565c1c67dc0d47">RT_HEAP_INFO::heapsize</a>, <a class="el" href="structRT__HEAP__INFO.html#a4cdd30f308e5e09871b87755ca5224d3">RT_HEAP_INFO::name</a>, <a class="el" href="structRT__HEAP__INFO.html#a02db2cbfe67efccd1dc849d489db533a">RT_HEAP_INFO::nwaiters</a>, <a class="el" href="structRT__HEAP__INFO.html#adf0c5f124ab3e315664507c6a89d2dab">RT_HEAP_INFO::usablemem</a>, and <a class="el" href="structRT__HEAP__INFO.html#a8f53bac1667b14a7f05108c2a3802f54">RT_HEAP_INFO::usedmem</a>.</p>

</div>
</div>
<a class="anchor" id="gaea086656fe119a563e8c0b6d44f83c8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_heap_unbind </td>
          <td>(</td>
          <td class="paramtype">RT_HEAP *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind from a heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>The heap descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases a previous binding to a heap. After this call has returned, the descriptor is no more valid for referencing this object.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
