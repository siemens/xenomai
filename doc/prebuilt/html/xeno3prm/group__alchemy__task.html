<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Task management services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__alchemy__task.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Task management services<div class="ingroups"><a class="el" href="group__alchemy.html">Alchemy API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Services dealing with preemptive multi-tasking.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Task management services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__alchemy__task.png" border="0" alt="" usemap="#group____alchemy____task"/>
<map name="group____alchemy____task" id="group____alchemy____task">
<area shape="rect" id="node2" href="group__alchemy.html" title="A programming interface reminiscent from traditional RTOS APIs. " alt="" coords="5,5,104,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRT__TASK__INFO.html">RT_TASK_INFO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task status descriptor.  <a href="structRT__TASK__INFO.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4b84dc0d444a96e1e417d480e803d32e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga4b84dc0d444a96e1e417d480e803d32e">T_LOPRIO</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga4b84dc0d444a96e1e417d480e803d32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task priorities.  <a href="#ga4b84dc0d444a96e1e417d480e803d32e">More...</a><br /></td></tr>
<tr class="separator:ga4b84dc0d444a96e1e417d480e803d32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ac6cf9677bae1012ecbcb6037d14fcb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga2ac6cf9677bae1012ecbcb6037d14fcb">T_LOCK</a>&#160;&#160;&#160;__THREAD_M_LOCK</td></tr>
<tr class="memdesc:ga2ac6cf9677bae1012ecbcb6037d14fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task mode bits.  <a href="#ga2ac6cf9677bae1012ecbcb6037d14fcb">More...</a><br /></td></tr>
<tr class="separator:ga2ac6cf9677bae1012ecbcb6037d14fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga725324cb26d8b5835c0818acb738bfe6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga725324cb26d8b5835c0818acb738bfe6">T_WARNSW</a>&#160;&#160;&#160;__THREAD_M_WARNSW</td></tr>
<tr class="memdesc:ga725324cb26d8b5835c0818acb738bfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cobalt only, nop over Mercury.  <a href="#ga725324cb26d8b5835c0818acb738bfe6">More...</a><br /></td></tr>
<tr class="separator:ga725324cb26d8b5835c0818acb738bfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab6e0d411830710e8cc82d77b9df19510"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#gab6e0d411830710e8cc82d77b9df19510">rt_task_delete</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:gab6e0d411830710e8cc82d77b9df19510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a real-time task.  <a href="#gab6e0d411830710e8cc82d77b9df19510">More...</a><br /></td></tr>
<tr class="separator:gab6e0d411830710e8cc82d77b9df19510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92ea8c9fed3c5a3789538c9c8362c28"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#gad92ea8c9fed3c5a3789538c9c8362c28">rt_task_set_affinity</a> (RT_TASK *task, const cpu_set_t *cpus)</td></tr>
<tr class="memdesc:gad92ea8c9fed3c5a3789538c9c8362c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set CPU affinity of real-time task.  <a href="#gad92ea8c9fed3c5a3789538c9c8362c28">More...</a><br /></td></tr>
<tr class="separator:gad92ea8c9fed3c5a3789538c9c8362c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee3863a29497e2181d49d5b3ecfd855"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga3ee3863a29497e2181d49d5b3ecfd855">rt_task_start</a> (RT_TASK *task, void(*entry)(void *arg), void *arg)</td></tr>
<tr class="memdesc:ga3ee3863a29497e2181d49d5b3ecfd855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a real-time task.  <a href="#ga3ee3863a29497e2181d49d5b3ecfd855">More...</a><br /></td></tr>
<tr class="separator:ga3ee3863a29497e2181d49d5b3ecfd855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e0a9355d06c346a95bf88b857a9749"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga72e0a9355d06c346a95bf88b857a9749">rt_task_shadow</a> (RT_TASK *task, const char *name, int prio, int mode)</td></tr>
<tr class="memdesc:ga72e0a9355d06c346a95bf88b857a9749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn caller into a real-time task.  <a href="#ga72e0a9355d06c346a95bf88b857a9749">More...</a><br /></td></tr>
<tr class="separator:ga72e0a9355d06c346a95bf88b857a9749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c77d57638578a126812e29429f61fe7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga8c77d57638578a126812e29429f61fe7">rt_task_join</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:ga8c77d57638578a126812e29429f61fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on the termination of a real-time task.  <a href="#ga8c77d57638578a126812e29429f61fe7">More...</a><br /></td></tr>
<tr class="separator:ga8c77d57638578a126812e29429f61fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1645d3a072ef3cefeed3bcbb27dcf108"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga1645d3a072ef3cefeed3bcbb27dcf108">rt_task_wait_period</a> (unsigned long *overruns_r)</td></tr>
<tr class="memdesc:ga1645d3a072ef3cefeed3bcbb27dcf108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the next periodic release point.  <a href="#ga1645d3a072ef3cefeed3bcbb27dcf108">More...</a><br /></td></tr>
<tr class="separator:ga1645d3a072ef3cefeed3bcbb27dcf108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5225e5fb8d583fbdfa5299f322b8366"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#gad5225e5fb8d583fbdfa5299f322b8366">rt_task_sleep</a> (RTIME delay)</td></tr>
<tr class="memdesc:gad5225e5fb8d583fbdfa5299f322b8366"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay the current real-time task (with relative delay).  <a href="#gad5225e5fb8d583fbdfa5299f322b8366">More...</a><br /></td></tr>
<tr class="separator:gad5225e5fb8d583fbdfa5299f322b8366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dc2deebe7500c9d21ff05d51d5efaa8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga0dc2deebe7500c9d21ff05d51d5efaa8">rt_task_sleep_until</a> (RTIME date)</td></tr>
<tr class="memdesc:ga0dc2deebe7500c9d21ff05d51d5efaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay the current real-time task (with absolute wakeup date).  <a href="#ga0dc2deebe7500c9d21ff05d51d5efaa8">More...</a><br /></td></tr>
<tr class="separator:ga0dc2deebe7500c9d21ff05d51d5efaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6e313941a3fea606be8d0f66380e922"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#gaf6e313941a3fea606be8d0f66380e922">rt_task_same</a> (RT_TASK *task1, RT_TASK *task2)</td></tr>
<tr class="memdesc:gaf6e313941a3fea606be8d0f66380e922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare real-time task descriptors.  <a href="#gaf6e313941a3fea606be8d0f66380e922">More...</a><br /></td></tr>
<tr class="separator:gaf6e313941a3fea606be8d0f66380e922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga926a4b10e3631f76c5f38910e6eea24c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga926a4b10e3631f76c5f38910e6eea24c">rt_task_suspend</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:ga926a4b10e3631f76c5f38910e6eea24c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a real-time task.  <a href="#ga926a4b10e3631f76c5f38910e6eea24c">More...</a><br /></td></tr>
<tr class="separator:ga926a4b10e3631f76c5f38910e6eea24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fab1aa24ef6f199546fd9669ae711be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga1fab1aa24ef6f199546fd9669ae711be">rt_task_resume</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:ga1fab1aa24ef6f199546fd9669ae711be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a real-time task.  <a href="#ga1fab1aa24ef6f199546fd9669ae711be">More...</a><br /></td></tr>
<tr class="separator:ga1fab1aa24ef6f199546fd9669ae711be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a17935f049171be2ac8945abc68da6a"><td class="memItemLeft" align="right" valign="top">RT_TASK *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga8a17935f049171be2ac8945abc68da6a">rt_task_self</a> (void)</td></tr>
<tr class="memdesc:ga8a17935f049171be2ac8945abc68da6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current task descriptor.  <a href="#ga8a17935f049171be2ac8945abc68da6a">More...</a><br /></td></tr>
<tr class="separator:ga8a17935f049171be2ac8945abc68da6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bed8d001e212a3328a4e7e73f1765e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga3bed8d001e212a3328a4e7e73f1765e8">rt_task_set_priority</a> (RT_TASK *task, int prio)</td></tr>
<tr class="memdesc:ga3bed8d001e212a3328a4e7e73f1765e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the base priority of a real-time task.  <a href="#ga3bed8d001e212a3328a4e7e73f1765e8">More...</a><br /></td></tr>
<tr class="separator:ga3bed8d001e212a3328a4e7e73f1765e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga915e7edfb0aaddb643794d7abc7093bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga915e7edfb0aaddb643794d7abc7093bf">rt_task_set_mode</a> (int clrmask, int setmask, int *mode_r)</td></tr>
<tr class="memdesc:ga915e7edfb0aaddb643794d7abc7093bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the current task mode.  <a href="#ga915e7edfb0aaddb643794d7abc7093bf">More...</a><br /></td></tr>
<tr class="separator:ga915e7edfb0aaddb643794d7abc7093bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31e44b069b2486c2d2bdfb8a0a3557c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga31e44b069b2486c2d2bdfb8a0a3557c8">rt_task_yield</a> (void)</td></tr>
<tr class="memdesc:ga31e44b069b2486c2d2bdfb8a0a3557c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manual round-robin.  <a href="#ga31e44b069b2486c2d2bdfb8a0a3557c8">More...</a><br /></td></tr>
<tr class="separator:ga31e44b069b2486c2d2bdfb8a0a3557c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770281eeca009c0a08a7c4a9fd849ac1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1">rt_task_unblock</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:ga770281eeca009c0a08a7c4a9fd849ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock a real-time task.  <a href="#ga770281eeca009c0a08a7c4a9fd849ac1">More...</a><br /></td></tr>
<tr class="separator:ga770281eeca009c0a08a7c4a9fd849ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9250436d7bd9e49a0320161d2e9373ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga9250436d7bd9e49a0320161d2e9373ae">rt_task_slice</a> (RT_TASK *task, RTIME quantum)</td></tr>
<tr class="memdesc:ga9250436d7bd9e49a0320161d2e9373ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a task's round-robin quantum.  <a href="#ga9250436d7bd9e49a0320161d2e9373ae">More...</a><br /></td></tr>
<tr class="separator:ga9250436d7bd9e49a0320161d2e9373ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53bad6acf5496f8008e594954507dce8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga53bad6acf5496f8008e594954507dce8">rt_task_inquire</a> (RT_TASK *task, <a class="el" href="structRT__TASK__INFO.html">RT_TASK_INFO</a> *info)</td></tr>
<tr class="memdesc:ga53bad6acf5496f8008e594954507dce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve information about a real-time task.  <a href="#ga53bad6acf5496f8008e594954507dce8">More...</a><br /></td></tr>
<tr class="separator:ga53bad6acf5496f8008e594954507dce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e40ae8b8ab82c1fddc26fed12d4ec2"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga10e40ae8b8ab82c1fddc26fed12d4ec2">rt_task_send_timed</a> (RT_TASK *task, RT_TASK_MCB *mcb_s, RT_TASK_MCB *mcb_r, const struct timespec *abs_timeout)</td></tr>
<tr class="memdesc:ga10e40ae8b8ab82c1fddc26fed12d4ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to a real-time task.  <a href="#ga10e40ae8b8ab82c1fddc26fed12d4ec2">More...</a><br /></td></tr>
<tr class="separator:ga10e40ae8b8ab82c1fddc26fed12d4ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74378805e49a613863a048bfaa70e9df"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga74378805e49a613863a048bfaa70e9df">rt_task_send_until</a> (RT_TASK *task, RT_TASK_MCB *mcb_s, RT_TASK_MCB *mcb_r, RTIME timeout)</td></tr>
<tr class="memdesc:ga74378805e49a613863a048bfaa70e9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to a real-time task (with absolute scalar timeout).  <a href="#ga74378805e49a613863a048bfaa70e9df">More...</a><br /></td></tr>
<tr class="separator:ga74378805e49a613863a048bfaa70e9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a89c21c9866e2784860e100a444b49"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga99a89c21c9866e2784860e100a444b49">rt_task_send</a> (RT_TASK *task, RT_TASK_MCB *mcb_s, RT_TASK_MCB *mcb_r, RTIME timeout)</td></tr>
<tr class="memdesc:ga99a89c21c9866e2784860e100a444b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to a real-time task (with relative scalar timeout).  <a href="#ga99a89c21c9866e2784860e100a444b49">More...</a><br /></td></tr>
<tr class="separator:ga99a89c21c9866e2784860e100a444b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2ad79df07c5589d5c646ea836b6a777"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#gaf2ad79df07c5589d5c646ea836b6a777">rt_task_receive_timed</a> (RT_TASK_MCB *mcb_r, const struct timespec *abs_timeout)</td></tr>
<tr class="memdesc:gaf2ad79df07c5589d5c646ea836b6a777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message from a real-time task.  <a href="#gaf2ad79df07c5589d5c646ea836b6a777">More...</a><br /></td></tr>
<tr class="separator:gaf2ad79df07c5589d5c646ea836b6a777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa51bdd7ba60692deca7bedbb99d76ae1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#gaa51bdd7ba60692deca7bedbb99d76ae1">rt_task_receive_until</a> (RT_TASK_MCB *mcb_r, RTIME timeout)</td></tr>
<tr class="memdesc:gaa51bdd7ba60692deca7bedbb99d76ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message from a real-time task (with absolute scalar timeout).  <a href="#gaa51bdd7ba60692deca7bedbb99d76ae1">More...</a><br /></td></tr>
<tr class="separator:gaa51bdd7ba60692deca7bedbb99d76ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd88694130824cdf1abf7a4f119e742"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga8fd88694130824cdf1abf7a4f119e742">rt_task_receive</a> (RT_TASK_MCB *mcb_r, RTIME timeout)</td></tr>
<tr class="memdesc:ga8fd88694130824cdf1abf7a4f119e742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message from a real-time task (with relative scalar timeout).  <a href="#ga8fd88694130824cdf1abf7a4f119e742">More...</a><br /></td></tr>
<tr class="separator:ga8fd88694130824cdf1abf7a4f119e742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd8a4fb2d11f0548bd053dfbf92f9e9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d">rt_task_reply</a> (int flowid, RT_TASK_MCB *mcb_s)</td></tr>
<tr class="memdesc:gacd8a4fb2d11f0548bd053dfbf92f9e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reply to a remote task message.  <a href="#gacd8a4fb2d11f0548bd053dfbf92f9e9d">More...</a><br /></td></tr>
<tr class="separator:gacd8a4fb2d11f0548bd053dfbf92f9e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6bd973c22a6f66e28653922c53e0385"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#gab6bd973c22a6f66e28653922c53e0385">rt_task_bind</a> (RT_TASK *task, const char *name, RTIME timeout)</td></tr>
<tr class="memdesc:gab6bd973c22a6f66e28653922c53e0385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to a task.  <a href="#gab6bd973c22a6f66e28653922c53e0385">More...</a><br /></td></tr>
<tr class="separator:gab6bd973c22a6f66e28653922c53e0385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2038cbe2350a8e2558330a3f45953865"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga2038cbe2350a8e2558330a3f45953865">rt_task_unbind</a> (RT_TASK *task)</td></tr>
<tr class="memdesc:ga2038cbe2350a8e2558330a3f45953865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind from a task.  <a href="#ga2038cbe2350a8e2558330a3f45953865">More...</a><br /></td></tr>
<tr class="separator:ga2038cbe2350a8e2558330a3f45953865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03387550693c21d0223f739570ccd992"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992">rt_task_create</a> (RT_TASK *task, const char *name, int stksize, int prio, int mode)</td></tr>
<tr class="memdesc:ga03387550693c21d0223f739570ccd992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a real-time task.  <a href="#ga03387550693c21d0223f739570ccd992">More...</a><br /></td></tr>
<tr class="separator:ga03387550693c21d0223f739570ccd992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gababee94264156693cd4f5b9b70d3c5a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#gababee94264156693cd4f5b9b70d3c5a1">rt_task_set_periodic</a> (RT_TASK *task, RTIME idate, RTIME period)</td></tr>
<tr class="memdesc:gababee94264156693cd4f5b9b70d3c5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a real-time task periodic.  <a href="#gababee94264156693cd4f5b9b70d3c5a1">More...</a><br /></td></tr>
<tr class="separator:gababee94264156693cd4f5b9b70d3c5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f9fa3cb09d7f774ebff7585994dffb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__alchemy__task.html#gaa4f9fa3cb09d7f774ebff7585994dffb">rt_task_spawn</a> (RT_TASK *task, const char *name, int stksize, int prio, int mode, void(*entry)(void *arg), void *arg)</td></tr>
<tr class="memdesc:gaa4f9fa3cb09d7f774ebff7585994dffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and start a real-time task.  <a href="#gaa4f9fa3cb09d7f774ebff7585994dffb">More...</a><br /></td></tr>
<tr class="separator:gaa4f9fa3cb09d7f774ebff7585994dffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Services dealing with preemptive multi-tasking. </p>
<p>Each Alchemy task is an independent portion of the overall application code embodied in a C procedure, which executes on its own stack context. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga2ac6cf9677bae1012ecbcb6037d14fcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T_LOCK&#160;&#160;&#160;__THREAD_M_LOCK</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task mode bits. </p>

<p>Referenced by <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992">rt_task_create()</a>, <a class="el" href="group__alchemy__task.html#ga915e7edfb0aaddb643794d7abc7093bf">rt_task_set_mode()</a>, and <a class="el" href="group__alchemy__task.html#ga72e0a9355d06c346a95bf88b857a9749">rt_task_shadow()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4b84dc0d444a96e1e417d480e803d32e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T_LOPRIO&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task priorities. </p>

</div>
</div>
<a class="anchor" id="ga725324cb26d8b5835c0818acb738bfe6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define T_WARNSW&#160;&#160;&#160;__THREAD_M_WARNSW</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cobalt only, nop over Mercury. </p>

<p>Referenced by <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992">rt_task_create()</a>, <a class="el" href="group__alchemy__task.html#ga915e7edfb0aaddb643794d7abc7093bf">rt_task_set_mode()</a>, and <a class="el" href="group__alchemy__task.html#ga72e0a9355d06c346a95bf88b857a9749">rt_task_shadow()</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gab6bd973c22a6f66e28653922c53e0385"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_bind </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind to a task. </p>
<p>This routine creates a new descriptor to refer to an existing Alchemy task identified by its symbolic name. If the object does not exist on entry, the caller may block until a task of the given name is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The address of a task descriptor filled in by the operation. Contents of this memory is undefined upon failure.</td></tr>
    <tr><td class="paramname">name</td><td>A valid NULL-terminated name which identifies the task to bind to. This string should match the object name argument passed to <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992" title="Create a real-time task. ">rt_task_create()</a>, or <a class="el" href="group__alchemy__task.html#ga72e0a9355d06c346a95bf88b857a9749" title="Turn caller into a real-time task. ">rt_task_shadow()</a>.</td></tr>
    <tr><td class="paramname">timeout</td><td>The number of clock ticks to wait for the registration to occur (see note). Passing TM_INFINITE causes the caller to block indefinitely until the object is registered. Passing TM_NONBLOCK causes the service to return immediately without waiting if the object is not registered on entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before the retrieval has completed.</li>
<li>-EWOULDBLOCK is returned if <em>timeout</em> is equal to TM_NONBLOCK and the searched object is not registered on entry.</li>
<li>-ETIMEDOUT is returned if the object cannot be retrieved within the specified amount of time.</li>
<li>-EPERM is returned if this service should block, but was not called from a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-nowait, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>timeout</em> value is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

</div>
</div>
<a class="anchor" id="ga03387550693c21d0223f739570ccd992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_create </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a real-time task. </p>
<p>This service creates a task with access to the full set of Xenomai real-time services. If <em>prio</em> is non-zero, the new task belongs to Xenomai's real-time FIFO scheduling class, aka SCHED_FIFO. If <em>prio</em> is zero, the task belongs to the regular SCHED_OTHER class.</p>
<p>Creating tasks with zero priority is useful for running non real-time processes which may invoke blocking real-time services, such as pending on a semaphore, reading from a message queue or a buffer, and so on.</p>
<p>Once created, the task is left dormant until it is actually started by <a class="el" href="group__alchemy__task.html#ga3ee3863a29497e2181d49d5b3ecfd855" title="Start a real-time task. ">rt_task_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The address of a task descriptor which can be later used to identify uniquely the created object, upon success of this call.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the task. When non-NULL and non-empty, a copy of this string is used for indexing the created task into the object registry.</td></tr>
    <tr><td class="paramname">stksize</td><td>The size of the stack (in bytes) for the new task. If zero is passed, a system-dependent default size will be substituted.</td></tr>
    <tr><td class="paramname">prio</td><td>The base priority of the new task. This value must be in the [0 .. 99] range, where 0 is the lowest effective priority.</td></tr>
    <tr><td class="paramname">mode</td><td>The task creation mode. The following flags can be OR'ed into this bitmask:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>T_JOINABLE allows another task to wait on the termination of the new task. <a class="el" href="group__alchemy__task.html#ga8c77d57638578a126812e29429f61fe7" title="Wait on the termination of a real-time task. ">rt_task_join()</a> shall be called for this task to clean up any resources after its termination.</li>
<li>T_LOCK causes the new task to lock the scheduler prior to entering the user routine specified by <a class="el" href="group__alchemy__task.html#ga3ee3863a29497e2181d49d5b3ecfd855" title="Start a real-time task. ">rt_task_start()</a>. A call to <a class="el" href="group__alchemy__task.html#ga915e7edfb0aaddb643794d7abc7093bf" title="Change the current task mode. ">rt_task_set_mode()</a> from the new task is required to drop this lock.</li>
<li>When running over the Cobalt core, T_WARNSW causes the SIGDEBUG signal to be sent to the current task whenever it switches to the secondary mode. This feature is useful to detect unwanted migrations to the Linux domain. This flag has no effect over the Mercury core.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if either <em>prio</em>, <em>mode</em> or <em>stksize</em> are invalid.</li>
<li>-ENOMEM is returned if the system fails to get memory from the main heap in order to create the task.</li>
<li>-EEXIST is returned if the <em>name</em> is conflicting with an already registered task.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a></dd></dl>
<dl class="section user"><dt>Side effects</dt><dd><ul>
<li>When running over the Cobalt core:<ul>
<li>calling <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992" title="Create a real-time task. ">rt_task_create()</a> causes SCHED_FIFO tasks to switch to secondary mode.</li>
<li>members of Xenomai's SCHED_FIFO class running in the primary domain have utmost priority over all Linux activities in the system, including Linux interrupt handlers.</li>
</ul>
</li>
<li>When running over the Mercury core, the new task belongs to the regular POSIX SCHED_FIFO class.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Tasks can be referred to from multiple processes which all belong to the same Xenomai session. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cross-link_8c-example.html#a12">cross-link.c</a>.</dd>
</dl>
<p>References <a class="el" href="group__alchemy__task.html#ga2ac6cf9677bae1012ecbcb6037d14fcb">T_LOCK</a>, and <a class="el" href="group__alchemy__task.html#ga725324cb26d8b5835c0818acb738bfe6">T_WARNSW</a>.</p>

<p>Referenced by <a class="el" href="group__alchemy__task.html#gaa4f9fa3cb09d7f774ebff7585994dffb">rt_task_spawn()</a>.</p>

</div>
</div>
<a class="anchor" id="gab6e0d411830710e8cc82d77b9df19510"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_delete </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a real-time task. </p>
<p>This call terminates a task previously created by <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992" title="Create a real-time task. ">rt_task_create()</a>.</p>
<p>Tasks created with the T_JOINABLE flag shall be joined by a subsequent call to <a class="el" href="group__alchemy__task.html#ga8c77d57638578a126812e29429f61fe7" title="Wait on the termination of a real-time task. ">rt_task_join()</a> once successfully deleted, to reclaim all resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a valid task descriptor.</li>
<li>-EPERM is returned if <em>task</em> is NULL and this service was called from an invalid context. In addition, this error is always raised when this service is called from asynchronous context, such as a timer/alarm handler.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must be an Alchemy task if <em>task</em> is NULL. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cross-link_8c-example.html#a4">cross-link.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga53bad6acf5496f8008e594954507dce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_inquire </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRT__TASK__INFO.html">RT_TASK_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve information about a real-time task. </p>
<p>Return various information about an Alchemy task. This service may also be used to probe for task existence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor. If <em>task</em> is NULL, the information about the current task is returned.</td></tr>
    <tr><td class="paramname">info</td><td>The address of a structure the task information will be written to. Passing NULL is valid, in which case the system is only probed for existence of the specified task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned if the task exists. In addition, if <em>info</em> is non-NULL, it is filled in with task information.</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a valid task descriptor, or if <em>prio</em> is invalid.</li>
<li>-EPERM is returned if <em>task</em> is NULL and this service was called from an invalid context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must be an Alchemy task if <em>task</em> is NULL. </dd></dl>

<p>References <a class="el" href="structRT__TASK__INFO.html#a3e5d47277ecea23aa3a5730e0b6b2d13">RT_TASK_INFO::name</a>, <a class="el" href="structRT__TASK__INFO.html#a70c731ca5877ff4a6235fa81caa77798">RT_TASK_INFO::pid</a>, <a class="el" href="structRT__TASK__INFO.html#a632e09c1d8dabc29c020c828abf62ac6">RT_TASK_INFO::prio</a>, and <a class="el" href="structRT__TASK__INFO.html#ae327f3dca3f2ae89c8aa5bd0033ed4b0">RT_TASK_INFO::stat</a>.</p>

</div>
</div>
<a class="anchor" id="ga8c77d57638578a126812e29429f61fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_join </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait on the termination of a real-time task. </p>
<p>This service blocks the caller in non-real-time context until <em>task</em> has terminated. All resources are released after successful completion of this service.</p>
<p>The specified task must have been created by the same process that wants to join it, and the T_JOINABLE mode flag must have been set on creation to <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992" title="Create a real-time task. ">rt_task_create()</a>.</p>
<p>Tasks created with the T_JOINABLE flag shall be joined by a subsequent call to <a class="el" href="group__alchemy__task.html#ga8c77d57638578a126812e29429f61fe7" title="Wait on the termination of a real-time task. ">rt_task_join()</a> once successfully deleted, to reclaim all resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a valid task descriptor.</li>
<li>-EINVAL is returned if the task was not created with T_JOINABLE set or some other task is already waiting on the termination.</li>
<li>-EDEADLK is returned if <em>task</em> refers to the caller.</li>
<li>-ESRCH is returned if <em>task</em> no longer exists or refers to task created by a different process.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>After successful completion of this service, it is neither required nor valid to additionally invoke <a class="el" href="group__alchemy__task.html#gab6e0d411830710e8cc82d77b9df19510" title="Delete a real-time task. ">rt_task_delete()</a> on the same task. </dd></dl>

<p>References <a class="el" href="group__cobalt__api__thread.html#ga28a15bba47cab57cbc9f5dac9af99c8b">pthread_join()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8fd88694130824cdf1abf7a4f119e742"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_task_receive </td>
          <td>(</td>
          <td class="paramtype">RT_TASK_MCB *&#160;</td>
          <td class="paramname"><em>mcb_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a message from a real-time task (with relative scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__task.html#gaf2ad79df07c5589d5c646ea836b6a777" title="Receive a message from a real-time task. ">rt_task_receive_timed()</a> accepting a relative timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mcb_r</td><td>The address of a message control block referring to the receive message area.</td></tr>
    <tr><td class="paramname">timeout</td><td>A delay expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__task.html#gaf2ad79df07c5589d5c646ea836b6a777">rt_task_receive_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf2ad79df07c5589d5c646ea836b6a777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_receive_timed </td>
          <td>(</td>
          <td class="paramtype">RT_TASK_MCB *&#160;</td>
          <td class="paramname"><em>mcb_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a message from a real-time task. </p>
<p>This service is part of the synchronous message passing support available to Alchemy tasks. The caller receives a variable-sized message from another task. The sender is blocked until the caller invokes <a class="el" href="group__alchemy__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d" title="Reply to a remote task message. ">rt_task_reply()</a> to finish the transaction.</p>
<p>A basic message control block is used to store the location and size of the data area to receive from the client, in addition to a user-defined operation code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mcb_r</td><td>The address of a message control block referring to the receive message area. The fields from this control block should be set as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>mcb_r-&gt;data should contain the address of a buffer large enough to collect the data sent by the remote task;</li>
<li>mcb_r-&gt;size should contain the size in bytes of the buffer space pointed at by mcb_r-&gt;data. If mcb_r-&gt;size is lower than the actual size of the received message, no data copy takes place and -ENOBUFS is returned to the caller. See note.</li>
</ul>
<p>Upon return, mcb_r-&gt;opcode will contain the operation code sent from the remote task using <a class="el" href="group__alchemy__task.html#ga99a89c21c9866e2784860e100a444b49" title="Send a message to a real-time task (with relative scalar timeout). ">rt_task_send()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abs_timeout</td><td>The number of clock ticks to wait for receiving a message (see note). Passing NULL causes the caller to block indefinitely until a remote task eventually sends a message. Passing { .tv_sec = 0, .tv_nsec = 0 } causes the service to return immediately without waiting if no remote task is currently waiting for sending a message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A strictly positive value is returned upon success, representing a flow identifier for the opening transaction; this token should be passed to <a class="el" href="group__alchemy__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d" title="Reply to a remote task message. ">rt_task_reply()</a>, in order to send back a reply to and unblock the remote task appropriately. Otherwise:</dd></dl>
<ul>
<li>-EPERM is returned if this service was called from an invalid context.</li>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before a message was received.</li>
<li>-ENOBUFS is returned if <em>mcb_r</em> does not point at a message area large enough to collect the remote task's message.</li>
<li>-EWOULDBLOCK is returned if <em>abs_timeout</em> is { .tv_sec = 0, .tv_nsec = 0 } and no remote task is currently waiting for sending a message to the caller.</li>
<li>-ETIMEDOUT is returned if no message was received within the <em>timeout</em>.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>abs_timeout</em> is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

<p>Referenced by <a class="el" href="group__alchemy__task.html#ga8fd88694130824cdf1abf7a4f119e742">rt_task_receive()</a>, and <a class="el" href="group__alchemy__task.html#gaa51bdd7ba60692deca7bedbb99d76ae1">rt_task_receive_until()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa51bdd7ba60692deca7bedbb99d76ae1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_task_receive_until </td>
          <td>(</td>
          <td class="paramtype">RT_TASK_MCB *&#160;</td>
          <td class="paramname"><em>mcb_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive a message from a real-time task (with absolute scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__task.html#gaf2ad79df07c5589d5c646ea836b6a777" title="Receive a message from a real-time task. ">rt_task_receive_timed()</a> accepting an absolute timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mcb_r</td><td>The address of a message control block referring to the receive message area.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__task.html#gaf2ad79df07c5589d5c646ea836b6a777">rt_task_receive_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="gacd8a4fb2d11f0548bd053dfbf92f9e9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_reply </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flowid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_TASK_MCB *&#160;</td>
          <td class="paramname"><em>mcb_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reply to a remote task message. </p>
<p>This service is part of the synchronous message passing support available to Alchemy tasks. The caller sends a variable-sized message back to a remote task, in response to this task's initial message received by a call to <a class="el" href="group__alchemy__task.html#ga8fd88694130824cdf1abf7a4f119e742" title="Receive a message from a real-time task (with relative scalar timeout). ">rt_task_receive()</a>. As a consequence of calling <a class="el" href="group__alchemy__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d" title="Reply to a remote task message. ">rt_task_reply()</a>, the remote task will be unblocked from the <a class="el" href="group__alchemy__task.html#ga99a89c21c9866e2784860e100a444b49" title="Send a message to a real-time task (with relative scalar timeout). ">rt_task_send()</a> service.</p>
<p>A basic message control block is used to store the location and size of the data area to send back, in addition to a user-defined status code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flowid</td><td>The flow identifier returned by a previous call to <a class="el" href="group__alchemy__task.html#ga8fd88694130824cdf1abf7a4f119e742" title="Receive a message from a real-time task (with relative scalar timeout). ">rt_task_receive()</a> which uniquely identifies the current transaction.</td></tr>
    <tr><td class="paramname">mcb_s</td><td>The address of an optional message control block referring to the message to be sent back. If <em>mcb_s</em> is NULL, the remote will be unblocked without getting any reply data. When <em>mcb_s</em> is valid, the fields from this control block should be set as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>mcb_s-&gt;data should contain the address of the payload data to send to the remote task.</li>
<li>mcb_s-&gt;size should contain the size in bytes of the payload data pointed at by mcb_s-&gt;data. Zero is a legitimate value, and indicates that no payload data will be transferred. In the latter case, mcb_s-&gt;data will be ignored.</li>
<li>mcb_s-&gt;opcode is an opaque status code carried during the message transfer the caller can fill with any appropriate value. It will be made available "as is" to the remote task into the status code field by the <a class="el" href="group__alchemy__task.html#ga99a89c21c9866e2784860e100a444b49" title="Send a message to a real-time task (with relative scalar timeout). ">rt_task_send()</a> service. If <em>mcb_s</em> is NULL, Zero will be returned to the remote task into the status code field.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>flowid</em> is invalid.</li>
<li>-ENXIO is returned if <em>flowid</em> does not match the expected identifier returned from the latest call of the current task to <a class="el" href="group__alchemy__task.html#ga8fd88694130824cdf1abf7a4f119e742" title="Receive a message from a real-time task (with relative scalar timeout). ">rt_task_receive()</a>, or if the remote task stopped waiting for the reply in the meantime (e.g. the remote could have been deleted or forcibly unblocked).</li>
<li>-ENOBUFS is returned if the reply data referred to by <em>mcb_s</em> is larger than the reply area mentioned by the remote task when calling <a class="el" href="group__alchemy__task.html#ga99a89c21c9866e2784860e100a444b49" title="Send a message to a real-time task (with relative scalar timeout). ">rt_task_send()</a>. In such a case, the remote task also receives -ENOBUFS on return from <a class="el" href="group__alchemy__task.html#ga99a89c21c9866e2784860e100a444b49" title="Send a message to a real-time task (with relative scalar timeout). ">rt_task_send()</a>.</li>
<li>-EPERM is returned if this service was called from an invalid context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1fab1aa24ef6f199546fd9669ae711be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_resume </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a real-time task. </p>
<p>Forcibly resume the execution of a task which was previously suspended by a call to <a class="el" href="group__alchemy__task.html#ga926a4b10e3631f76c5f38910e6eea24c" title="Suspend a real-time task. ">rt_task_suspend()</a>, if the suspend nesting count decrements to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a valid task descriptor.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Blocked and suspended task states are cumulative. Therefore, resuming a task currently waiting on a synchronization object (e.g. semaphore, queue) does not make it eligible for scheduling until the awaited resource is eventually acquired, or a timeout elapses. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6e313941a3fea606be8d0f66380e922"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_same </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare real-time task descriptors. </p>
<p>This predicate returns true if <em>task1</em> and <em>task2</em> refer to the same task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task1</td><td>First task descriptor to compare.</td></tr>
    <tr><td class="paramname">task2</td><td>Second task descriptor to compare.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-zero value is returned if both descriptors refer to the same task, zero otherwise.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga8a17935f049171be2ac8945abc68da6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RT_TASK * rt_task_self </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current task descriptor. </p>
<p>Return the address of the current Alchemy task descriptor.</p>
<dl class="section return"><dt>Returns</dt><dd>The address of the task descriptor referring to the current Alchemy task is returned upon success, or NULL if not called from a valid Alchemy task context.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga99a89c21c9866e2784860e100a444b49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_task_send </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_TASK_MCB *&#160;</td>
          <td class="paramname"><em>mcb_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_TASK_MCB *&#160;</td>
          <td class="paramname"><em>mcb_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message to a real-time task (with relative scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__task.html#ga10e40ae8b8ab82c1fddc26fed12d4ec2" title="Send a message to a real-time task. ">rt_task_send_timed()</a> accepting a relative timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor.</td></tr>
    <tr><td class="paramname">mcb_s</td><td>The address of the message control block referring to the message to be sent.</td></tr>
    <tr><td class="paramname">mcb_r</td><td>The address of an optional message control block referring to the reply message area.</td></tr>
    <tr><td class="paramname">timeout</td><td>A delay expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__task.html#ga10e40ae8b8ab82c1fddc26fed12d4ec2">rt_task_send_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga10e40ae8b8ab82c1fddc26fed12d4ec2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_task_send_timed </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_TASK_MCB *&#160;</td>
          <td class="paramname"><em>mcb_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_TASK_MCB *&#160;</td>
          <td class="paramname"><em>mcb_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec *&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to a real-time task. </p>
<p>This service is part of the synchronous message passing support available to Alchemy tasks. The caller sends a variable-sized message to another task, waiting for the remote to receive the initial message by a call to <a class="el" href="group__alchemy__task.html#ga8fd88694130824cdf1abf7a4f119e742" title="Receive a message from a real-time task (with relative scalar timeout). ">rt_task_receive()</a>, then reply to it using <a class="el" href="group__alchemy__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d" title="Reply to a remote task message. ">rt_task_reply()</a>.</p>
<p>A basic message control block is used to store the location and size of the data area to send or retrieve upon reply, in addition to a user-defined operation code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor.</td></tr>
    <tr><td class="paramname">mcb_s</td><td>The address of the message control block referring to the message to be sent. The fields from this control block should be set as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>mcb_s-&gt;data should contain the address of the payload data to send to the remote task.</li>
<li>mcb_s-&gt;size should contain the size in bytes of the payload data pointed at by mcb_s-&gt;data. Zero is a legitimate value, and indicates that no payload data will be transferred. In the latter case, mcb_s-&gt;data will be ignored.</li>
<li>mcb_s-&gt;opcode is an opaque operation code carried during the message transfer, the caller can fill with any appropriate value. It will be made available "as is" to the remote task into the operation code field by the <a class="el" href="group__alchemy__task.html#ga8fd88694130824cdf1abf7a4f119e742" title="Receive a message from a real-time task (with relative scalar timeout). ">rt_task_receive()</a> service.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mcb_r</td><td>The address of an optional message control block referring to the reply message area. If <em>mcb_r</em> is NULL and a reply is sent back by the remote task, the reply message will be discarded, and -ENOBUFS will be returned to the caller. When <em>mcb_r</em> is valid, the fields from this control block should be set as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>mcb_r-&gt;data should contain the address of a buffer large enough to collect the reply data from the remote task.</li>
<li>mcb_r-&gt;size should contain the size in bytes of the buffer space pointed at by mcb_r-&gt;data. If mcb_r-&gt;size is lower than the actual size of the reply message, no data copy takes place and -ENOBUFS is returned to the caller.</li>
</ul>
<p>Upon return, mcb_r-&gt;opcode will contain the status code sent back from the remote task using <a class="el" href="group__alchemy__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d" title="Reply to a remote task message. ">rt_task_reply()</a>, or zero if unspecified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks, specifying a time limit to wait for the recipient task to reply to the initial message (see note). Passing NULL causes the caller to block indefinitely until a reply is received. Passing { .tv_sec = 0, .tv_nsec = 0 } causes the service to return without blocking in case the recipient task is not waiting for messages at the time of the call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive value is returned upon success, representing the length (in bytes) of the reply message returned by the remote task. Zero is a success status, meaning either that <em>mcb_r</em> was NULL on entry, or that no actual message was passed to the remote call to <a class="el" href="group__alchemy__task.html#gacd8a4fb2d11f0548bd053dfbf92f9e9d" title="Reply to a remote task message. ">rt_task_reply()</a>. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a valid task descriptor.</li>
<li>-EPERM is returned if this service was called from an invalid context.</li>
<li>-ENOBUFS is returned if <em>mcb_r</em> does not point at a message area large enough to collect the remote task's reply. This includes the case where <em>mcb_r</em> is NULL on entry, despite the remote task attempts to send a reply message.</li>
<li>-EWOULDBLOCK is returned if <em>abs_timeout</em> is { .tv_sec = 0, .tv_nsec = 0 } and the recipient <em>task</em> is not currently waiting for a message on the <a class="el" href="group__alchemy__task.html#ga8fd88694130824cdf1abf7a4f119e742" title="Receive a message from a real-time task (with relative scalar timeout). ">rt_task_receive()</a> service.</li>
<li>-EIDRM is returned if <em>task</em> has been deleted while waiting for a reply.</li>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task before any reply was received from the recipient <em>task</em>.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd><em>abs_timeout</em> is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

<p>Referenced by <a class="el" href="group__alchemy__task.html#ga99a89c21c9866e2784860e100a444b49">rt_task_send()</a>, and <a class="el" href="group__alchemy__task.html#ga74378805e49a613863a048bfaa70e9df">rt_task_send_until()</a>.</p>

</div>
</div>
<a class="anchor" id="ga74378805e49a613863a048bfaa70e9df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rt_task_send_until </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_TASK_MCB *&#160;</td>
          <td class="paramname"><em>mcb_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RT_TASK_MCB *&#160;</td>
          <td class="paramname"><em>mcb_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>abs_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a message to a real-time task (with absolute scalar timeout). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__task.html#ga10e40ae8b8ab82c1fddc26fed12d4ec2" title="Send a message to a real-time task. ">rt_task_send_timed()</a> accepting an absolute timeout specification expressed as a scalar value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor.</td></tr>
    <tr><td class="paramname">mcb_s</td><td>The address of the message control block referring to the message to be sent.</td></tr>
    <tr><td class="paramname">mcb_r</td><td>The address of an optional message control block referring to the reply message area.</td></tr>
    <tr><td class="paramname">abs_timeout</td><td>An absolute date expressed in clock ticks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a> </dd></dl>

<p>References <a class="el" href="group__alchemy__task.html#ga10e40ae8b8ab82c1fddc26fed12d4ec2">rt_task_send_timed()</a>.</p>

</div>
</div>
<a class="anchor" id="gad92ea8c9fed3c5a3789538c9c8362c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_set_affinity </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cpu_set_t *&#160;</td>
          <td class="paramname"><em>cpus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set CPU affinity of real-time task. </p>
<p>This calls makes <em>task</em> affine to the set of CPUs defined by <em>cpus</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor. If <em>task</em> is NULL, the CPU affinity of the current task is changed.</td></tr>
    <tr><td class="paramname">cpus</td><td>The set of CPUs <em>task</em> should be affine to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is NULL but the caller is not a Xenomai task, or if <em>task</em> is non-NULL but not a valid task descriptor.</li>
<li>-EINVAL is returned if <em>cpus</em> contains no processors that are currently physically on the system and permitted to the process according to any restrictions that may be imposed by the "cpuset" mechanism described in cpuset(7).</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must be an Alchemy task if <em>task</em> is NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga915e7edfb0aaddb643794d7abc7093bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_set_mode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>setmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>mode_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the current task mode. </p>
<p>Each Alchemy task has a set of internal flags determining several operating conditions. <a class="el" href="group__alchemy__task.html#ga915e7edfb0aaddb643794d7abc7093bf" title="Change the current task mode. ">rt_task_set_mode()</a> takes a bitmask of mode bits to clear for disabling the corresponding modes for the current task, and another one to set for enabling them. The mode bits which were previously in effect before the change can be returned upon request.</p>
<p>The following bits can be part of the bitmask:</p>
<ul>
<li>T_LOCK causes the current task to lock the scheduler on the current CPU, preventing all further involuntary task switches on this CPU. Clearing this bit unlocks the scheduler.</li>
<li>Only when running over the Cobalt core:<ul>
<li>T_WARNSW causes the SIGDEBUG signal to be sent to the current task whenever it switches to the secondary mode. This feature is useful to detect unwanted migrations to the Linux domain.</li>
<li>T_CONFORMING can be passed in <em>setmask</em> to switch the current Alchemy task to its preferred runtime mode. The only meaningful use of this switch is to force a real-time task back to primary mode (see note). Any other use leads to a nop.</li>
</ul>
</li>
</ul>
<p>These two last flags have no effect over the Mercury core, and are simply ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clrmask</td><td>A bitmask of mode bits to clear for the current task, before <em>setmask</em> is applied. Zero is an acceptable value which leads to a no-op.</td></tr>
    <tr><td class="paramname">setmask</td><td>A bitmask of mode bits to set for the current task. Zero is an acceptable value which leads to a no-op.</td></tr>
    <tr><td class="paramname">mode_r</td><td>If non-NULL, <em>mode_r</em> must be a pointer to a memory location which will be written upon success with the previous set of active mode bits. If NULL, the previous set of active mode bits will not be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a valid task descriptor, or if any bit from <em>clrmask</em> or <em>setmask</em> is invalid.</li>
<li>-EPERM is returned if this service was called from an invalid context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must be an Alchemy task.</dd>
<dd>
Forcing the task mode using the T_CONFORMING bit from user code is almost always wrong, since the Xenomai/cobalt core handles mode switches internally when/if required. Most often, manual mode switching from applications introduces useless overhead. This mode bit is part of the API only to cover rare use cases in middleware code based on the Alchemy interface. </dd></dl>

<p>References <a class="el" href="group__alchemy__task.html#ga2ac6cf9677bae1012ecbcb6037d14fcb">T_LOCK</a>, and <a class="el" href="group__alchemy__task.html#ga725324cb26d8b5835c0818acb738bfe6">T_WARNSW</a>.</p>

</div>
</div>
<a class="anchor" id="gababee94264156693cd4f5b9b70d3c5a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_set_periodic </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>idate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a real-time task periodic. </p>
<p>Make a task periodic by programing its first release point and its period in the processor time line. <em>task</em> should then call <a class="el" href="group__alchemy__task.html#ga1645d3a072ef3cefeed3bcbb27dcf108" title="Wait for the next periodic release point. ">rt_task_wait_period()</a> to sleep until the next periodic release point in the processor timeline is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor. If <em>task</em> is NULL, the current task is made periodic. <em>task</em> must belong the current process.</td></tr>
    <tr><td class="paramname">idate</td><td>The initial (absolute) date of the first release point, expressed in clock ticks (see note). If <em>idate</em> is equal to TM_NOW, the current system date is used.</td></tr>
    <tr><td class="paramname">period</td><td>The period of the task, expressed in clock ticks (see note). Passing TM_INFINITE stops the task's periodic timer if enabled, then returns successfully.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is NULL but the caller is not a Xenomai task, or if <em>task</em> is non-NULL but not a valid task descriptor.</li>
<li>-ETIMEDOUT is returned if <em>idate</em> is different from TM_INFINITE and represents a date in the past.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must be an Alchemy task if <em>task</em> is NULL.</dd>
<dd>
Over Cobalt, -EINVAL is returned if <em>period</em> is different from TM_INFINITE but shorter than the user scheduling latency value for the target system, as displayed by /proc/xenomai/latency.</dd>
<dd>
The <em>idate</em> and <em>period</em> values are interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond).</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Unlike its Xenomai 2.x counterpart, <a class="el" href="group__alchemy__task.html#gababee94264156693cd4f5b9b70d3c5a1" title="Make a real-time task periodic. ">rt_task_set_periodic()</a> will <b>NOT</b> block <em>task</em> until <em>idate</em> is reached. The first beat in the periodic timeline should be awaited for by a call to <a class="el" href="group__alchemy__task.html#ga1645d3a072ef3cefeed3bcbb27dcf108" title="Wait for the next periodic release point. ">rt_task_wait_period()</a>. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cross-link_8c-example.html#a5">cross-link.c</a>.</dd>
</dl>
<p>References <a class="el" href="group__cobalt__api__time.html#ga10b73e75d375e5c244e32ea46be775bf">clock_gettime()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3bed8d001e212a3328a4e7e73f1765e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_set_priority </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the base priority of a real-time task. </p>
<p>The base priority of a task defines the relative importance of the work being done by each task, which gains conrol of the CPU accordingly.</p>
<p>Changing the base priority of a task does not affect the priority boost the target task might have obtained as a consequence of a priority inheritance undergoing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor. If <em>task</em> is NULL, the priority of the current task is changed.</td></tr>
    <tr><td class="paramname">prio</td><td>The new priority. This value must range from [T_LOPRIO .. T_HIPRIO] (inclusive) where T_LOPRIO is the lowest effective priority.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a valid task descriptor, or if <em>prio</em> is invalid.</li>
<li>-EPERM is returned if <em>task</em> is NULL and this service was called from an invalid context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must be an Alchemy task if <em>task</em> is NULL.</dd>
<dd>
Assigning the same priority to a running or ready task moves it to the end of its priority group, thus causing a manual round-robin. </dd></dl>

</div>
</div>
<a class="anchor" id="ga72e0a9355d06c346a95bf88b857a9749"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_shadow </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn caller into a real-time task. </p>
<p>Extends the calling Linux task with Xenomai capabilities, with access to the full set of Xenomai real-time services. This service is typically used for turning the main() thread of an application process into a Xenomai-enabled task.</p>
<p>If <em>prio</em> is non-zero, the new task moves to Xenomai's real-time FIFO scheduling class, aka SCHED_FIFO. If <em>prio</em> is zero, the task moves to the regular SCHED_OTHER class.</p>
<p>Running Xenomai tasks with zero priority is useful for running non real-time processes which may invoke blocking real-time services, such as pending on a semaphore, reading from a message queue or a buffer, and so on.</p>
<p>Once shadowed with the Xenomai extension, the calling task returns and resumes execution normally from the call site.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>If non-NULL, the address of a task descriptor which can be later used to identify uniquely the task, upon success of this call. If NULL, no descriptor is returned.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the task. When non-NULL and non-empty, a copy of this string is used for indexing the task into the object registry.</td></tr>
    <tr><td class="paramname">prio</td><td>The base priority of the task. This value must be in the [0 .. 99] range, where 0 is the lowest effective priority.</td></tr>
    <tr><td class="paramname">mode</td><td>The task shadowing mode. The following flags can be OR'ed into this bitmask:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>T_LOCK causes the current task to lock the scheduler before returning to the caller, preventing all further involuntary task switches on the current CPU. A call to <a class="el" href="group__alchemy__task.html#ga915e7edfb0aaddb643794d7abc7093bf" title="Change the current task mode. ">rt_task_set_mode()</a> from the current task is required to drop this lock.</li>
<li>When running over the Cobalt core, T_WARNSW causes the SIGDEBUG signal to be sent to the current task whenever it switches to the secondary mode. This feature is useful to detect unwanted migrations to the Linux domain. This flag has no effect over the Mercury core.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>prio</em> is invalid.</li>
<li>-ENOMEM is returned if the system fails to get memory from the main heap in order to create the task extension.</li>
<li>-EEXIST is returned if the <em>name</em> is conflicting with an already registered task.</li>
<li>-EBUSY is returned if the caller is already mapped to a Xenomai task context.</li>
<li>-EPERM is returned if this service was called from an invalid context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">pthread-only, switch-secondary</a></dd></dl>
<dl class="section user"><dt>Side effects</dt><dd>Over the Cobalt core, the caller always returns from this service in primary mode.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Tasks can be referred to from multiple processes which all belong to the same Xenomai session. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="rtcanrecv_8c-example.html#a26">rtcanrecv.c</a>, and <a class="el" href="rtcansend_8c-example.html#a17">rtcansend.c</a>.</dd>
</dl>
<p>References <a class="el" href="group__alchemy__task.html#ga2ac6cf9677bae1012ecbcb6037d14fcb">T_LOCK</a>, and <a class="el" href="group__alchemy__task.html#ga725324cb26d8b5835c0818acb738bfe6">T_WARNSW</a>.</p>

</div>
</div>
<a class="anchor" id="gad5225e5fb8d583fbdfa5299f322b8366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_sleep </td>
          <td>(</td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay the current real-time task (with relative delay). </p>
<p>This routine is a variant of <a class="el" href="group__alchemy__task.html#ga0dc2deebe7500c9d21ff05d51d5efaa8" title="Delay the current real-time task (with absolute wakeup date). ">rt_task_sleep_until()</a> accepting a relative timeout specification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay</td><td>A relative delay expressed in clock ticks (see note). A zero delay causes this service to return immediately to the caller with a success status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group__alchemy__task.html#ga0dc2deebe7500c9d21ff05d51d5efaa8" title="Delay the current real-time task (with absolute wakeup date). ">rt_task_sleep_until()</a>.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <em>delay</em> value is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cross-link_8c-example.html#a3">cross-link.c</a>, and <a class="el" href="rtcansend_8c-example.html#a2">rtcansend.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga0dc2deebe7500c9d21ff05d51d5efaa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_sleep_until </td>
          <td>(</td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>date</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay the current real-time task (with absolute wakeup date). </p>
<p>Delay the execution of the calling task until a given date is reached. The caller is put to sleep, and does not consume any CPU time in such a state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date</td><td>An absolute date expressed in clock ticks, specifying a wakeup date (see note). As a special case, TM_INFINITE is an acceptable value that causes the caller to block indefinitely, until <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> is called against it. Otherwise, any wake up date in the past causes the task to return immediately.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the current task.</li>
<li>-ETIMEDOUT is returned if <em>date</em> has already elapsed.</li>
<li>-EPERM is returned if this service was called from an invalid context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must be an Alchemy task if <em>task</em> is NULL.</dd>
<dd>
The <em>date</em> value is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

</div>
</div>
<a class="anchor" id="ga9250436d7bd9e49a0320161d2e9373ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_slice </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RTIME&#160;</td>
          <td class="paramname"><em>quantum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a task's round-robin quantum. </p>
<p>Set the time credit allotted to a task undergoing the round-robin scheduling. If <em>quantum</em> is non-zero, <a class="el" href="group__alchemy__task.html#ga9250436d7bd9e49a0320161d2e9373ae" title="Set a task&#39;s round-robin quantum. ">rt_task_slice()</a> also refills the current quantum for the target task, otherwise, time-slicing is stopped for that task.</p>
<p>In other words, <a class="el" href="group__alchemy__task.html#ga9250436d7bd9e49a0320161d2e9373ae" title="Set a task&#39;s round-robin quantum. ">rt_task_slice()</a> should be used to toggle round-robin scheduling for an Alchemy task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor. If <em>task</em> is NULL, the time credit of the current task is changed. <em>task</em> must belong to the current process.</td></tr>
    <tr><td class="paramname">quantum</td><td>The round-robin quantum for the task expressed in clock ticks (see note).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a valid task descriptor, or if <em>prio</em> is invalid.</li>
<li>-EPERM is returned if <em>task</em> is NULL and this service was called from an invalid context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must be an Alchemy task if <em>task</em> is NULL.</dd>
<dd>
The <em>quantum</em> value is interpreted as a multiple of the Alchemy clock resolution (see &ndash;alchemy-clock-resolution option, defaults to 1 nanosecond). </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4f9fa3cb09d7f774ebff7585994dffb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_spawn </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and start a real-time task. </p>
<p>This service spawns a task by combining calls to <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992" title="Create a real-time task. ">rt_task_create()</a> and <a class="el" href="group__alchemy__task.html#ga3ee3863a29497e2181d49d5b3ecfd855" title="Start a real-time task. ">rt_task_start()</a> for the new task.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The address of a task descriptor which can be later used to identify uniquely the created object, upon success of this call.</td></tr>
    <tr><td class="paramname">name</td><td>An ASCII string standing for the symbolic name of the task. When non-NULL and non-empty, a copy of this string is used for indexing the created task into the object registry.</td></tr>
    <tr><td class="paramname">stksize</td><td>The size of the stack (in bytes) for the new task. If zero is passed, a system-dependent default size will be substituted.</td></tr>
    <tr><td class="paramname">prio</td><td>The base priority of the new task. This value must be in the [0 .. 99] range, where 0 is the lowest effective priority.</td></tr>
    <tr><td class="paramname">mode</td><td>The task creation mode. See <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992" title="Create a real-time task. ">rt_task_create()</a>.</td></tr>
    <tr><td class="paramname">entry</td><td>The address of the task entry point.</td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined opaque argument <em>entry</em> will receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992" title="Create a real-time task. ">rt_task_create()</a>.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-secondary</a></dd></dl>
<dl class="section user"><dt>Side effects</dt><dd>see <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992" title="Create a real-time task. ">rt_task_create()</a>. </dd></dl>

<p>References <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992">rt_task_create()</a>, and <a class="el" href="group__alchemy__task.html#ga3ee3863a29497e2181d49d5b3ecfd855">rt_task_start()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3ee3863a29497e2181d49d5b3ecfd855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_start </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *arg)&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a real-time task. </p>
<p>This call starts execution of a task previously created by <a class="el" href="group__alchemy__task.html#ga03387550693c21d0223f739570ccd992" title="Create a real-time task. ">rt_task_create()</a>. This service causes the started task to leave the initial dormant state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor.</td></tr>
    <tr><td class="paramname">entry</td><td>The address of the task entry point.</td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined opaque argument <em>entry</em> will receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a valid task descriptor.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Starting an already started task leads to a nop, returning a success status. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cross-link_8c-example.html#a13">cross-link.c</a>.</dd>
</dl>
<p>Referenced by <a class="el" href="group__alchemy__task.html#gaa4f9fa3cb09d7f774ebff7585994dffb">rt_task_spawn()</a>.</p>

</div>
</div>
<a class="anchor" id="ga926a4b10e3631f76c5f38910e6eea24c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_suspend </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend a real-time task. </p>
<p>Forcibly suspend the execution of a task. This task will not be eligible for scheduling until it is explicitly resumed by a call to <a class="el" href="group__alchemy__task.html#ga1fab1aa24ef6f199546fd9669ae711be" title="Resume a real-time task. ">rt_task_resume()</a>. In other words, the suspended state caused by a call to <a class="el" href="group__alchemy__task.html#ga926a4b10e3631f76c5f38910e6eea24c" title="Suspend a real-time task. ">rt_task_suspend()</a> is cumulative with respect to the delayed and blocked states caused by other services, and is managed separately from them.</p>
<p>A nesting count is maintained so that <a class="el" href="group__alchemy__task.html#ga926a4b10e3631f76c5f38910e6eea24c" title="Suspend a real-time task. ">rt_task_suspend()</a> and <a class="el" href="group__alchemy__task.html#ga1fab1aa24ef6f199546fd9669ae711be" title="Resume a real-time task. ">rt_task_resume()</a> must be used in pairs.</p>
<p>Receiving a Linux signal causes the suspended task to resume immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor. If <em>task</em> is NULL, the current task is suspended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is NULL but the caller is not a Xenomai task, or if <em>task</em> is non-NULL but not a valid task descriptor.</li>
<li>-EINTR is returned if a Linux signal has been received by the caller if suspended.</li>
<li>-EPERM is returned if <em>task</em> is NULL and this service was called from an invalid context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller must be an Alchemy task if <em>task</em> is NULL.</dd>
<dd>
Blocked and suspended task states are cumulative. Therefore, suspending a task currently waiting on a synchronization object (e.g. semaphore, queue) holds its execution until it is resumed, despite the awaited resource may have been acquired, or a timeout has elapsed in the meantime. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2038cbe2350a8e2558330a3f45953865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_unbind </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unbind from a task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases a previous binding to an Alchemy task. After this call has returned, the descriptor is no more valid for referencing this object.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">thread-unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga770281eeca009c0a08a7c4a9fd849ac1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_unblock </td>
          <td>(</td>
          <td class="paramtype">RT_TASK *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblock a real-time task. </p>
<p>Break the task out of any wait it is currently in. This call clears all delay and/or resource wait condition for the target task.</p>
<p>However, <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> does not resume a task which has been forcibly suspended by a previous call to <a class="el" href="group__alchemy__task.html#ga926a4b10e3631f76c5f38910e6eea24c" title="Suspend a real-time task. ">rt_task_suspend()</a>. If all suspensive conditions are gone, the task becomes eligible anew for scheduling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>task</em> is not a valid task descriptor.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">unrestricted, switch-primary</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1645d3a072ef3cefeed3bcbb27dcf108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_wait_period </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>overruns_r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the next periodic release point. </p>
<p>Delay the current task until the next periodic release point is reached. The periodic timer should have been previously started for <em>task</em> by a call to <a class="el" href="group__alchemy__task.html#gababee94264156693cd4f5b9b70d3c5a1" title="Make a real-time task periodic. ">rt_task_set_periodic()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overruns_r</td><td>If non-NULL, <em>overruns_r</em> shall be a pointer to a memory location which will be written with the count of pending overruns. This value is written to only when <a class="el" href="group__alchemy__task.html#ga1645d3a072ef3cefeed3bcbb27dcf108" title="Wait for the next periodic release point. ">rt_task_wait_period()</a> returns -ETIMEDOUT or success. The memory location remains unmodified otherwise. If NULL, this count will not be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. If <em>overruns_r</em> is non-NULL, zero is written to the pointed memory location. Otherwise:</dd></dl>
<ul>
<li>-EWOULDBLOCK is returned if <a class="el" href="group__alchemy__task.html#gababee94264156693cd4f5b9b70d3c5a1" title="Make a real-time task periodic. ">rt_task_set_periodic()</a> was not called for the current task.</li>
<li>-EINTR is returned if <a class="el" href="group__alchemy__task.html#ga770281eeca009c0a08a7c4a9fd849ac1" title="Unblock a real-time task. ">rt_task_unblock()</a> was called for the waiting task before the next periodic release point was reached. In this case, the overrun counter is also cleared.</li>
<li>-ETIMEDOUT is returned if a timer overrun occurred, which indicates that a previous release point was missed by the calling task. If <em>overruns_r</em> is non-NULL, the count of pending overruns is written to the pointed memory location.</li>
<li>-EPERM is returned if this service was called from an invalid context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the current release point has already been reached at the time of the call, the current task immediately returns from this service with no delay. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="cross-link_8c-example.html#a7">cross-link.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga31e44b069b2486c2d2bdfb8a0a3557c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rt_task_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manual round-robin. </p>
<p>Move the current task to the end of its priority group, so that the next equal-priority task in ready state is switched in.</p>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-EPERM is returned if this service was called from an invalid context.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="api-tags.html">xthread-only, switch-primary</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
