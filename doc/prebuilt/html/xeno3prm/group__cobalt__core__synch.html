<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Xenomai: Thread synchronization services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cobalt__core__synch.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Thread synchronization services<div class="ingroups"><a class="el" href="group__cobalt.html">Cobalt</a> &raquo; <a class="el" href="group__cobalt__core.html">Cobalt kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Thread synchronization services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__cobalt__core__synch.png" border="0" alt="" usemap="#group____cobalt____core____synch"/>
<map name="group____cobalt____core____synch" id="group____cobalt____core____synch">
<area shape="rect" id="node2" href="group__cobalt__core.html" title="The Cobalt core is a co&#45;kernel which supplements the Linux kernel for delivering real&#45;time services w..." alt="" coords="5,13,104,39"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafc3030603c9054b69f1abb44014f1838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__synch.html#gafc3030603c9054b69f1abb44014f1838">xnsynch_init</a> (struct xnsynch *synch, int flags, <a class="el" href="structatomic__t.html">atomic_t</a> *fastlock)</td></tr>
<tr class="memdesc:gafc3030603c9054b69f1abb44014f1838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a synchronization object.  <a href="#gafc3030603c9054b69f1abb44014f1838">More...</a><br /></td></tr>
<tr class="separator:gafc3030603c9054b69f1abb44014f1838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd862461f55506485f04f4f98cdb6fb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__synch.html#gadd862461f55506485f04f4f98cdb6fb8">xnsynch_destroy</a> (struct xnsynch *synch)</td></tr>
<tr class="memdesc:gadd862461f55506485f04f4f98cdb6fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a synchronization object.  <a href="#gadd862461f55506485f04f4f98cdb6fb8">More...</a><br /></td></tr>
<tr class="separator:gadd862461f55506485f04f4f98cdb6fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51cec970cb57608abe882c98bee72347"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__synch.html#ga51cec970cb57608abe882c98bee72347">xnsynch_sleep_on</a> (struct xnsynch *synch, xnticks_t timeout, xntmode_t timeout_mode)</td></tr>
<tr class="memdesc:ga51cec970cb57608abe882c98bee72347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep on an ownerless synchronization object.  <a href="#ga51cec970cb57608abe882c98bee72347">More...</a><br /></td></tr>
<tr class="separator:ga51cec970cb57608abe882c98bee72347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54162964059c62d7a7b45ef22911662f"><td class="memItemLeft" align="right" valign="top">struct xnthread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__synch.html#ga54162964059c62d7a7b45ef22911662f">xnsynch_wakeup_one_sleeper</a> (struct xnsynch *synch)</td></tr>
<tr class="memdesc:ga54162964059c62d7a7b45ef22911662f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock the heading thread from wait.  <a href="#ga54162964059c62d7a7b45ef22911662f">More...</a><br /></td></tr>
<tr class="separator:ga54162964059c62d7a7b45ef22911662f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8096364cd5d717dae816c74dcc05a8ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__synch.html#ga8096364cd5d717dae816c74dcc05a8ac">xnsynch_wakeup_this_sleeper</a> (struct xnsynch *synch, struct xnthread *sleeper)</td></tr>
<tr class="memdesc:ga8096364cd5d717dae816c74dcc05a8ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock a particular thread from wait.  <a href="#ga8096364cd5d717dae816c74dcc05a8ac">More...</a><br /></td></tr>
<tr class="separator:ga8096364cd5d717dae816c74dcc05a8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43fa3ecdc81f6ae157f840175c7ea091"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__synch.html#ga43fa3ecdc81f6ae157f840175c7ea091">xnsynch_acquire</a> (struct xnsynch *synch, xnticks_t timeout, xntmode_t timeout_mode)</td></tr>
<tr class="memdesc:ga43fa3ecdc81f6ae157f840175c7ea091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the ownership of a synchronization object.  <a href="#ga43fa3ecdc81f6ae157f840175c7ea091">More...</a><br /></td></tr>
<tr class="separator:ga43fa3ecdc81f6ae157f840175c7ea091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5cad7eeaa18834c9ba8843511a67628"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__synch.html#gad5cad7eeaa18834c9ba8843511a67628">xnsynch_try_acquire</a> (struct xnsynch *synch)</td></tr>
<tr class="memdesc:gad5cad7eeaa18834c9ba8843511a67628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try acquiring the ownership of a synchronization object.  <a href="#gad5cad7eeaa18834c9ba8843511a67628">More...</a><br /></td></tr>
<tr class="separator:gad5cad7eeaa18834c9ba8843511a67628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad38fe2be85e02bf1298418674ab6386f"><td class="memItemLeft" align="right" valign="top">struct xnthread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__synch.html#gad38fe2be85e02bf1298418674ab6386f">xnsynch_release</a> (struct xnsynch *synch, struct xnthread *thread)</td></tr>
<tr class="memdesc:gad38fe2be85e02bf1298418674ab6386f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the resource ownership to the next waiting thread.  <a href="#gad38fe2be85e02bf1298418674ab6386f">More...</a><br /></td></tr>
<tr class="separator:gad38fe2be85e02bf1298418674ab6386f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f98598194fa76a8b0ff298387429b9d"><td class="memItemLeft" align="right" valign="top">struct xnthread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__synch.html#ga4f98598194fa76a8b0ff298387429b9d">xnsynch_peek_pendq</a> (struct xnsynch *synch)</td></tr>
<tr class="memdesc:ga4f98598194fa76a8b0ff298387429b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the thread leading a synch object wait queue.  <a href="#ga4f98598194fa76a8b0ff298387429b9d">More...</a><br /></td></tr>
<tr class="separator:ga4f98598194fa76a8b0ff298387429b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51febbfe4ff33ef18778fe9ecf62c43a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__synch.html#ga51febbfe4ff33ef18778fe9ecf62c43a">xnsynch_flush</a> (struct xnsynch *synch, int reason)</td></tr>
<tr class="memdesc:ga51febbfe4ff33ef18778fe9ecf62c43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock all waiters pending on a resource.  <a href="#ga51febbfe4ff33ef18778fe9ecf62c43a">More...</a><br /></td></tr>
<tr class="separator:ga51febbfe4ff33ef18778fe9ecf62c43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga43fa3ecdc81f6ae157f840175c7ea091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnsynch_acquire </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntmode_t&#160;</td>
          <td class="paramname"><em>timeout_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire the ownership of a synchronization object. </p>
<p>This service should be called by upper interfaces wanting the current thread to acquire the ownership of the given resource. If the resource is already assigned to another thread, the caller is suspended.</p>
<p>This service must be used only with synchronization objects that track ownership (XNSYNCH_OWNER set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synch</td><td>The descriptor address of the synchronization object to acquire.</td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout which may be used to limit the time the thread pends on the resource. This value is a wait time given as a count of nanoseconds. It can either be relative, absolute monotonic, or absolute adjustable depending on <em>timeout_mode</em>. Passing XN_INFINITE <b>and</b> setting <em>mode</em> to XN_RELATIVE specifies an unbounded wait. All other values are used to initialize a watchdog timer.</td></tr>
    <tr><td class="paramname">timeout_mode</td><td>The mode of the <em>timeout</em> parameter. It can either be set to XN_RELATIVE, XN_ABSOLUTE, or XN_REALTIME (see also <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b" title="Arm a timer. ">xntimer_start()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bitmask which may include zero or one information bit among XNRMID, XNTIMEO and XNBREAK, which should be tested by the caller, for detecting respectively: object deletion, timeout or signal/unblock conditions which might have happened while waiting.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike <a class="el" href="group__cobalt__core__synch.html#gad5cad7eeaa18834c9ba8843511a67628" title="Try acquiring the ownership of a synchronization object. ">xnsynch_try_acquire()</a>, this call does NOT check for invalid recursive locking request, which means that such request will always cause a deadlock for the caller. </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__states.html#gaca3bcd5615c7331c73c3eadddb3d1b89">XNBOOST</a>, <a class="el" href="group__cobalt__core__thread__info.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, <a class="el" href="group__cobalt__core__thread__info.html#gab07d9dea73645dbba353dc2452c15b40">XNRMID</a>, <a class="el" href="group__cobalt__core__thread__info.html#gad28db508d297929d6a0ec30964639d65">XNROBBED</a>, <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>, <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc">xnthread_suspend()</a>, <a class="el" href="group__cobalt__core__thread__info.html#gaa11d7fc754db50d3a1f1e41611d324e9">XNTIMEO</a>, and <a class="el" href="group__cobalt__core__thread__info.html#ga53e49fa49b312e5266b31d66f7465d44">XNWAKEN</a>.</p>

<p>Referenced by <a class="el" href="group__rtdm__sync__mutex.html#ga0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock()</a>.</p>

</div>
</div>
<a class="anchor" id="gadd862461f55506485f04f4f98cdb6fb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnsynch_destroy </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>synch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a synchronization object. </p>
<p>Destroys the synchronization object <em>synch</em>, unblocking all waiters with the XNRMID status.</p>
<dl class="section return"><dt>Returns</dt><dd>XNSYNCH_RESCHED is returned if at least one thread is unblocked, which means the caller should invoke <a class="el" href="group__cobalt__core__sched.html#gab51b1711cd73d890278e3998c817cc3a" title="The rescheduling procedure. ">xnsched_run()</a> for applying the new scheduling state. Otherwise, XNSYNCH_DONE is returned.</dd></dl>
<dl class="section user"><dt>Side effects</dt><dd>Same as <a class="el" href="group__cobalt__core__synch.html#ga51febbfe4ff33ef18778fe9ecf62c43a" title="Unblock all waiters pending on a resource. ">xnsynch_flush()</a>.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__info.html#gab07d9dea73645dbba353dc2452c15b40">XNRMID</a>, and <a class="el" href="group__cobalt__core__synch.html#ga51febbfe4ff33ef18778fe9ecf62c43a">xnsynch_flush()</a>.</p>

</div>
</div>
<a class="anchor" id="ga51febbfe4ff33ef18778fe9ecf62c43a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnsynch_flush </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblock all waiters pending on a resource. </p>
<p>This service atomically releases all threads which currently sleep on a given resource.</p>
<p>This service should be called by upper interfaces under circumstances requiring that the pending queue of a given resource is cleared, such as before the resource is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synch</td><td>The descriptor address of the synchronization object to be flushed.</td></tr>
    <tr><td class="paramname">reason</td><td>Some flags to set in the information mask of every unblocked thread. Zero is an acceptable value. The following bits are pre-defined by the nucleus:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNRMID should be set to indicate that the synchronization object is about to be destroyed (see <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115" title="Resume a thread. ">xnthread_resume()</a>).</li>
<li>XNBREAK should be set to indicate that the wait has been forcibly interrupted (see <a class="el" href="group__cobalt__core__thread.html#ga8fe02cbf0d0cebc0ca9d9522bc58e65a" title="Unblock a thread. ">xnthread_unblock()</a>).</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>XNSYNCH_RESCHED is returned if at least one thread is unblocked, which means the caller should invoke <a class="el" href="group__cobalt__core__sched.html#gab51b1711cd73d890278e3998c817cc3a" title="The rescheduling procedure. ">xnsched_run()</a> for applying the new scheduling state. Otherwise, XNSYNCH_DONE is returned.</dd></dl>
<dl class="section user"><dt>Side effects</dt><dd></dd></dl>
<ul>
<li>The effective priority of the previous resource owner might be lowered to its base priority value as a consequence of the priority inheritance boost being cleared.</li>
<li>After this operation has completed, the synchronization object is not owned by any thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__states.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, and <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115">xnthread_resume()</a>.</p>

<p>Referenced by <a class="el" href="group__rtdm__sync__event.html#ga1217402b82034b26fe25c26f1e5b32c9">rtdm_event_signal()</a>, and <a class="el" href="group__cobalt__core__synch.html#gadd862461f55506485f04f4f98cdb6fb8">xnsynch_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="gafc3030603c9054b69f1abb44014f1838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_init </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structatomic__t.html">atomic_t</a> *&#160;</td>
          <td class="paramname"><em>fastlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a synchronization object. </p>
<p>Initializes a synchronization object. Xenomai threads can wait on and signal such objects for serializing access to resources. This object has built-in support for priority inheritance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synch</td><td>The address of a synchronization object descriptor the nucleus will use to store the object-specific data. This descriptor must always be valid while the object is active therefore it must be allocated in permanent memory.</td></tr>
    <tr><td class="paramname">flags</td><td>A set of creation flags affecting the operation. The valid flags are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNSYNCH_PRIO causes the threads waiting for the resource to pend in priority order. Otherwise, FIFO ordering is used (XNSYNCH_FIFO).</li>
<li>XNSYNCH_OWNER indicates that the synchronization object shall track the resource ownership, allowing a single owner at most at any point in time. Note that setting this flag implies the use of <a class="el" href="group__cobalt__core__synch.html#ga43fa3ecdc81f6ae157f840175c7ea091" title="Acquire the ownership of a synchronization object. ">xnsynch_acquire()</a> and <a class="el" href="group__cobalt__core__synch.html#gad38fe2be85e02bf1298418674ab6386f" title="Give the resource ownership to the next waiting thread. ">xnsynch_release()</a> instead of <a class="el" href="group__cobalt__core__synch.html#ga51cec970cb57608abe882c98bee72347" title="Sleep on an ownerless synchronization object. ">xnsynch_sleep_on()</a> and xnsynch_wakeup_*().</li>
<li>XNSYNCH_PIP enables priority inheritance when a priority inversion is detected among threads using this object. XNSYNCH_PIP enables XNSYNCH_OWNER and XNSYNCH_PRIO implicitly.</li>
<li>XNSYNCH_DREORD (Disable REORDering) tells the nucleus that the wait queue should not be reordered whenever the priority of a blocked thread it holds is changed. If this flag is not specified, changing the priority of a blocked thread using <a class="el" href="group__cobalt__core__thread.html#gafb78d40c8065b8569fafe7e24960742e" title="Change the base scheduling parameters of a thread. ">xnthread_set_schedparam()</a> will cause this object's wait queue to be reordered according to the new priority level, provided the synchronization object makes the waiters wait by priority order on the awaited resource (XNSYNCH_PRIO).</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fastlock</td><td>Address of the fast lock word to be associated with a synchronization object with ownership tracking. Therefore, a valid fast-lock address is required if XNSYNCH_OWNER is set in <em>flags</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

<p>Referenced by <a class="el" href="group__rtdm__sync__event.html#gaddf08d8ba5a44668bb360070a114fb19">rtdm_event_init()</a>, <a class="el" href="group__rtdm__sync__mutex.html#ga8d58a144bf71df7b38bb887d036cbbb5">rtdm_mutex_init()</a>, <a class="el" href="group__rtdm__sync__sem.html#gae1172824e463d7705ed3033e8aea133d">rtdm_sem_init()</a>, and <a class="el" href="group__cobalt__core__select.html#gaf5576af13d5ffd6056311c2746a706a0">xnselector_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f98598194fa76a8b0ff298387429b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnthread * xnsynch_peek_pendq </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>synch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the thread leading a synch object wait queue. </p>
<p>This services returns the descriptor address of to the thread leading a synchronization object wait queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synch</td><td>The descriptor address of the target synchronization object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The descriptor address of the unblocked thread.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad38fe2be85e02bf1298418674ab6386f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnthread * xnsynch_release </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give the resource ownership to the next waiting thread. </p>
<p>This service releases the ownership of the given synchronization object. The thread which is currently leading the object's pending list, if any, is unblocked from its pending state. However, no reschedule is performed.</p>
<p>This service must be used only with synchronization objects that track ownership (XNSYNCH_OWNER set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synch</td><td>The descriptor address of the synchronization object whose ownership is changed.</td></tr>
    <tr><td class="paramname">thread</td><td>The descriptor address of the current owner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The descriptor address of the unblocked thread.</dd></dl>
<dl class="section user"><dt>Side effects</dt><dd></dd></dl>
<ul>
<li>The effective priority of the previous resource owner might be lowered to its base priority value as a consequence of the priority inheritance boost being cleared.</li>
<li>The synchronization object ownership is transfered to the unblocked thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

<p>Referenced by <a class="el" href="group__rtdm__sync__mutex.html#gab40ed579324d8cc76387a0e06dd0f82a">rtdm_mutex_unlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ga51cec970cb57608abe882c98bee72347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnsynch_sleep_on </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntmode_t&#160;</td>
          <td class="paramname"><em>timeout_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleep on an ownerless synchronization object. </p>
<p>Makes the calling thread sleep on the specified synchronization object, waiting for it to be signaled.</p>
<p>This service should be called by upper interfaces wanting the current thread to pend on the given resource. It must not be used with synchronization objects that are supposed to track ownership (XNSYNCH_OWNER).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synch</td><td>The descriptor address of the synchronization object to sleep on.</td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout which may be used to limit the time the thread pends on the resource. This value is a wait time given as a count of nanoseconds. It can either be relative, absolute monotonic, or absolute adjustable depending on <em>timeout_mode</em>. Passing XN_INFINITE <b>and</b> setting <em>mode</em> to XN_RELATIVE specifies an unbounded wait. All other values are used to initialize a watchdog timer.</td></tr>
    <tr><td class="paramname">timeout_mode</td><td>The mode of the <em>timeout</em> parameter. It can either be set to XN_RELATIVE, XN_ABSOLUTE, or XN_REALTIME (see also <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b" title="Arm a timer. ">xntimer_start()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A bitmask which may include zero or one information bit among XNRMID, XNTIMEO and XNBREAK, which should be tested by the caller, for detecting respectively: object deletion, timeout or signal/unblock conditions which might have happened while waiting.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__info.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, <a class="el" href="group__cobalt__core__thread__info.html#gab07d9dea73645dbba353dc2452c15b40">XNRMID</a>, <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>, <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc">xnthread_suspend()</a>, <a class="el" href="group__cobalt__core__thread__info.html#gaa11d7fc754db50d3a1f1e41611d324e9">XNTIMEO</a>, and <a class="el" href="group__cobalt__core__thread__states.html#ga44a2c7ec314961aacb1934636cb33482">XNWARN</a>.</p>

<p>Referenced by <a class="el" href="group__rtdm__sync__event.html#gaf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait()</a>, <a class="el" href="group__rtdm__sync__sem.html#ga8aadb120a93df5dfd717c5bac6d4c1a9">rtdm_sem_timeddown()</a>, <a class="el" href="group__cobalt__core__registry.html#ga03ceaaa3cb5799a6b706dc9a65f493e5">xnregistry_bind()</a>, and <a class="el" href="group__cobalt__core__select.html#ga4af23e0a42dbc61a04be36d5739a165f">xnselect()</a>.</p>

</div>
</div>
<a class="anchor" id="gad5cad7eeaa18834c9ba8843511a67628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnsynch_try_acquire </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>synch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try acquiring the ownership of a synchronization object. </p>
<p>This service should be called by upper interfaces wanting the current thread to acquire the ownership of the given resource. If the resource is already assigned to another thread, the call returns with an error code.</p>
<p>This service must be used only with synchronization objects that track ownership (XNSYNCH_OWNER set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synch</td><td>The descriptor address of the synchronization object to acquire.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero is returned if <em>synch</em> has been successfully acquired. Otherwise:</dd></dl>
<ul>
<li>-EDEADLK is returned if <em>synch</em> is currently held by the calling thread.</li>
<li>-EBUSY is returned if <em>synch</em> is currently held by another thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>.</p>

<p>Referenced by <a class="el" href="group__rtdm__sync__mutex.html#ga0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock()</a>.</p>

</div>
</div>
<a class="anchor" id="ga54162964059c62d7a7b45ef22911662f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct xnthread * xnsynch_wakeup_one_sleeper </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>synch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblock the heading thread from wait. </p>
<p>This service wakes up the thread which is currently leading the synchronization object's pending list. The sleeping thread is unblocked from its pending state, but no reschedule is performed.</p>
<p>This service should be called by upper interfaces wanting to signal the given resource so that a single waiter is resumed. It must not be used with synchronization objects that are supposed to track ownership (XNSYNCH_OWNER not set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synch</td><td>The descriptor address of the synchronization object whose ownership is changed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The descriptor address of the unblocked thread.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__states.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, and <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115">xnthread_resume()</a>.</p>

<p>Referenced by <a class="el" href="group__rtdm__sync__sem.html#ga829dbd8c5709d798ed06947b27001fed">rtdm_sem_up()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8096364cd5d717dae816c74dcc05a8ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnsynch_wakeup_this_sleeper </td>
          <td>(</td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>synch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>sleeper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblock a particular thread from wait. </p>
<p>This service wakes up a specific thread which is currently pending on the given synchronization object. The sleeping thread is unblocked from its pending state, but no reschedule is performed.</p>
<p>This service should be called by upper interfaces wanting to signal the given resource so that a specific waiter is resumed. It must not be used with synchronization objects that are supposed to track ownership (XNSYNCH_OWNER not set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synch</td><td>The descriptor address of the synchronization object whose ownership is changed.</td></tr>
    <tr><td class="paramname">sleeper</td><td>The thread to unblock which MUST be currently linked to the synchronization object's pending queue (i.e. synch-&gt;pendq).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__states.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, and <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115">xnthread_resume()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
